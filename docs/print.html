<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>MASQ Rust Docs</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Welcome!</a></li><li class="chapter-item expanded "><a href="ch-01-introduction/main.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch-01-introduction/pg-01-benefits-of-using-rust.html"><strong aria-hidden="true">1.1.</strong> Benefits of using rust</a></li><li class="chapter-item expanded "><a href="ch-01-introduction/pg-02-the-hello-world-program.html"><strong aria-hidden="true">1.2.</strong> The Hello World Program</a></li></ol></li><li class="chapter-item expanded "><a href="ch-02-basics-of-rust/main.html"><strong aria-hidden="true">2.</strong> Basics of Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch-02-basics-of-rust/pg-01-variables-and-mutability.html"><strong aria-hidden="true">2.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch-02-basics-of-rust/pg-02-data-types.html"><strong aria-hidden="true">2.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch-02-basics-of-rust/pg-03-advanced-data-types.html"><strong aria-hidden="true">2.3.</strong> Advanced Data Types</a></li><li class="chapter-item expanded "><a href="ch-02-basics-of-rust/pg-04-functions.html"><strong aria-hidden="true">2.4.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch-02-basics-of-rust/pg-05-control-flow.html"><strong aria-hidden="true">2.5.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="ch-02-basics-of-rust/pg-06-loops.html"><strong aria-hidden="true">2.6.</strong> Loops</a></li><li class="chapter-item expanded "><a href="ch-02-basics-of-rust/pg-07-ownership.html"><strong aria-hidden="true">2.7.</strong> Ownership</a></li><li class="chapter-item expanded "><a href="ch-02-basics-of-rust/pg-08-borrowing.html"><strong aria-hidden="true">2.8.</strong> Borrowing</a></li><li class="chapter-item expanded "><a href="ch-02-basics-of-rust/pg-09-structs.html"><strong aria-hidden="true">2.9.</strong> Structs</a></li><li class="chapter-item expanded "><a href="ch-02-basics-of-rust/pg-10-enums.html"><strong aria-hidden="true">2.10.</strong> Enums</a></li><li class="chapter-item expanded "><a href="ch-02-basics-of-rust/pg-11-pattern-matching.html"><strong aria-hidden="true">2.11.</strong> Pattern Matching</a></li></ol></li><li class="chapter-item expanded "><a href="ch-03-common-collections/main.html"><strong aria-hidden="true">3.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch-03-common-collections/pg-01-vector.html"><strong aria-hidden="true">3.1.</strong> Vector</a></li><li class="chapter-item expanded "><a href="ch-03-common-collections/pg-02-hashmaps.html"><strong aria-hidden="true">3.2.</strong> HashMaps</a></li></ol></li><li class="chapter-item expanded "><a href="ch-04-project-structuring-and-error-handling/main.html"><strong aria-hidden="true">4.</strong> Project Structuring and Error Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch-04-project-structuring-and-error-handling/pg-01-project-structuring.html"><strong aria-hidden="true">4.1.</strong> Project Structuring</a></li><li class="chapter-item expanded "><a href="ch-04-project-structuring-and-error-handling/pg-02-modularizing.html"><strong aria-hidden="true">4.2.</strong> Modularizing</a></li><li class="chapter-item expanded "><a href="ch-04-project-structuring-and-error-handling/pg-03-error-handling.html"><strong aria-hidden="true">4.3.</strong> Error Handling</a></li></ol></li><li class="chapter-item expanded "><a href="ch-05-medium-concepts/main.html"><strong aria-hidden="true">5.</strong> Medium Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch-05-medium-concepts/pg-01-generics.html"><strong aria-hidden="true">5.1.</strong> Generics</a></li><li class="chapter-item expanded "><a href="ch-05-medium-concepts/pg-02-traits.html"><strong aria-hidden="true">5.2.</strong> Traits</a></li><li class="chapter-item expanded "><a href="ch-05-medium-concepts/pg-03-lifetimes.html"><strong aria-hidden="true">5.3.</strong> Lifetimes</a></li><li class="chapter-item expanded "><a href="ch-05-medium-concepts/pg-04-functional-language-features.html"><strong aria-hidden="true">5.4.</strong> Functional Language Features</a></li><li class="chapter-item expanded "><a href="ch-05-medium-concepts/pg-05-smart-pointers.html"><strong aria-hidden="true">5.5.</strong> Smart Pointers</a></li><li class="chapter-item expanded "><a href="ch-05-medium-concepts/pg-06-concurrency.html"><strong aria-hidden="true">5.6.</strong> Concurrency</a></li><li class="chapter-item expanded "><a href="ch-05-medium-concepts/pg-07-object-oriented-programming.html"><strong aria-hidden="true">5.7.</strong> Object Oriented Programming</a></li></ol></li><li class="chapter-item expanded "><a href="ch-06-advanced-concepts/main.html"><strong aria-hidden="true">6.</strong> Advanced Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch-06-advanced-concepts/pg-01-advanced-pattern-matching.html"><strong aria-hidden="true">6.1.</strong> Advanced Pattern Matching</a></li><li class="chapter-item expanded "><a href="ch-06-advanced-concepts/pg-02-unsafe-rust.html"><strong aria-hidden="true">6.2.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch-06-advanced-concepts/pg-03-advanced-traits.html"><strong aria-hidden="true">6.3.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch-06-advanced-concepts/pg-04-advanced-types.html"><strong aria-hidden="true">6.4.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch-06-advanced-concepts/pg-05-advanced-functions-and-closures.html"><strong aria-hidden="true">6.5.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="ch-06-advanced-concepts/pg-06-macros.html"><strong aria-hidden="true">6.6.</strong> Macros</a></li><li class="chapter-item expanded "><a href="ch-06-advanced-concepts/pg-07-miscellaneous.html"><strong aria-hidden="true">6.7.</strong> Miscellaneous</a></li></ol></li><li class="chapter-item expanded "><a href="ch-07-rust-tests/main.html"><strong aria-hidden="true">7.</strong> Rust Tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch-07-rust-tests/pg-01-getting-started.html"><strong aria-hidden="true">7.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="ch-07-rust-tests/pg-02-controlling-tests.html"><strong aria-hidden="true">7.2.</strong> Controlling Tests</a></li><li class="chapter-item expanded "><a href="ch-07-rust-tests/pg-03-test-organization.html"><strong aria-hidden="true">7.3.</strong> Test Organization</a></li><li class="chapter-item expanded "><a href="ch-07-rust-tests/pg-04-test-driven-development.html"><strong aria-hidden="true">7.4.</strong> Test Driven Development</a></li></ol></li><li class="chapter-item expanded "><a href="ch-08-useful-snippets/main.html"><strong aria-hidden="true">8.</strong> Useful Snippets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch-08-useful-snippets/pg-01-useful-operations.html"><strong aria-hidden="true">8.1.</strong> Useful Operations</a></li><li class="chapter-item expanded "><a href="ch-08-useful-snippets/pg-02-useful-functions.html"><strong aria-hidden="true">8.2.</strong> Useful Functions</a></li><li class="chapter-item expanded "><a href="ch-08-useful-snippets/pg-03-useful-macros.html"><strong aria-hidden="true">8.3.</strong> Useful Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch-09-masq-rust-tools/main.html"><strong aria-hidden="true">9.</strong> MASQ Rust Tools</a></li><li class="chapter-item expanded "><a href="ch-10-appendix/main.html"><strong aria-hidden="true">10.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch-10-appendix/pg-01-installation.html"><strong aria-hidden="true">10.1.</strong> Installaiton</a></li><li class="chapter-item expanded "><a href="ch-10-appendix/pg-02-basic-rust-commands.html"><strong aria-hidden="true">10.2.</strong> Basic Rust Commands</a></li><li class="chapter-item expanded "><a href="ch-10-appendix/pg-03-conventions-in-rust.html"><strong aria-hidden="true">10.3.</strong> Conventions in Rust</a></li><li class="chapter-item expanded "><a href="ch-10-appendix/pg-04-documentation.html"><strong aria-hidden="true">10.4.</strong> Documentation</a></li><li class="chapter-item expanded "><a href="ch-10-appendix/pg-05-cargo.html"><strong aria-hidden="true">10.5.</strong> Cargo</a></li><li class="chapter-item expanded "><a href="ch-10-appendix/pg-06-editions-in-rust.html"><strong aria-hidden="true">10.6.</strong> Editions in Rust</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">MASQ Rust Docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome"><a class="header" href="#welcome">Welcome</a></h1>
<p>This book is written by the Rust Dev Team at MASQ.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This section will introduce you with the benefits of using rust and will tell you why you should learn this programming language.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="benefits-of-using-rust"><a class="header" href="#benefits-of-using-rust">Benefits of using rust</a></h1>
<ul>
<li>Memory Safe
<ul>
<li>Chromium Project has 70% vulnerabilities related to Memory.</li>
<li>C/C++ doesn’t provide Memory Safety</li>
<li>Python, JS provides Memory Safety but uses Garbage Collector</li>
<li>Rust provides Memory Safety without using Garbage Collector.</li>
<li>Rust achieves this functionality by making the language typed, thus the code won’t compile if any vulnerability will exist.</li>
</ul>
</li>
<li>No Null Types or No Null Pointers
<ul>
<li>Null Pointers in C are used as <code>*ptr = NULL</code>.</li>
<li>Rust uses it’s rich type system to represent the absence of a value.</li>
</ul>
</li>
<li>No Exceptions
<ul>
<li>Rust Provides No Direct Referencing, No Pointers and No Pointer Exceptions.</li>
</ul>
</li>
<li>Modern Package Manager
<ul>
<li>It uses Package Manager named <em>Cargo</em>.</li>
</ul>
</li>
<li>No Data Race
<ul>
<li>A data race occurs when:
<ul>
<li>two or more threads in a <strong>single process</strong> access the same memory location concurrently, and</li>
<li>at least one of the accesses is for writing, and</li>
<li>the threads are not using any exclusive locks to control their accesses to that memory</li>
</ul>
</li>
<li>Game Changer for writing Asynchronous Code</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-hello-world-program"><a class="header" href="#the-hello-world-program">The <code>&quot;Hello, World!&quot;</code> program</a></h1>
<p>Fun Fact: Rust is an ahead-of-time compiled language, meaning you can compile a program and give the executable to someone else, and they can run it even without having Rust installed.</p>
<ul>
<li>
<p>After <a href="ch-01-introduction/pg-02-the-hello-world-program.html#installation">installing Rust</a>, you may follow the following steps.</p>
</li>
<li>
<p>Create a project folder, cd into it and create <code>main.rs</code> file:</p>
<pre><code class="language-zsh">mkdir hello_world
cd hello_world
touch main.rs
</code></pre>
</li>
<li>
<p>Add the following program inside of it:</p>
<pre><pre class="playground"><code class="language-rust">// Filename: main.rs
fn main() {
    println!(&quot;Hello, world!&quot;);
}</code></pre></pre>
</li>
<li>
<p>Some facts regarding the above code.</p>
<ul>
<li>Main function is the first function that gets called.</li>
<li><code>println!()</code> is not a function but a <em>macro</em>.</li>
<li>Macros contain an <code>!</code> mark.</li>
</ul>
</li>
<li>
<p>Compile and run the file:</p>
<pre><code class="language-zsh">rustc main.rs
</code></pre>
<ul>
<li>
<p>For Linux and macOS:</p>
<pre><code class="language-zsh">./main
</code></pre>
</li>
<li>
<p>For Windows:</p>
<pre><code class="language-zsh">.\main
</code></pre>
</li>
</ul>
</li>
<li>
<p>Alternatively, you may use the package manager <a href="ch-01-introduction/pg-02-the-hello-world-program.html#cargo">Cargo</a> to create new boilerplate projects.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics-of-rust"><a class="header" href="#basics-of-rust">Basics of Rust</a></h1>
<p>In this Chapter you'll learn about the common programming concepts like functions, conditionals etc. along with some unique Rust concepts like borrowing, ownership and pattern matching.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="variables-and-mutability"><a class="header" href="#variables-and-mutability">Variables and Mutability</a></h2>
<h3 id="variables"><a class="header" href="#variables">Variables</a></h3>
<ul>
<li>
<p>By default variables are immutable in Rust.</p>
</li>
<li>
<p>Its advantages includes memory safety and easy concurrency.</p>
</li>
<li>
<p>Example of immutable variable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Example of mutable variable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 5;
x = 6;
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h3 id="constants"><a class="header" href="#constants">Constants</a></h3>
<ul>
<li>First, you aren’t allowed to use mut with constants.</li>
<li>Constants aren’t just immutable by default—they’re always immutable.</li>
<li>Constants can be declared in any scope, including the global scope, which makes them useful for values that many parts of code need to know about.</li>
<li>Constants may be set only to a constant expression, not the result of a value that could only be computed at runtime.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Rust’s naming convention for constants is to use all uppercase with underscores between words.</li>
<li>See the <a href="https://doc.rust-lang.org/reference/const_eval.html">Rust Reference’s section on constant evaluation</a> for more information on what operations can be used when declaring constants.</li>
</ul>
<h3 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h3>
<ul>
<li>
<p>You can declare a new variable with the same name as a previous variable, it's called <em>shadowing</em>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5; // Binding x to value 5

    let x = x + 1; // Declaring a variable named x again, thereby performing shadowing

    {
        let x = x * 2; // Shadowing x again, but within the scope
        println!(&quot;The value of x in the inner scope is: {}&quot;, x);
    }

    println!(&quot;The value of x is: {}&quot;, x);
}

// Output:
// The value of x in the inner scope is: 12
// The value of x is: 6</code></pre></pre>
</li>
<li>
<p>In shadowing, we can make a few transformations on a value but have the variable be immutable, unlike <code>let mut</code>.</p>
</li>
<li>
<p>You can perform type conversions and still keep the same name.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Shadowing compiles without errors
let spaces = &quot;   &quot;;
let spaces = spaces.len();

// It's not possible to change type of a mutable Variables
let mut spaces = &quot;   &quot;;
spaces = spaces.len(); // This line won't compile
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h3 id="shadowing-vs-mutable-variables"><a class="header" href="#shadowing-vs-mutable-variables">Shadowing Vs Mutable Variables</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Shadowing</th><th>Mutable Variables</th></tr></thead><tbody>
<tr><td>Transform a variable but still keep it as immutable.</td><td>We only make transformations after making variable mutable.</td></tr>
<tr><td>We need to declare variable with <code>let</code> everytime we perform shadowing.</td><td>We need to declare variable with only <code>let mut</code> once.</td></tr>
<tr><td>It is possible to change the type of variable and keep the same name.</td><td>It is not possible to change the type of mutable variable.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="data-types"><a class="header" href="#data-types">Data Types</a></h2>
<ul>
<li>Every value in Rust is of a certain <em>data type</em>, that makes Rust a <em>statically typed language</em>.</li>
<li>It means Rust needs to know the type of all variables at compile time.</li>
<li>Rust data types has two subsets:
<ol>
<li>Scalar</li>
<li>Compound</li>
</ol>
</li>
</ul>
<h3 id="scalar-data-types"><a class="header" href="#scalar-data-types">Scalar Data Types</a></h3>
<ul>
<li>
<p>Booleans</p>
<ul>
<li>Represented by <code>bool</code>, has two values <code>true</code> and <code>false</code>.</li>
</ul>
</li>
<li>
<p>Characters</p>
<ul>
<li>Represented by <code>char</code>, it always has space of <code>4</code> bytes or <code>32</code> bits instead of 1 byte.</li>
<li>Characters are UTF-8 encoded, thus supports <code>'z', 'ℤ', '😻'</code>.</li>
<li>Characters use single quotes and string uses double quotes.</li>
</ul>
</li>
<li>
<p>Integers</p>
<ul>
<li><code>u</code> means unsigned (only positive), <code>i</code> means signed (both positive &amp; negative)</li>
<li>The size ranges from <code>8</code> bits to <code>128</code> bits.</li>
<li>Range of Unsigned Integers is:
$$ [0, 2^n - 1] $$</li>
<li>Range of Signed Integer is:
$$ [- 2^{n-1}, 2^{n-1} - 1]$$</li>
<li>Examples, <code>u8</code>, <code>i8</code>, <code>u128</code>, <code>i128</code></li>
<li>Rust also supports, <code>usize</code> and <code>isize</code> which means that it will take up space according to the architecture whether it is 32 bit or 64 bit.</li>
<li>You may also represent integer literals in the below forms:</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Number literals</th><th>Example</th><th>Integer</th></tr></thead><tbody>
<tr><td>Decimal</td><td>98_222</td><td>98222</td></tr>
<tr><td>Hex</td><td>0xff</td><td>255</td></tr>
<tr><td>Octal</td><td>0o77</td><td>63</td></tr>
<tr><td>Binary</td><td>0b1111_0000</td><td>240</td></tr>
<tr><td>Byte (u8 only)</td><td>b'A'</td><td>65</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>Integer types default to <code>i32</code>.</p>
</li>
<li>
<p>To read how Interger Overflow works in Rust, please follow <a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-overflow">this link</a>.</p>
</li>
<li>
<p>Division of integers gives floored value, <code>3 / 2 == 1</code>.</p>
</li>
<li>
<p>Floats</p>
<ul>
<li>It has <code>f32</code> and <code>f64</code>, two floating data types for size <code>32</code> and <code>64</code>.</li>
<li>Floating types default to <code>f64</code>.</li>
<li>Division of floats give fractional result, <code>3.0 / 2. 0 = 1.5</code>.</li>
</ul>
</li>
</ul>
<h3 id="compound-data-types"><a class="header" href="#compound-data-types">Compound Data Types</a></h3>
<ul>
<li>
<p>There are two compound data types in Rust:</p>
<ol>
<li>Tuples</li>
<li>Arrays</li>
</ol>
</li>
</ul>
<h4 id="tuples"><a class="header" href="#tuples">Tuples</a></h4>
<ul>
<li>
<p>They can store number of values with different data types.</p>
</li>
<li>
<p>They can't grow or shrink once declared.</p>
</li>
<li>
<p>Tuples can be declared as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tup_with_types: (i32, f64, u8) = (500, 6.4, 1);
let tup = (500, 6.4, 1);

// Destructuring Tuples
let (x, y, z) = tup;

// Destructuing Tuples using .
let x: (i32, f64, u8) = (500, 6.4, 1);
let five_hundred = x.0;
let six_point_four = x.1;
let one = x.2;

// Unit type tuple with unit value
let unit_tup = ();
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h4 id="array"><a class="header" href="#array">Array</a></h4>
<ul>
<li>
<p>They can store number of values with same data type.</p>
</li>
<li>
<p>They can't grow or shrink once declared as their memory is allocated on stack.</p>
</li>
<li>
<p>If you want a similar data structure that can grow or shrink then use Vectors.</p>
</li>
<li>
<p>If you access an index of array that is greater than it's length, it'll result in <code>'index out of bounds'</code>.</p>
</li>
<li>
<p>In other low level languages, this check is not done and they return an invalid memory.</p>
</li>
<li>
<p>Arrays can be declared as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Simple array declaration
let a = [1, 2, 3, 4, 5];

// Declaring array with type and size
let a: [i32; 5] = [1, 2, 3, 4, 5];

// Declaring same value 3 for 5 elements
let a = [3; 5];

// Accessing Values of array
let a = [1, 2, 3, 4, 5];
let first = a[0];
let second = a[1];
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h4 id="slicing-an-array"><a class="header" href="#slicing-an-array">Slicing an array</a></h4>
<ul>
<li>
<p>It is possible to slice an array in Rust.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3]; // It is of type &amp;[i32]
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h4 id="ranges"><a class="header" href="#ranges">Ranges</a></h4>
<ul>
<li>You can create a range with <code>..</code> operator.</li>
<li>The following are equal:
<ul>
<li><code>1..5</code> ~ <code>1..=4</code></li>
<li><code>0..4</code> ~ <code>..4</code></li>
<li><code>1..len</code> ~ <code>1..</code></li>
<li><code>0..len</code> ~ <code>..</code></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="advanced-data-types"><a class="header" href="#advanced-data-types">Advanced Data Types</a></h2>
<h4 id="strings"><a class="header" href="#strings">Strings</a></h4>
<ul>
<li>
<p>They are represented in three types:</p>
<ul>
<li>
<p><code>String</code> - A smart pointer.</p>
</li>
<li>
<p><code>&amp;String</code> - Reference to a String.</p>
</li>
<li>
<p><code>&amp;str</code> - String Slice</p>
</li>
<li>
<p>Defining a String</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let string = String::new(&quot;127.0.0.1:8080&quot;); // It can grow and shrink
let string_literal = &quot;1234&quot;; // It's memory is fixed at runtime
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Slicing a string</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let string = String::from(&quot;127.0.0.1:8080&quot;);
let string_slice = &amp;string[10..14]; // We can also use &amp;string[10..]

// We can also use
let string_slice = &amp;string[10..]; // Give me everything after 10th byte not character
let string_slice = &amp;string[..12]; // Give me everything upto 12th byte not character
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Rust uses UTF-8 encoding. So, prefer not to not pass integer values for slicing, as the slice function slices on the basis of bytes instead of characters.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let string = String::from(&quot;😀😃😄😁&quot;);
let string_slice = &amp;string[..4];
<span class="boring">}</span></code></pre></pre>
<p>For this slice instead of returning 4 emojis, the rust will return 1 emoji because it takes 4 bytes to store an emoji.</p>
<pre><code class="language-zsh">string_slice = &quot;😀&quot;
</code></pre>
</li>
<li>
<p>Strings in rust can dynamically grow or shrink.</p>
</li>
<li>
<p>We can borrow an entire string by using this syntax</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let string = String::from(&quot;127.0.0.1:8080&quot;);
let string_borrow: &amp;str = &amp;string;
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
</li>
<li>
<p>This is how <code>let s1 = String::from(&quot;hello&quot;);</code> is stored in Rust:</p>
<ul>
<li>Left - Parts of String that are stored on the stack:
<ol>
<li>Pointer: Points to the memory that holds the contents of the string.</li>
<li>Length: How much memory, in bytes, the contents of the String is currently using.</li>
<li>Capacity: The total amount of memory, in bytes, that the String has received from the allocator.</li>
</ol>
</li>
<li>Right - The memory on the heap that holds the contents.</li>
</ul>
<p><img src="https://doc.rust-lang.org/book/img/trpl04-01.svg" alt="Image" /></p>
</li>
</ul>
<h2 id="string-slicing"><a class="header" href="#string-slicing">String Slicing</a></h2>
<ul>
<li>
<p>Slices let you reference a contiguous sequence of elements in a collection rather than the whole collection.</p>
</li>
<li>
<p>A slice is a kind of reference, so it does not have ownership.</p>
</li>
<li>
<p>Slices are represented by <code>&amp;str</code> and are <em>immutable</em>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let s = String::from(&quot;hello world&quot;);

    let hello = &amp;s[0..5]; // or you can use &amp;s[..5]
    let world = &amp;s[6..11];
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>This will throw compile-time error:</p>
<pre><pre class="playground"><code class="language-rust">// FAIL: You cannot clear the memory, to which some reference already exists
fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s); // Returns a &amp;str, which is a referenc to s

    s.clear(); // error!

    println!(&quot;the first word is: {}&quot;, word);
}</code></pre></pre>
</li>
<li>
<p>Thus, String Slices helps us write secure code by protecting the references to a string.</p>
</li>
<li>
<p>Also string literals <code>let string_literal = &quot;hello&quot;;</code>, are string slices <code>&amp;str</code>, and are immutable.</p>
</li>
</ul>
<p>Note: It is expected that the String only contains ASCII characters, because in case of UTF-8, if we try to slice between a multibyte character, it'll cause an error.</p>
<ul>
<li>
<p>The correct way to use referencing is discussed int the section, <a href="ch-02-basics-of-rust/pg-03-advanced-data-types.html#which-is-better-string-or-str">&quot;Which is better <code>&amp;String</code> or <code>&amp;str</code>?&quot;</a>.</p>
</li>
<li>
<p>Difference between String, String Literal, String Slice</p>
<div class="table-wrapper"><table><thead><tr><th>Property</th><th>String</th><th>String Literal</th><th>String Slice</th><th>Reference to String</th></tr></thead><tbody>
<tr><td>Definition</td><td><code>let string = String::from(&quot;some_string&quot;);</code></td><td><code>let string_literal = &quot;1234&quot;;</code></td><td><code>let string_slice = &amp;string[1..3]</code></td><td><code>let string_reference = &amp;string</code></td></tr>
<tr><td>Representation</td><td><code>String</code></td><td><code>&amp;str</code></td><td><code>&amp;str</code></td><td><code>&amp;String</code></td></tr>
<tr><td>Mutable</td><td>:white_check_mark:</td><td>:x:</td><td>:x:</td><td>:x:</td></tr>
<tr><td>Memory Management</td><td>Heap (but deallocates when out of scope)</td><td>Heap (Points to binary)</td><td>Heap (Points to Binary)</td><td>Heap</td></tr>
<tr><td>Use Cases</td><td>Taking Input, or any String Manipulation</td><td>Defining Constant Strings</td><td>Slicing and Borrowing</td><td>Borrowing</td></tr>
</tbody></table>
</div></li>
</ul>
<h4 id="strings-and-utf-8-encoding"><a class="header" href="#strings-and-utf-8-encoding">Strings and UTF-8 encoding</a></h4>
<ul>
<li>
<p>Characters are represented by single inverted commas, and has <code>4 bytes</code> of storage. For Example, <code>'😀'</code>.</p>
</li>
<li>
<p>String is not a collection of characters but collections of bytes.</p>
</li>
<li>
<p>Rust has only one string type in the core language, which is the string slice <code>str</code> that is usually seen in its borrowed form <code>&amp;str</code>.</p>
</li>
<li>
<p>String Slices are the references to some UTF-8 data stored somewhere else.</p>
</li>
<li>
<p>String Literals are string slices when stored in program's binary.</p>
</li>
<li>
<p>The <code>String</code> type, which is provided by Rust’s standard library rather than coded into the core language, is a growable, mutable, owned, UTF-8 encoded string type.</p>
</li>
<li>
<p>When Rustaceans, call &quot;string in rust&quot;, they collectively mean:</p>
<ul>
<li><code>String</code></li>
<li><code>&amp;str</code></li>
</ul>
</li>
<li>
<p>Both <code>String</code> and <code>&amp;str</code> are UTF-8 encoded.</p>
</li>
<li>
<p>Creating the <code>String</code> type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::new();
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>To create a <code>String</code> from some starting string:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;initial contents&quot;.to_string(); // This fn can be used on any type that implements Display trait
let s = String::from(&quot;initial contents&quot;);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>It is possible to store any properly encoded data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = String::from(&quot;नमस्ते&quot;);
let hello = String::from(&quot;안녕하세요&quot;);
let hello = String::from(&quot;Здравствуйте&quot;);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Updating the String:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;foo&quot;);
s.push_str(&quot;bar&quot;); // It takes string slice, hence doesn't takes ownership
s.push('!'); // This fn only takes character as argument.
// s will become &quot;foobar!&quot;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Concatenating two strings with the <code>+</code> operator:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// '+' is a replacement of - fn add(self, s: &amp;str) -&gt; String {
let s1 = String::from(&quot;Hello, &quot;);
let s2 = String::from(&quot;world!&quot;);
let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>Note: In Rust, if we provide <code>&amp;str</code>, as a function's argument, it can accept both <code>&amp;String</code> and <code>&amp;str</code>. Rust uses a deref coercion, which here turns <code>&amp;s2</code> into <code>&amp;s2[..]</code>.</p>
<ul>
<li>
<p>Combining multiple strings or formatting them:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

// Method 1
let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;

// Method 2
let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3); // It works like println!() but returns String
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Indexing into Strings is not possible and results in error:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// FAIL: Strings can be indexed in Rust
let s1 = String::from(&quot;hello&quot;);
let h = s1[0]; // Won't work
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>How values are stored in string.</p>
<ul>
<li>
<p>String is just a wrapper over <code>Vec&lt;u8&gt;</code>, this means <code>1 byte</code> of space for each element in the vector. Hence, if we want to save special charcters, then it may take more than one element to store the values.</p>
</li>
<li>
<p>Let's consider following examples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = String::from(&quot;Hola&quot;); // Each character will take 1 byte of storage
let hello = String::from(&quot;Здравствуйте&quot;); // Each character will take 2 bytes of storage
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Let's understand using the Hindi word <code>“नमस्ते”</code>:</p>
<ul>
<li>
<p>As Bytes (the way <code>String</code> does using <code>u8</code> which ranges from <code>0</code> to <code>255</code>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>As Unicode Scalar Values (the way <code>char</code> does):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>['न', 'म', 'स', '्', 'त', 'े']
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>As Grapheme Clusters (the way a Hindi speaker might do):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Slicing Strings:</p>
<ul>
<li>
<p>You need to provide the range of <code>bytes</code> to be sliced out of String. Again, not characters but bytes.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = &quot;Здравствуйте&quot;; // Each character here is composed of 2 bytes

let s = &amp;hello[0..4]; // It'll save first 4 bytes, `Зд`

let will_panic = &amp;hello[0..1]; // It'll panic, as if invalid index was accessed in the vector.
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
</li>
<li>
<p>Iterating over strings:</p>
<ul>
<li>
<p>You can iterate over the unicode scalar values or what <code>chars</code> might store:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in &quot;नमस्ते&quot;.chars() {
    println!(&quot;{}&quot;, c);
}

// This is what it'll print
न
म
स
्
त
े
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>You can iterate over bytes also, the way <code>String</code> is stored in <code>Vec&lt;u8&gt;</code> format:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in &quot;नमस्ते&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}

// The output will be like
224
164
// --snip--
165
135
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<ul>
<li>We define a function in Rust by entering <code>fn</code> followed by a function name and a set of parentheses.</li>
<li>The curly brackets tell the compiler where the function body begins and ends.</li>
<li>The entry function to a rust's code is the <code>main</code> function.</li>
<li>Rust doesn’t care where you define your functions, only that they’re defined somewhere.</li>
<li>Here's an example of functions in rust:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);

    another_function();
}

fn another_function() {
    println!(&quot;Another function.&quot;);
}

// Function with Parameter (or argument)
fn function_with_parameters(x: i32) {
    println!(&quot;The value of x is: {}&quot;, x);
}

// Function with two parameters
fn print_labeled_measurement(value: i32, unit_label: char) {
    println!(&quot;The measurement is: {}{}&quot;, value, unit_label);
}

// Functions with a return value
// In rust, functions return last expression implicitly
fn five() -&gt; i32 {
    5 // An Expression
}

// Functions returning through classical return keyword
// We use return keyword when we need to return early from a function
fn five() -&gt; i32 {
    return 5; // A statement
}

// This will also work
fn plus_one(x: i32) -&gt; i32 {
    x + 1
}

// Fail: Statement means, this function returns anything, expressed by (), a unit type
fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}</code></pre></pre>
<h3 id="statements-and-expressions"><a class="header" href="#statements-and-expressions">Statements and Expressions</a></h3>
<ul>
<li>In Rust, function bodies are made up of a series of statements optionally ending in an expression.</li>
</ul>
<h4 id="statements"><a class="header" href="#statements">Statements</a></h4>
<ul>
<li>
<p>They are instructions that perform some action and do not return a value.</p>
</li>
<li>
<p>They are just a standalone unit of execution.</p>
</li>
<li>
<p>Creating a variable and assigning itself a value is a statement.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let y = 6;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Function definitions are also statements; the entire function is a statement in itself.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = 6;
}</code></pre></pre>
</li>
<li>
<p>Statements do not return values. Therefore, you can’t assign a let statement to another variable:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = (let y = 6); // FAIL : Statements doesn't return anything
}</code></pre></pre>
</li>
<li>
<p>In some languages, you can write <code>x = y = 6</code> and have both <code>x</code> and <code>y</code> have the value <code>6</code>; that is <strong>not the case</strong> in Rust.</p>
</li>
</ul>
<h4 id="expressions"><a class="header" href="#expressions">Expressions</a></h4>
<ul>
<li>
<p>They do not end with a semicolon, unlike statements.</p>
</li>
<li>
<p>They evaluate into a resulting value.</p>
</li>
<li>
<p>They are a combination of values and functions that are combined by the compiler to create a new value.</p>
</li>
<li>
<p>The following things are considered as an expression:</p>
<ol>
<li>A simple math operation</li>
<li>Calling a function</li>
<li>Calling a macro</li>
<li>A new scope block created with curly brackets</li>
</ol>
</li>
<li>
<p>A simple math operation is an expression:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>5 + 6
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>In the below statement the standalone <code>6</code> is an expression.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 6; // A statement containing an expression
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>A scope block is an expression:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let x = 3;
    x + 1
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>The above scope block will return <code>4</code> and can now become a part of a statement.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // The below statement contains the computed value of an expression
    let y = {
        let x = 3; // Statements end with a semicolon
        x + 1 // Expressions do not end with semicolon
    };

    println!(&quot;The value of y is: {}&quot;, y);
}</code></pre></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h2>
<h3 id="if-expressions"><a class="header" href="#if-expressions"><code>if</code> expressions</a></h3>
<ul>
<li>
<p>The code inside an <code>if</code> block is called an arm, similar to match.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!(&quot;condition was true&quot;); // An arm
    } else {
        println!(&quot;condition was false&quot;);
    }
}</code></pre></pre>
</li>
<li>
<p>You can only pass a <code>bool</code> to the <code>if</code> expression</p>
<pre><pre class="playground"><code class="language-rust">// FAIL: number is of type integer and not bool
fn main() {
    let number = 3;

    if number {
        println!(&quot;number was three&quot;);
    }
}

// This works since it's a condition
fn main() {
    let number = 3;

    if number != 0 {
        println!(&quot;number was something other than zero&quot;);
    }
}</code></pre></pre>
</li>
<li>
<p>Rust only executes the block for the first true condition, and once it finds one, it doesn't even check the rest:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!(&quot;number is divisible by 4&quot;);
    } else if number % 3 == 0 {
        println!(&quot;number is divisible by 3&quot;); // Only this statement will run
    } else if number % 2 == 0 {
        println!(&quot;number is divisible by 2&quot;);
    } else {
        println!(&quot;number is not divisible by 4, 3, or 2&quot;);
    }
}</code></pre></pre>
</li>
<li>
<p>Conditionals in Single Line:</p>
<pre><pre class="playground"><code class="language-rust">// This Works
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!(&quot;The value of number is: {}&quot;, number);
}

// FAIL: Different data types integer and string
fn main() {
  let condition = true;

  let number = if condition { 5 } else { &quot;six&quot; };

  println!(&quot;The value of number is: {}&quot;, number);
}</code></pre></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="loops"><a class="header" href="#loops">Loops</a></h2>
<ul>
<li>
<p>Rust has three kinds of loops:</p>
<ol>
<li><code>loop</code> - Infinite Loop, uses <code>break</code> and <code>continue</code></li>
<li><code>while</code> - Breaks when the condition doesn't meet.</li>
<li><code>for</code> - Faster and easier to use for iterators and classical for loops.</li>
</ol>
</li>
<li>
<p>Simple Infinite Loop:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
  // Do something iteratively
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Named Loop</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'outer:loop {
 loop {
  break 'outer;
 }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Named Loop with different breaks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'oulter_loop: loop {
  loop {
    if condition {
      break 'oulter_loop; // Breaks Outer Loop
    }

    if some_other_condition {
      break; // Breaks Inner Loop
    }
  }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Returning values in loops:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!(&quot;The result is {}&quot;, result);
}</code></pre></pre>
</li>
<li>
<p>The <code>while</code> loop:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut number = 3;

    // Prevents the use of break, by including the condition with while
    while number != 0 {
        println!(&quot;{}!&quot;, number);

        number -= 1;
    }

    println!(&quot;LIFTOFF!!!&quot;);
}</code></pre></pre>
</li>
<li>
<p>The <code>for</code> loop:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Last item in exclusive, or 0..10 === 0..=9
for x in 0..10 {
    println!(&quot;{}&quot;, x); // x: i32
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>The <code>for</code> loop for iterator:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!(&quot;the value is: {}&quot;, element);
    }
}</code></pre></pre>
</li>
<li>
<p>A for loop for iterating characters in String</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in name.chars() {
    // c variable stores one charater per iteration
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Enumeration</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for (i, v) in request.chars().enumerate() {
    // i is index, v is variable
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>The <code>for</code> loop in reverse:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for number in (1..4).rev() {
        println!(&quot;{}!&quot;, number);
    }
    println!(&quot;LIFTOFF!!!&quot;);
}

// Output:
// 3!
// 2!
// 1!
// LIFTOFF!!!</code></pre></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ownership"><a class="header" href="#ownership">Ownership</a></h2>
<ul>
<li><em>Ownership</em> is a set of rules that governs how a Rust program manages memory.</li>
<li>Some languages have garbage collection that constantly looks for no-longer used memory as the program runs; in other languages, the programmer must explicitly allocate and free the memory.</li>
<li>Rust uses a third approach: memory is managed through a system of ownership with a set of rules that the compiler checks.</li>
<li>If any of the rules are violated, the program won’t compile.</li>
<li>None of the features of ownership will slow down your program while it’s running.</li>
</ul>
<h3 id="the-stack-and-the-heap"><a class="header" href="#the-stack-and-the-heap">The stack and the heap</a></h3>
<ul>
<li>
<p>Both the stack and the heap are parts of memory available to your code to use at runtime</p>
</li>
<li>
<p>Differences between Stack and Heap</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Stack</th><th>Heap</th></tr></thead><tbody>
<tr><td>Value is stored in order <em>Last In, First Out</em>.</td><td>Value is stored at an empty spot and a <em>pointer</em> is returned.</td></tr>
<tr><td>More Organized</td><td>Less Organized</td></tr>
<tr><td>Operations are <em>push</em> and <em>pop</em>.</td><td>Process of storing data on heap is called allocating.</td></tr>
<tr><td>All stored data is of fixed size.</td><td>Stored data can be of dynamic size.</td></tr>
<tr><td>New items are stored on top of stack, hence pushing is faster.</td><td>New items are stored after searching for right place to store, hence allocating is slower.</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>Pushing values onto the stack is not considered allocating. Because the pointer to the heap is a known, fixed size, you can store the pointer on the stack, but when you want the actual data, you must follow the pointer.</p>
</li>
<li>
<p>Think of heap as being seated at a restaurant.</p>
<ul>
<li>When you enter, you state the number of people in your group, and the staff finds an empty table that fits everyone and leads you there. If someone in your group comes late, they can ask where you’ve been seated to find you.</li>
<li>Consider a server at a restaurant taking orders from many tables. It’s most efficient to get all the orders at one table before moving on to the next table. Taking an order from table A, then an order from table B, then one from A again, and then one from B again would be a much slower process. By the same token, a processor can do its job better if it works on data that’s close to other data (as it is on the stack) rather than farther away (as it can be on the heap). Allocating a large amount of space on the heap can also take time.</li>
</ul>
</li>
<li>
<p>When your code calls a function, the values passed into the function (including, potentially, pointers to data on the heap) and the function’s local variables get pushed onto the stack. When the function is over, those values get popped off the stack.</p>
</li>
</ul>
<h3 id="ownership-rules"><a class="header" href="#ownership-rules">Ownership Rules</a></h3>
<ul>
<li>
<p>These are three golden rules of ownership:</p>
<ol>
<li>Each value in Rust has a variable that’s called its <em>owner</em>.</li>
<li>There can only be one owner at a time.</li>
<li>When the owner goes out of scope, the value will be dropped.</li>
</ol>
</li>
</ul>
<h3 id="what-is-moved"><a class="header" href="#what-is-moved">What is <code>moved</code>?</a></h3>
<ul>
<li>This is not a move, it's a copy:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// y = x is a copy: Integers are simple values with a known, fixed size, pushed to stack, hence copied
let x = 5;
let y = x;
<span class="boring">}</span></code></pre></pre>
<ul>
<li>This is a move:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// s1 = s2 is a move: Strings are stored on heap, hence only the data of string stored on stack is copied, hence moved
let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
<span class="boring">}</span></code></pre></pre>
<ul>
<li>
<p>Why <code>String</code> is only moved and not copied?</p>
<ul>
<li>When we assign s1 to s2, the String data is copied, meaning we copy the pointer, the length, and the capacity that are on the stack.</li>
<li>We do not copy the data on the heap that the pointer refers to.</li>
<li>Hence it is moved not copied.</li>
</ul>
<p><img src="https://doc.rust-lang.org/book/img/trpl04-02.svg" alt="Move of String" /></p>
</li>
<li>
<p>Why Rust preferes moving instead of copying the heap data?</p>
<ul>
<li>If Rust preformed copy instead of move, the operation <code>s2 = s1</code> could be very expensive in terms of runtime performance if the data on the heap were large.</li>
<li>This is what it would look like if Rust would have copied instead of moved.</li>
</ul>
<p><img src="https://doc.rust-lang.org/book/img/trpl04-03.svg" alt="If String was Copied" /></p>
</li>
<li>
<p>How does Rust clean memory after we perform <code>s2 = s1</code> and both <code>s1</code> and <code>s2</code> go out of scope?</p>
<ul>
<li>When a variable saved on heap goes out of scope, Rust calls a <code>drop</code> function to clean it from the memory.</li>
<li>But we performed <code>let s2 = s1;</code>, so Rust will try to clean both <code>s1</code> and <code>s2</code>, cleaning the same memory.</li>
<li>This problem is called <em>double free</em> error.</li>
<li>To solve this problem, when we perform <code>let s2 = s1;</code>, Rust actually moves the value to <code>s2</code> by invalidating <code>s1</code>.</li>
<li>Now, Rust has to only clean the <code>s2</code> variable. Hence, the problem of double free is solved.</li>
<li>So, what may look like a shallow copy (refer shallow and deep copy in other languages), it is actually a move operation.
<img src="https://doc.rust-lang.org/book/img/trpl04-04.svg" alt="Invalidation of s1" /></li>
</ul>
</li>
<li>
<p>In addition, there’s a design choice that’s implied by this: Rust will never automatically create “deep” copies of your data.</p>
</li>
<li>
<p>Therefore, any automatic copying can be assumed to be inexpensive in terms of runtime performance.</p>
</li>
</ul>
<h3 id="clone"><a class="header" href="#clone">Clone</a></h3>
<ul>
<li>This function is used when we want to clone the heap data.</li>
<li>If we perform <code>s2 = s1</code>, on a heap data for example String, then only the stack data will be copied and not the heap data, hence moved.</li>
<li>In case we want to copy the heap data too (also referred to deep copy), we use <em>clone</em> function.</li>
<li>Here's an example:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}</span></code></pre></pre>
<h3 id="the-copy-and-drop-trait"><a class="header" href="#the-copy-and-drop-trait">The <code>Copy</code> and <code>Drop</code> trait</a></h3>
<ul>
<li>
<p><code>Copy</code> trait can be placed on types that are stored on the stack like integers are.</p>
</li>
<li>
<p>If a type implements the Copy trait, a variable is still valid after assignment to another variable.</p>
</li>
<li>
<p>Rust won’t let us annotate a type with Copy if the type, or any of its parts, has implemented the Drop trait.</p>
</li>
<li>
<p>If the type needs something special to happen when the value goes out of scope and we add the Copy annotation to that type, we’ll get a compile-time error.</p>
</li>
<li>
<p>Types that implement copy:</p>
<ol>
<li>All the integer types, such as u32.</li>
<li>The Boolean type, bool, with values true and false.</li>
<li>All the floating point types, such as f64.</li>
<li>The character type, char.</li>
<li>Tuples, if they only contain types that also implement Copy. For example, (i32, i32) implements Copy, but (i32, String) does not.</li>
</ol>
</li>
</ul>
<h3 id="ownership-and-functions"><a class="header" href="#ownership-and-functions">Ownership and Functions</a></h3>
<ul>
<li>Passing a variable to a function will move or copy, just as assignment does.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it's okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!(&quot;{}&quot;, some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!(&quot;{}&quot;, some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.</code></pre></pre>
<ul>
<li>This is how the ownership works for the return values:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return value into s1
    let s2 = String::from(&quot;hello&quot;);     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into takes_and_gives_back, which also moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing
  // happens. s1 goes out of scope and is dropped.

fn gives_ownership() -&gt; String { // gives_ownership will move its return value into the function that calls it
    let some_string = String::from(&quot;yours&quot;); // some_string comes into scope

    some_string // some_string is returned and moves out to the calling function
}

// This function takes a String and returns one
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string comes into scope
    a_string  // a_string is returned and moves out to the calling function
}</code></pre></pre>
<ul>
<li>When a variable that includes data on the heap goes out of scope, the value will be cleaned up by drop unless ownership of the data has been moved to another variable. See how <code>takes_and_gives_back</code> function returns the variable before going out of scope.</li>
<li>Basically if we send a variable, we must return it back from the function to use it again.</li>
<li>So, there are two things we can do, either <em>return multiple values using tuples</em> or use <em>references</em>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">// This is an example of how a fn returns multiple values using tuples
fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, len) = calculate_length(s1);

    println!(&quot;The length of '{}' is {}.&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h2>
<ul>
<li>We do borrowing whenever we don't want to transfer the complete ownership of a varaible.</li>
<li>Consider the above example in previous section, inside <code>calculate_length</code> function we returned String <code>s</code>.</li>
<li>We returned it because when we passed <code>s1</code> into the function we transferred it's ownership to the variable <code>s</code>.</li>
<li>Since, the scope of variable <code>s</code> is limited, the passed value of <code>s1</code> will die outside the scope of <code>calculate_length</code>.</li>
<li>So, we returned the variable <code>s</code> inside a tuple before the end of it's scope.</li>
<li>Now, there is a workaround to calculate length without transferring the ownership.</li>
<li>The process of doing so is called <em>Borrowing</em> and it's done using <em>references</em>.</li>
</ul>
<h3 id="references"><a class="header" href="#references">References</a></h3>
<ul>
<li>
<p>A reference is a pointer to the variable.</p>
</li>
<li>
<p>It’s an address we can follow to access data stored at that address that is owned by some other variable.</p>
</li>
<li>
<p>Unlike a pointer, a reference is guaranteed to point to a valid value of a particular type.</p>
</li>
<li>
<p>We use <code>&amp;</code>, called as ampersand, to represent a reference.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    // Instead of transferring ownership, we only passed a reference to the string
    let len = calculate_length(&amp;s1);

    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

// We declare that this function will only accept a reference to a String, hence only borrows
fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}</code></pre></pre>
</li>
<li>
<p>Instead of Ownership transfer, borrowing looks like this, where <code>s</code> stores the reference.</p>
<p><img src="https://doc.rust-lang.org/book/img/trpl04-05.svg" alt="Borrowing" /></p>
</li>
</ul>
<h4 id="dereference"><a class="header" href="#dereference">Dereference</a></h4>
<ul>
<li>This is the opposite of reference. It is represented by <code>*</code>.</li>
<li>It returns the value of a pointer.</li>
</ul>
<h4 id="mutable-reference"><a class="header" href="#mutable-reference">Mutable Reference</a></h4>
<ul>
<li>
<p>The references are also immutable by default.</p>
</li>
<li>
<p>To make a reference mutable, we need to make both the declared variable and the reference mutable using <code>mut</code> keyword.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;); // Step 2 -&gt; Change variable to mutable

    change(&amp;mut s); // Step 3 -&gt; Pass the string as a mutable reference
}

fn change(some_string: &amp;mut String) { // Step 1 -&gt; Declare in fn definition, that it demands a mutable reference
    some_string.push_str(&quot;, world&quot;);
}</code></pre></pre>
</li>
</ul>
<h3 id="referencing-for-strings"><a class="header" href="#referencing-for-strings">Referencing for strings</a></h3>
<h4 id="which-is-better-string-or-str"><a class="header" href="#which-is-better-string-or-str">Which is better <code>&amp;String</code> or <code>&amp;str</code>?</a></h4>
<ul>
<li>
<p>Short Answer: <code>&amp;str</code>.</p>
</li>
<li>
<p>Reason: It allows us to use the same function on both <code>&amp;String</code> values and <code>&amp;str</code> values.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first_word(s: &amp;String) -&gt; &amp;str { // This sucks, only allows &amp;String

fn first_word(s: &amp;str) -&gt; &amp;str { // Rustaceans prefer this, since it allows both `&amp;String` and `&amp;str`.
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Basically, <code>&amp;str</code> works for all types of references:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_string = String::from(&quot;hello world&quot;);

    // `first_word` works on slices of `String`s, whether partial or whole
    let word = first_word(&amp;my_string[0..6]);
    let word = first_word(&amp;my_string[..]);
    // `first_word` also works on references to `String`s, which are equivalent
    // to whole slices of `String`s
    let word = first_word(&amp;my_string);

    let my_string_literal = &quot;hello world&quot;;

    // `first_word` works on slices of string literals, whether partial or whole
    let word = first_word(&amp;my_string_literal[0..6]);
    let word = first_word(&amp;my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}</code></pre></pre>
</li>
</ul>
<h3 id="data-race"><a class="header" href="#data-race">Data Race</a></h3>
<ul>
<li>
<p>The <em>data race</em> condition happens when these three behaviors occur:</p>
<ol>
<li>Two or more pointers access the same data at the same time.</li>
<li>At least one of the pointers is being used to write to the data.</li>
<li>There’s no mechanism being used to synchronize access to the data.</li>
</ol>
</li>
<li>
<p>To prevent this condition, Rust adds limitations while using references.</p>
</li>
</ul>
<h4 id="limitations-of-referecnes"><a class="header" href="#limitations-of-referecnes">Limitations of Referecnes</a></h4>
<ul>
<li>
<p>We cannot create two mutable references to a variable.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!(&quot;{}, {}&quot;, r1, r2);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>We cannot create one immutable and one mutable reference to a variable.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // no problem
    let r2 = &amp;s; // no problem
    let r3 = &amp;mut s; // BIG PROBLEM

    println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h4 id="allowed-workarounds-for-references"><a class="header" href="#allowed-workarounds-for-references">Allowed Workarounds for References</a></h4>
<ul>
<li>
<p>Multiple immutable references are allowed because no one who is just reading the data has the ability to affect anyone else’s reading of the data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // no problem
    let r2 = &amp;s; // no problem

    println!(&quot;{}, {}&quot;, r1, r2);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Rust treats last usage of a immutable reference, as it's end. Hence, the following code runs perfectly, read more about <a href="https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html#non-lexical-lifetimes">Non-Lexical Lifetimes</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // no problem
    let r2 = &amp;s; // no problem
    println!(&quot;{} and {}&quot;, r1, r2);
    // variables r1 and r2 will not be used after this point

    let r3 = &amp;mut s; // no problem
    println!(&quot;{}&quot;, r3);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>You may create a new scope to use two mutable references.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    {
        let r1 = &amp;mut s;
    } // r1 goes out of scope here, so we can make a new reference with no problems.

    let r2 = &amp;mut s;
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h3 id="dangling-references"><a class="header" href="#dangling-references">Dangling References</a></h3>
<ul>
<li>
<p>Dangling Reference is a reference to a location in memory which is freed but the reference exists.</p>
</li>
<li>
<p>In languages with pointers, it’s easy to erroneously create a dangling pointer.</p>
</li>
<li>
<p>In Rust, by contrast, the compiler guarantees that references will never be dangling references: if you have a reference to some data, the compiler will ensure that the data will not go out of scope before the reference to the data does.</p>
</li>
<li>
<p>Compiler throws error if we manually try to create a dangling reference:</p>
<pre><pre class="playground"><code class="language-rust">// FAIL: Rust won't allow you to create Dangling References
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);

    &amp;s
} // s goes out of scope here, but we try to reference to</code></pre></pre>
</li>
<li>
<p>The Error that compiler throws is:</p>
<pre><code class="language-zsh">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from
</code></pre>
</li>
<li>
<p>It also mentions, we can fix it using lifetimes.</p>
</li>
</ul>
<h3 id="golden-rules-of-referencing"><a class="header" href="#golden-rules-of-referencing">Golden Rules of Referencing</a></h3>
<ol>
<li><a href="ch-02-basics-of-rust/pg-08-borrowing.html#data-race">No Data Racing</a> - At any given time, you can have either one mutable reference or any number of immutable references.</li>
<li><a href="ch-02-basics-of-rust/pg-08-borrowing.html#dangling-references">No Dangling References</a> - References must always be valid.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="structs"><a class="header" href="#structs">Structs</a></h2>
<ul>
<li>A <em>struct</em>, or structure, is a <strong>custom data type</strong> that lets you name and package together multiple related values that make up a meaningful group.</li>
<li>It is used to just define the data attributes as we do in Object Oriented Programming Languages.</li>
<li>There are three types of Structs:
<ol>
<li>Structs with Named Fields</li>
<li>Tuple Structs</li>
<li>Unit Structs</li>
</ol>
</li>
</ul>
<h3 id="associated-functions-and-methods"><a class="header" href="#associated-functions-and-methods">Associated Functions and Methods</a></h3>
<ul>
<li>Functions defined for structs using the <code>impl</code> keyowrd are called <em>associated functions</em>.</li>
<li>The associated functions which accepts <code>self</code> as it's first argument are called <em>methods</em>.</li>
</ul>
<h4 id="structs-with-named-fields"><a class="header" href="#structs-with-named-fields">Structs with Named Fields</a></h4>
<ul>
<li>
<p>In structs, we name each piece of data, so it's clear what they mean. This name and data type pair are called <em>fields</em>.</p>
</li>
<li>
<p>Struct definition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    active: bool, // A Field
    username: String,
    email: String,
    sign_in_count: u64,
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Creating a struct's instance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// If you specify mut, all the values will be mutable otherwise none
let mut user1 = User {
    email: String::from(&quot;someone@example.com&quot;),
    username: String::from(&quot;someusername123&quot;),
    active: true,
    sign_in_count: 1,
};
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Taking out and updating the values:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>user1.email = String::from(&quot;anotheremail@example.com&quot;);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Defining functions for structs</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email, //We can write like this aslo-&gt; email: email
        username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>The struct update syntax (<code>..</code>), or spread operator in JS:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Initially
let user2 = User {
    active: user1.active,
    username: user1.username,
    email: String::from(&quot;another@example.com&quot;),
    sign_in_count: user1.sign_in_count,
};

// After using the struct update syntax (..)
let user2 = User {
    email: String::from(&quot;another@example.com&quot;),
    ..user1
};
<span class="boring">}</span></code></pre></pre>
<p>Note: This update syntax, works same as assignment operator <code>=</code>, so stack values will get copied and heap values will be moved. Since, username is a String, it's value will be moved from <code>user1</code> to <code>user2</code>, hence <code>user1</code> can't be used again.</p>
</li>
<li>
<p>To prevent this problem of ownership transfer, we can use <code>&amp;str</code> instead of <code>String</code> but when we use references in structs, it won't actually compile but will ask for lifetimes.</p>
<pre><pre class="playground"><code class="language-rust">// FAIL: Lifetime specifier not provided.
struct User {
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: &quot;someone@example.com&quot;,
        username: &quot;someusername123&quot;,
        active: true,
        sign_in_count: 1,
    };
}</code></pre></pre>
</li>
<li>
<p>In this situation the compiler situation looks something like this:</p>
<pre><code class="language-zsh"> --&gt; src/main.rs:2:15
  |
2 |     username: &amp;str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 | struct User&lt;'a&gt; {
2 |     username: &amp;'a str,
  |
</code></pre>
</li>
</ul>
<h4 id="tuple-structs"><a class="header" href="#tuple-structs">Tuple Structs</a></h4>
<ul>
<li>
<p>Using Tuple Structs without Named Fields to Create Different Types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>To access their types, we use the <code>.</code> operator followed by the number of this argumnet.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let color = Color(10, 25, 16);
let red = color.0;
let green = color.1;
let blue = color.2;
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h4 id="unit-structs"><a class="header" href="#unit-structs">Unit Structs</a></h4>
<ul>
<li>
<p>They are structs without Any Fields (they act like <code>()</code>).</p>
</li>
<li>
<p>They are Useful when we want to implement a trait on some type but don’t have any data that you want to store in the type itself.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AlwaysEqual;

let subject = AlwaysEqual;
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h4 id="why-do-we-use-structs"><a class="header" href="#why-do-we-use-structs">Why do we use Structs?</a></h4>
<ol>
<li>
<p>It is a more sensible design choice to pass as minimum arguments as possible inside a function. For Example, if we need to calculate the area of rectangle, instead of passing <code>height</code> and <code>width</code>, it would be cleaner to pass the whole rectangle.</p>
</li>
<li>
<p>Now, this can be done with the tuples too. For Example, <code>let rect1 = (50, 30);</code> but the problem with this syntax is that any developer can confuse which one is width or height.</p>
</li>
<li>
<p>To make this process clearer and cleaner, we use <code>struct</code>, so that we can combine the data and still keep the meaning of each attribute intact.</p>
<pre><pre class="playground"><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 50,
        height: 30
    };

    println!(&quot;The area of the rectangle is {} square pixels&quot;, area(&amp;rect1));
}


// Passing Rectangle as a reference is important so that main fn
// can retain it's ownership after this function is called.
fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}</code></pre></pre>
</li>
</ol>
<h4 id="printing-variables"><a class="header" href="#printing-variables">Printing Variables</a></h4>
<ul>
<li>
<p>Ways to Print the variables:</p>
<ul>
<li><code>{}</code> - Used to print variables with Display trait, for simple data types like int, string etc. we don't need to derive this attribute.</li>
<li><code>{:?}</code> - Used to print complex variables with Debug trait, preferred for complex data type like struct, and we need to derive the <code>Debug</code> attribute.</li>
<li><code>{:#?}</code> - Works similarly like <code>{:?}</code>, except it's preferred for structs with large number of fields.</li>
<li><code>dbg!()</code> - It is a macro used with Debug trait to print the variables, file and line number. It prints to <code>stderr</code> instead of <code>stdout</code> (which <code>println!()</code> uses). It takes ownership, so prefer sending references to it.</li>
</ul>
</li>
<li>
<p>Here's an example of using the <code>dbg!()</code> macro:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale), // It'll resolve the expression `30 * scale`, as if dbg!() call was never there, it happens due to ownership transfer
        height: 50,
    };

    dbg!(&amp;rect1); // To maintian the scope of rect1 in main() we sent only the reference.
}</code></pre></pre>
</li>
<li>
<p>The output looks like this:</p>
<pre><code class="language-zsh">   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10] 30 * scale = 60
[src/main.rs:14] &amp;rect1 = Rectangle {
    width: 60,
    height: 50,
}
</code></pre>
</li>
<li>
<p>You can read more about <a href="https://doc.rust-lang.org/book/appendix-03-derivable-traits.html">Derivable Traits</a> and <a href="https://doc.rust-lang.org/reference/attributes.html">Attributes</a>.</p>
</li>
</ul>
<h4 id="structs-with-method-syntax"><a class="header" href="#structs-with-method-syntax">Structs with Method Syntax</a></h4>
<ul>
<li>
<p>When functions are defined in the context of a struct, enum or trait they are called as <em>Methods</em>.</p>
</li>
<li>
<p>The first parameter of a method is always <code>self</code>, which represents the instance.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

// Everything inside the impl block is associated with Rectangle
impl Rectangle {

    // &amp;self is a short hand for self: `&amp;self` (references are used to prevent mutation)
    // You can pass the following too:
    // self - Ownership of instance
    // &amp;self - Reference to the instance {Currently Using}
    // &amp;mut self - Mutable Reference to the instance
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    // It is possible to name methods same as fields of struct
    // Usually these methods are used as getters, to keep the fields private but provide read only accees using the methods
    fn width(&amp;self) -&gt; bool {
      self.width &gt; 0
    }

    // This is how we pass anotherr instance of same struct to a method
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
      self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    let rect2 = Rectangle {
      width: 15,
      height: 25,
    };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rect1.area()
    );

    // If we use rect1.width() - Rust unserstands it as method and
    // if we use rect1.width - Rust unserstands it as a field
    if rect1.width() {
      println!(&quot;The rectangle has a nonzero width; it is {}&quot;, rect1.width);
    };

    // This is how we can pass second instance while calling a method on first instance
    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
}</code></pre></pre>
</li>
</ul>
<p>Note: When you call a method with <code>object.something()</code>, Rust automatically adds in <code>&amp;</code>, <code>&amp;mut</code>, or <code>*</code> so object matches the signature of the method. In other words, the following are the same:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}</span></code></pre></pre>
<ul>
<li>
<p>It is possible to use different <code>impl</code> blocks, it is a valid syntax.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h4 id="associated-functions"><a class="header" href="#associated-functions">Associated Functions</a></h4>
<ul>
<li>
<p>All the functions defined under <code>impl</code> are associated functions.</p>
</li>
<li>
<p>Methods are associated functions which has <code>self</code> as an argument and we use <code>.</code> operator to access it.</p>
</li>
<li>
<p>It is possible to define associated functions without passing <code>self</code> as the <strong>first</strong> argument, these functions are accessed through <code>::</code> operator.</p>
</li>
<li>
<p>Here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Calling a method, also an associated function
instance.method(some_argument);

// Calling an associated function, without self as the first argument, hence not a method
String::from(&quot;Hello, World!&quot;);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>These associated functions are commonly used as constructors. Also, for the previous example of Rectangle, we can use it as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Rectangle {
    // With this associated function we can create a new instance of Rectangle
    // by passing one value instead of two, hence creating a square.
    fn square(size: u32) -&gt; Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>It can be called like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sq = Rectangle::square(3);
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<ul>
<li>Enums is the short form of enumerations.</li>
<li>It allows us to define a type with possible values, these possible values are called <em>variants</em>.</li>
<li>We can enumerate all possible variants, which is where enumeration gets its name.</li>
<li>The total size that enum will allocate for it’s variant will be equal to the memory allocation of it’s largest variant. It works similar to unions in C.</li>
</ul>
<h4 id="where-to-use-enums"><a class="header" href="#where-to-use-enums">Where to use Enums?</a></h4>
<ul>
<li>
<p>When their are certain possible values for a type and those possible values may not coincide together.</p>
</li>
<li>
<p>For Example, we can make an <code>enum</code> for Day, with possible variants Monday-Sunday, now for a certain day any two possible values will never coincide.</p>
</li>
<li>
<p>Another Example, IP Address, it's possible variants will be IPV4, IPV6, for a certain IP address, it can only be either of the two.</p>
</li>
<li>
<p>Here's an example definition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>To create an instance of ane enum, we use <code>::</code> operator:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>To use it in a function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In fn declaration
fn route(ip_kind: IpAddrKind) {}

// In fn call
route(IpAddrKind::V4);
route(IpAddrKind::V6);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Using Enums with Structs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from(&quot;127.0.0.1&quot;),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from(&quot;::1&quot;),
    };
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Enums with associated data types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Now, we don't need an extra struct
enum IpAddr {
    V4(String),
    V6(String),
}

// We get a default constructor function for each variant
let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Defining enum variants with different data types:</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum IpAddr {
    // Defining variants with two different data types
    // is only possible through enums and not through enums with struct
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}</span></code></pre></pre>
<ul>
<li>
<p>This is how <a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">standard library defines IP addresses</a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

// It is posible to put any data type inside
// the enum variant, int, String, struct,
// or even enum
enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}

<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Enum with complicated data types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Cleaner Approach
enum Message {
    Quit, // No data associated with it at all!
    Move { x: i32, y: i32 }, // Has named fields like struct
    Write(String),
    ChangeColor(i32, i32, i32),
}

// Uglier approach using struct
struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>It is possible to define associated functions on enums using <code>impl</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn call(&amp;self) {
        // method body would be defined here
    }
}

let _quit_message = Message::Quit; // We won't use parantheses because it is of Unit Type
let _write_message = Message::Write(String::from(&quot;Hello&quot;)); // Constructor function, that accepts String and will stroe it on heap
let _change_color_message = Message::ChangeColor(12, 12, 12); // Constructor function, that accepts three i32 values
let _move_message = Message::Move {x: 5, y: 6}; // Works similar to creating new instance of struct with named fields

_quit_message.call();
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h4 id="the-option-enum"><a class="header" href="#the-option-enum">The <code>Option</code> Enum</a></h4>
<ul>
<li>
<p>The Option type is used in many places because it encodes the very common scenario in which a value could be something or it could be nothing.</p>
</li>
<li>
<p>Expressing this concept in terms of the type system means the compiler can check whether you’ve handled all the cases you should be handling.</p>
</li>
<li>
<p>This functionality can prevent bugs that are extremely common in other programming languages.</p>
</li>
<li>
<p>Rust doesn't have <code>Null</code>, so it uses <code>Option</code> enum with variants <code>Some</code> and <code>None</code>.</p>
</li>
<li>
<p>This makes Rust extremely cool, you may read more about <a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html#the-option-enum-and-its-advantages-over-null-values">&quot;Null References: The Billion Dollar Mistake&quot;</a>.</p>
</li>
<li>
<p>The problem with null values is that if you try to use a null value as a not-null value, you’ll get an error of some kind.</p>
</li>
<li>
<p>Rust's <code>Option</code> enum will always ask you to offer solution for both <code>Some</code> and <code>None</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// It is generic over any data type T
enum Option&lt;T&gt; {
    None,
    Some(T),
}

// Rust automatically inferred to be of type Option&lt;i32&gt; because we passed a number and i32 is it's default type
let some_number = Some(5);
// Similarly, Rust inferred Option&lt;&amp;str&gt;, since we passed string literal
let some_string = Some(&quot;a string&quot;);

// Here, since None can belong to any data type, we explicitly define i32
let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h4 id="why-is-having-optiont-any-better-than-having-null"><a class="header" href="#why-is-having-optiont-any-better-than-having-null">Why is having <code>Option&lt;T&gt;</code> any better than having <code>null</code>?</a></h4>
<ul>
<li>
<p>In short, because <code>Option&lt;T&gt;</code> and <code>T</code> (where <code>T</code> can be any type) are different types, the compiler won’t let us use an <code>Option&lt;T&gt;</code> value as if it were definitely a valid value.</p>
</li>
<li>
<p>For example, this code won’t compile because it’s trying to add an <code>i8</code> to an <code>Option&lt;i8&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let sum = x + y;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>When we have a value of a type like <code>i8</code> in Rust, the compiler will ensure that we always have a valid value.</p>
</li>
<li>
<p>We can proceed confidently without having to check for null before using that value.</p>
</li>
<li>
<p>when we have an <code>Option&lt;i8&gt;</code>, we'll have to worry about possibly not having a value, and the compiler will make sure we handle that case before using the value.</p>
</li>
<li>
<p>In other words, you have to convert an <code>Option&lt;T&gt;</code> to a <code>T</code> before you can perform <code>T</code> operations with it.</p>
</li>
<li>
<p>Generally, this helps catch one of the most common issues with null: assuming that something isn’t null when it actually is.</p>
</li>
<li>
<p>In languages like C, this will work and print something, even though we know it doesn't contain any value.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int x;
    printf(&quot;Value of x: %i&quot;, x);

    return 0;
}
</code></pre>
</li>
<li>
<p>In Rust, it'll not compile, since it identifies an absence of value.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number: i32;
    println!(&quot;Value of x: {}&quot;, number);
}</code></pre></pre>
</li>
<li>
<p>Everywhere that a value has a type that isn’t an <code>Option&lt;T&gt;</code>, you can safely assume that the value isn’t <code>null</code>.</p>
</li>
<li>
<p>This was a deliberate design decision for Rust to limit null’s pervasiveness and increase the safety of Rust code.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h2>
<h3 id="the-match-conftrol-flow-operator"><a class="header" href="#the-match-conftrol-flow-operator">The <code>match</code> conftrol flow operator</a></h3>
<ul>
<li>
<p>It allows you to compare a value against a series of patterns and then execute code based on which pattern matches.</p>
</li>
<li>
<p>It is possible to express very different kind of patterns. Also, Rust has a cumpolsary check, where it handles that all possible cases are handled.</p>
</li>
<li>
<p>Think of a <code>match</code> expression as being like a coin-sorting machine: coins slide down a track with variously sized holes along it, and each coin falls through the first hole it encounters that it fits into.</p>
</li>
<li>
<p>At the first pattern the value “fits”, the value falls into the associated code block to be used during execution.</p>
</li>
<li>
<p>The expression with <code>if</code> statement only returns a boolean value but <code>match</code> expression can return any type.</p>
</li>
<li>
<p>Here's an Example Below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!(&quot;Lucky penny!&quot;);
            1
        },
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Each new pattern under <code>match</code> is an arm. An arm has two parts: a pattern and some code.</p>
</li>
<li>
<p>The code associated with each arm is an expression, and the resulting value of the expression in the matching arm is the value that gets returned for the entire match expression.</p>
</li>
</ul>
<h4 id="an-enum-inside-another-enum"><a class="header" href="#an-enum-inside-another-enum">An <code>enum</code> inside another <code>enum</code></a></h4>
<ul>
<li>This is how we'll be using <code>match</code> for such cases:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;State quarter from {:?}!&quot;, state);
            25
        }
    }
}

fn main() {
  let _value = value_in_cents(Coin::Quarter(UsState::Alaska));
}</code></pre></pre>
<h4 id="matching-with-optiont"><a class="header" href="#matching-with-optiont">Matching with <code>Option&lt;T&gt;</code></a></h4>
<ul>
<li>
<p>The value inside Option of type <code>T</code> can be passed through like a functional argument using the <code>match</code> expression.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>The <code>match</code> expression always covers all the possible values, that's why we call them <em>exhaustive</em>: we must exhaust every last possibility in order for the code to be valid.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// FAIL: All the cases not covered in match expression, the None case is remaining
fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        Some(i) =&gt; Some(i + 1),
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Especially in the case of <code>Option&lt;T&gt;</code>, when Rust prevents us from forgetting to explicitly handle the <code>None</code> case, it protects us from assuming that we have a value when we might have <code>null</code>, thus <em>making the billion-dollar mistake discussed earlier impossible</em>.</p>
</li>
</ul>
<h4 id="catch-remaining-patterns-using-_-placeholder"><a class="header" href="#catch-remaining-patterns-using-_-placeholder">Catch remaining patterns using <code>_</code> placeholder</a></h4>
<ul>
<li>
<p>It is possible to cover the remaining cases inside the <code>match</code> expression, it is similar to <code>default</code> case of <code>switch</code> statement in other languages.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        other =&gt; move_player(other), // This will match all the cases that aren't specifically listed
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Sometimes we use placeholder <code>_</code>, to specify Rust, that this value is useless.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; reroll(), // These values aren't that important
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>If we want to tell Rust to literally do nothing, then we can use unit tuple <code>()</code> instead of fn call.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; (), // Telling Rust to &quot;do nothing&quot;
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h4 id="the-if-let-syntax"><a class="header" href="#the-if-let-syntax">The <code>if let</code> syntax</a></h4>
<ul>
<li>
<p>It is used in case you want to consider only particular case of an enum.</p>
</li>
<li>
<p>For example, if you want to consider only the <code>Some</code> variant of an enum <code>Option&lt;&gt;</code>, you may prefer to use the <code>if let</code> syntax instead of <code>match</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The older approach using the match syntax
let config_max = Some(3u8);
match config_max {
    Some(max) =&gt; println!(&quot;The maximum is configured to be {}&quot;, max),
    _ =&gt; (), // This line seems redundant
}

// More concise approach with if let
let config_max = Some(3u8);
if let Some(max) = config_max {
    println!(&quot;The maximum is configured to be {}&quot;, max);
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>The <code>if let</code> accepts a pattern (consider <code>Some(max)</code>) and an expression (consider <code>config_max</code>) seperated by and <code>=</code> sign.</p>
</li>
<li>
<p>Before using <code>if let</code> please make sure whether gaining conciseness is an appropriate trade-off for losing exhaustive checking.</p>
</li>
<li>
<p>This approach is not exhaustive in sense that it only considers one pattern and ignores other unlike the <code>match</code> syntax.</p>
</li>
<li>
<p>It is possible to use <code>else</code> with <code>if let</code>:</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In this problem we are counting the coins that aren't quarter
let mut count = 0;
match coin {
    Coin::Quarter(state) =&gt; println!(&quot;State quarter from {:?}!&quot;, state),
    _ =&gt; count += 1,
}

// Another possible approach with if let and else
let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!(&quot;State quarter from {:?}!&quot;, state);
} else {
    count += 1;
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-collections"><a class="header" href="#common-collections">Common Collections</a></h1>
<ul>
<li>The various data structures in Rust's standard library are called Collections. Refer <a href="https://doc.rust-lang.org/std/collections/index.html">here</a>.</li>
<li>They can contain multiple values and collections point data stored on heap.</li>
<li>Most Common Collections:
<ul>
<li>Vectors</li>
<li>String</li>
<li>Hash Map</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="vector"><a class="header" href="#vector">Vector</a></h2>
<ul>
<li>
<p>It is represesnted as <code>Vec&lt;T&gt;</code>.</p>
</li>
<li>
<p>You can store variable number of values, unlike Array. Though, the data type of stored values should be same.</p>
</li>
<li>
<p>Vectors store values next to each other in memory.</p>
</li>
<li>
<p>Creating a new vector:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  // We'll add type annotation because the vector has 0 elements,
  // hence, there is no way for Rust to recognize type implicitly
  let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Creating vectors using a macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let v = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Pushing new values (make sure Vector is mutable):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  v.push(5);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Popping new values:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut vec = vec![1, 2, 3];
assert_eq!(vec.pop(), Some(3));
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Even though vectors store values on heap and it is possible to introduce references to the elements of the vector. Still, the vectors automatically cleans up memory as it goes out of scope:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  {
      let v = vec![1, 2, 3, 4];

      // do stuff with v
  } // &lt;- v goes out of scope and is freed here
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Accessing elements inside a vector:</p>
<ul>
<li>
<p>Method 1:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let third: &amp;i32 = &amp;v[2]; // Might panic due to out of index
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Method 2:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match v.get(2) { // Gives Option&lt;&amp;T&gt;
    Some(third) =&gt; println!(&quot;The third element is {}&quot;, third),
    None =&gt; println!(&quot;There is no third element.&quot;),
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
</li>
<li>
<p>You can't do that:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5];

    let first = &amp;v[0]; // A reference to immutable vector [Immutable Borrow]

    v.push(6); // Writing to a mutable vector [Mutable Error]

    println!(&quot;The first element is: {}&quot;, first); // Accessing the reference after writing [Immutable Borrow Used]

    // Recall: You can’t have mutable and immutable references in the same scope.
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Why should a reference to the first element care about what changes at the end of the vector? This error is due to the way vectors work: adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space, if there isn’t enough room to put all the elements next to each other where the vector currently is.</p>
</li>
<li>
<p>Itearting over the Vector:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let v = vec![100, 32, 57];
  for i in &amp;v {
      println!(&quot;{}&quot;, i);
  }
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Iterating and mutating the vector:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut v = vec![100, 32, 57];
    for i in &amp;mut v {
        *i += 50;
    }
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Storing values of different types using enums:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // Using enums in vectors add stability as
    // when we'll use match all possible cases
    // will be covered.
    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
        SpreadsheetCell::Float(10.12),
    ];
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hashmaps"><a class="header" href="#hashmaps">HashMaps</a></h2>
<ul>
<li>
<p>The type <code>HashMap&lt;K, V&gt;</code> stores a mapping of keys of type <code>K</code> to values of type <code>V</code>.</p>
</li>
<li>
<p>It does this via a hashing function, which determines how it places these keys and values into memory.</p>
</li>
<li>
<p>Creating a new HashMap:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Just like Vectors, HashMaps also save their values on Heap.</p>
</li>
<li>
<p>All Keys must have same type, and all values must have same type.</p>
</li>
<li>
<p>Creating HashMap through iterators:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let teams = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];
    let initial_scores = vec![10, 50];

    let mut scores: HashMap&lt;_, _&gt; =
        teams.into_iter()
             .zip(initial_scores.into_iter()) // creates a tuple, example (&quot;Blue&quot;, 10)
             .collect(); // Converts tuple into HashMap
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>HashMap and ownership: Types that implement <code>Copy</code> trait will be copied else moved. For Example, <code>i32</code> will be copied but <code>String</code> will be moved.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let field_name = String::from(&quot;Favorite color&quot;);
    let field_value = String::from(&quot;Blue&quot;);

    let mut map = HashMap::new();
    map.insert(field_name, field_value);
    // You can't use field_name or field_value now, as they've been moved
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Accessing value in HashMap, the <code>get</code> method returns <code>Option&lt;&amp;V&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);

    let team_name = String::from(&quot;Blue&quot;);
    let score = scores.get(&amp;team_name); // This is how we access value for a certain Key

    // The score variable will contain - Some(&amp;10)
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Iterating over a HashMap:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);

    for (key, value) in &amp;scores {
        println!(&quot;{}: {}&quot;, key, value);
    }
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Updating a HashMap:</p>
<ul>
<li>
<p>Overwriting the value:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Blue&quot;), 25);

// Output - scores = {&quot;Blue&quot;: 25}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Only inserting the value if the Key has no value:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>scores.insert(String::from(&quot;Blue&quot;), 10);

// We'll need to use entry to use or_insert
scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50); // This will add 50
scores.entry(String::from(&quot;Blue&quot;)).or_insert(50); // This won't replace 10 with 50

// Output - scores = {&quot;Yellow&quot;: 50, &quot;Blue&quot;: 10}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Updating a value based on the Old Value:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let text = &quot;hello world wonderful world&quot;;

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0); // or_insert returns mutable reference to the Value, &amp;mut V
    *count += 1;
}

println!(&quot;{:?}&quot;, map);

// Output - map = {&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
</li>
<li>
<p>The hashing function that Rust uses is <code>SipHash</code>. You can replace the hashing function. Please <a href="https://doc.rust-lang.org/book/ch08-03-hash-maps.html#hashing-functions">refer here</a> for more.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-structuring-and-error-handling"><a class="header" href="#project-structuring-and-error-handling">Project Structuring and Error Handling</a></h1>
<ul>
<li>You'll learn about how to structure the differences between packages, crates, modules and paths. It'll help you to modularize your code as your project grows. We'll talk about error handling and the differences between recoverable and unrecoverable errors.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="project-structuring"><a class="header" href="#project-structuring">Project Structuring</a></h3>
<ul>
<li>The Rust's <em>module system</em> includes:
<ul>
<li><strong>Packages:</strong> A Cargo feature that lets you build, test, and share crates</li>
<li><strong>Crates:</strong> A tree of modules that produces a library or executable</li>
<li><strong>Modules</strong> and <strong>use:</strong> Let you control the organization, scope, and privacy of paths</li>
<li><strong>Paths:</strong> A way of naming an item, such as a struct, function, or module</li>
</ul>
</li>
<li>Once you’ve implemented an operation, other code can call that code via the code’s public interface without knowing how the implementation works.</li>
<li>The way you write code defines which parts are public for other code to use and which parts are private.
<ul>
<li><code>private</code> - No exteranl code can call this code directly</li>
<li><code>public</code> - External code can call this code directly</li>
</ul>
</li>
<li>The way privacy works in Rust is that all items (functions, methods, structs, enums, modules, and constants) are private by default.</li>
</ul>
<h4 id="package"><a class="header" href="#package">Package</a></h4>
<ul>
<li>When we run the command <code>cargo new</code> it creates the package.</li>
<li>A package contains a <em>Cargo.toml</em> file that describes how to build those crates.</li>
<li>A package can contain <strong>at most one</strong> <em>library</em> crate. It can contain <strong>as many</strong> <em>binary</em> crates as you’d like, but it must contain at least one crate (either library or binary).</li>
<li>As a package grows, you can extract parts into separate crates that become external dependencies.</li>
</ul>
<h4 id="crates"><a class="header" href="#crates">Crates</a></h4>
<ul>
<li>A crate is a binary or library.</li>
<li>The <em>crate root</em> is a source file that the Rust compiler starts from and makes up the root module of your crate.</li>
<li>Cargo follows a convention that <em>src/main.rs</em> is the crate root of a <strong>binary</strong> crate with the same name as the package.</li>
<li>Similarly, <em>src/lib.rs</em> is the crate root of a <strong>library</strong> crate with the same name as the package.</li>
<li>Cargo passes the crate root files to rustc to build the library or binary.</li>
<li>A crate’s functionality is namespaced in its own scope, it means we can import another crate let's say <code>rand</code> which has a trait named <code>Rng</code>, and still create a new struct named <code>Rng</code> in our project's crate. The <code>rustc</code> will never confuse between the two and we can access the <code>rand</code>'s components as <code>rand::Rng</code>.</li>
</ul>
<h4 id="modules"><a class="header" href="#modules">Modules</a></h4>
<ul>
<li>
<p>Modules are used to structure code inside a crate.</p>
</li>
<li>
<p>It is also used to provide privacy to your code.</p>
<ul>
<li><code>private</code> - Exteranl code outside that module can not call this code directly</li>
<li><code>public</code> - External code outside that module can call this code directly</li>
</ul>
</li>
<li>
<p>By using modules, we can group related definitions together and name why they’re related.</p>
</li>
<li>
<p>The benefit it'll provide you is that other programmers reading your code can easily find the code they are searching for because then they'll navigate through groups rather than each function definition. Also, they'll add new code in the right module.</p>
</li>
<li>
<p>The contents of the files <em>src/main.rs</em> and <em>src/lib.rs</em> (these files are also referred as crate roots) form a module named <code>crate</code> at the root of the crate’s module structure, known as the <em>module tree</em>.</p>
<pre><code class="language-zsh">crate                                 // An implicit module, definitely not named by you
 └── front_of_house                   // Main Module inside lib.rs
     ├── hosting                      // Submodule
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving                      // Submodule
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
</li>
</ul>
<h4 id="paths"><a class="header" href="#paths">Paths</a></h4>
<ul>
<li>
<p>We use a path in the same way we use a path when navigating a filesystem.</p>
</li>
<li>
<p>A path can take two forms:</p>
<ul>
<li>An <em>absolute path</em> starts from a crate root by using a crate name or a literal <code>crate</code>.</li>
<li>A <em>relative path</em> starts from the current module and uses <code>self</code>, <code>super</code>, or an identifier in the current module.</li>
</ul>
</li>
<li>
<p>You ma consider paths in rust quite similar to the paths used to access the filesystem</p>
<ul>
<li><code>crate</code> - Root (<code>/</code>)</li>
<li><code>::</code> - Used to distinct others (<code>/</code>)</li>
<li><code>super</code> - Used to go back one step (<code>../</code>)</li>
</ul>
</li>
<li>
<p>Here's an exmaple:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// eat_at_restaurant is a sibling to front_of_house (since they are in same file),
// thus front_of_house doesn't need pub keyword to make it accessible.
mod front_of_house {
    // Add pub to allow the functions that can access front_of_house to access hosting too.
    pub mod hosting {
        // Add pub to allow the functions that can access hosting to access add_to_waitlist too.
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    // Filesystem Equivalent to /front_of_house/hosting/add_to_waitlist
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    // Filesystem Equivalent to front_of_house/hosting/add_to_waitlist
    front_of_house::hosting::add_to_waitlist();
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Our preference is to specify absolute paths because it’s more likely to move code definitions and item calls independently of each other.</p>
</li>
<li>
<p>Items in a parent module can’t use the private items inside child modules, but items in child modules can use the items in their ancestor modules.</p>
</li>
<li>
<p>But you can expose inner parts of child modules’ code to outer ancestor modules by using the pub keyword to make an item public.</p>
</li>
<li>
<p>If you want to make an item like a function or struct private, you put it in a module.</p>
</li>
<li>
<p>Another example to show usecase for <code>super</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn serve_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::serve_order();
    }

    fn cook_order() {}
}

<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>If we make a <code>struct</code> public, it <strong>doesn't</strong> mean all it's fields are public too. We use <code>.</code> to access fields.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod back_of_house {
    pub struct Breakfast {
        pub toast: String, // Accessible
        seasonal_fruit: String, // Not Accessible
    }

  ...
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>On the other hand, if we make an <code>enum</code> public all it's variants becomes public too. We use <code>::</code> to access variants.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod back_of_house {
    pub enum Appetizer {
        Soup, // Accessible
        Salad, // Accessible
    }

    ...
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h4 id="the-use-keyword"><a class="header" href="#the-use-keyword">The <code>use</code> keyword</a></h4>
<ul>
<li>
<p>It is similar to the <code>import</code> keyword in python.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

// The line below will make hosting as a valid name in the scope
use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>We can use the following ways to achieve the same thing:</p>
<ul>
<li><code>use self::front_of_house::hosting;</code></li>
<li><code>use crate::front_of_house::hosting::add_to_waitlist;</code></li>
</ul>
</li>
<li>
<p>Though, the one mentioned inside the code block is the idiiomatic way to do it in Rust.</p>
</li>
<li>
<p>On the other hand, when bringing in structs, enums, and other items with use, it’s idiomatic to specify the full path.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}</code></pre></pre>
</li>
<li>
<p>In case if we have two items with same name (in our case <code>Result</code>) but from different crates (in our case <code>fmt</code> and <code>io</code>), then we'll not use the full path, as it'll confuse Rust.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;
use std::io;

// This way Rust will be able to distinguish which Result we want
fn function1() -&gt; fmt::Result {
    // --snip--
}

fn function2() -&gt; io::Result&lt;()&gt; {
    // --snip--
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Alternatively, we can use the <code>as</code> keyword to deal with two same names.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Result;
use std::io::Result as IoResult;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>We can re-export the code using <code>pub use</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

// The use keyword will create a local variable named hosting in this scope
// and pub keyword will re-export it for the external code to use it.
pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Using external packages:</p>
<ul>
<li>
<p>First, we'll add the name and version of the package in <code>cargo.toml</code>, so that it can be automatically downloaded through crates.io.</p>
<pre><code class="language-toml">rand = &quot;0.8.3&quot;
</code></pre>
</li>
<li>
<p>Then, we'll use the <code>use</code> keyword to bring it into the scope.</p>
<pre><pre class="playground"><code class="language-rust">use rand::Rng;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1..101);
}</code></pre></pre>
</li>
<li>
<p>The packages like <code>std</code> is also external but is a part of Rust language and it is not needed to download it from crates.io.</p>
</li>
</ul>
</li>
<li>
<p>Nesting the paths:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Dirty Approach
use std::cmp::Ordering;
use std::io;

// Cleaneer Aproach (Nested)
use std::{cmp::Ordering, io};

//Another Dierty Approach
use std::io;
use std::io::Write;

// Cleaner Approach (Nesting using self)
use std::io::{self, Write};
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>The glob operator (<code>*</code>), is used to bring all public definitions into the scope.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// It is a bit riskier, as it is hard to identify what all definitions have been brought into scope
use std::collections::*;
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modularizing"><a class="header" href="#modularizing">Modularizing</a></h1>
<h3 id="modularizing-in-different-files"><a class="header" href="#modularizing-in-different-files">Modularizing in different files</a></h3>
<ul>
<li>
<p>Let's say we decided to put some code in the file <code>src/front_of_house.rs</code>, and we want to use this code inside the file <code>src/lib.rs</code>. It can be done like this:</p>
<pre><code class="language-zsh">src
 ├── front_of_house.rs
 └── lib.rs
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Filename: src/lib.rs
// This will bring the contents of module (thst is stored in file `src/front_of_house.rs`)
// into the current file
mod front_of_house;

// This will allow us to use as well as export it
// so that external can use it too.
pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Now, we can make a new directory as well and can store the files as folows:</p>
<pre><code class="language-zsh">src
 ├── front_of_house
 │   └── hosting.rs
 ├── front_of_house.rs
 └── lib.rs
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Filename: src/front_of_house.rs
pub mod hosting;
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Filename: src/front_of_house/hosting.rs
pub fn add_to_waitlist() {}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h4 id="re-exporting"><a class="header" href="#re-exporting">Re-exporting</a></h4>
<ul>
<li>
<p>You may use re-exporting, for making it easier to use your crate for other developers. It allows to use the structures directly intead of following the heirarchy in which the crate is designed.</p>
<ul>
<li>
<p>Without re-exporting:</p>
<ul>
<li>
<p>How structure looks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod kinds {
    pub enum PrimaryColor {
      ...
    }

    pub enum SecondaryColor {
      ...
    }
}

pub mod utils {
    use crate::kinds::*;

    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        ...
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>How others will be using it:</p>
<pre><pre class="playground"><code class="language-rust">use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}</code></pre></pre>
</li>
</ul>
</li>
<li>
<p>With re-exporting:</p>
<ul>
<li>
<p>How structure looks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Here we're re-exporting it for direct use
pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    ...
}

pub mod utils {
    ...
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>How others will be using it:</p>
<pre><pre class="playground"><code class="language-rust">// Isn't it easier to import now?
use art::mix;
use art::PrimaryColor;

fn main() {
  let red = PrimaryColor::Red;
  let yellow = PrimaryColor::Yellow;
  mix(red, yellow);
}</code></pre></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="workspaces"><a class="header" href="#workspaces">Workspaces</a></h4>
<ul>
<li>
<p>A <code>workspace</code> is a set of packages that share the same <code>Cargo.lock</code> and output directory.</p>
</li>
<li>
<p>You can build your workspace that looks like this:</p>
<pre><code class="language-zsh">add
├── Cargo.lock
├── Cargo.toml
├── add_one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target // Notice only one target directory
</code></pre>
</li>
<li>
<p>The <code>cargo.toml</code> of <code>add</code> (the outer one) of the workspace will look like this:</p>
<pre><code class="language-toml">&lt;!-- Filename: add/Cargo.toml --&gt;
[workspace]

members = [
    &quot;adder&quot;,
    &quot;add_one&quot;,
]
</code></pre>
</li>
<li>
<p>The workspace has one target directory at the top level, the <code>adder</code> package doesn’t have its own <code>target</code> directory.</p>
</li>
<li>
<p>Even if we were to run <code>cargo build</code> from inside the <code>adder</code> directory, the compiled artifacts would still end up in <code>add/target</code> rather than <code>add/adder/target</code>.</p>
</li>
<li>
<p>The <code>cargo.toml</code> of <code>adder</code> will look like this:</p>
<pre><code class="language-toml">&lt;!-- Filename: add/adder/Cargo.toml --&gt;
[dependencies]
add_one = { path = &quot;../add_one&quot; }
</code></pre>
</li>
<li>
<p>The <code>main.rs</code> in <code>adder</code> will look something like this:</p>
<pre><pre class="playground"><code class="language-rust">// Filename: add/adder/src/main.rs
use add_one;

fn main() {
    let num = 10;
    println!(
        &quot;Hello, world! {} plus one is {}!&quot;,
        num,
        add_one::add_one(num)
    );
}</code></pre></pre>
</li>
<li>
<p>To build the whole workspace, you may run this command from the <code>add</code> directory (the outer).</p>
<pre><code class="language-zsh">$ cargo build
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68s
</code></pre>
</li>
<li>
<p>To run a particular package you may run the following command:</p>
<pre><code class="language-zsh">$ cargo run -p adder
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
</code></pre>
</li>
<li>
<p>All the dependencies in different packages will use the same version of the dependency. It is because the <code>cargo.toml</code> of the workspace will make only one entry of the dependency. It also saves space and makes all the package compatible with each other, since they'll be using the same version of the dependency.</p>
</li>
<li>
<p>To run all test:</p>
<pre><code class="language-zsh">cargo run test
</code></pre>
</li>
<li>
<p>To run test in particular file:</p>
<pre><code class="language-zsh">cargo test -p add_one
</code></pre>
</li>
</ul>
<h3 id="refactoring-guides"><a class="header" href="#refactoring-guides">Refactoring Guides</a></h3>
<p>This pattern is about separating concerns: <code>main.rs</code> handles running the program, and <code>lib.rs</code> handles all the logic of the task at hand. Because you can’t test the main function directly, this structure lets you test all of your program’s logic by moving it into functions in <code>lib.rs</code>. The only code that remains in main.rs will be small enough to verify its correctness by reading it.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<h4 id="types-of-errors"><a class="header" href="#types-of-errors">Types of Errors</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Recoverable</th><th>Unrecoverable</th></tr></thead><tbody>
<tr><td>Errors like file not found error.</td><td>Errors like trying to access a location beyond the end of an array.</td></tr>
<tr><td>It’s reasonable to report the problem to the user and retry the operation.</td><td>They are always symptoms of bugs.</td></tr>
<tr><td><code>Result&lt;T, E&gt;</code> is used for Recoverable Errors.</td><td>The <code>panic!</code> macro is used to stop the execution for an unrecoverable error.</td></tr>
</tbody></table>
</div>
<h4 id="unrecoverable-errors-with-panic"><a class="header" href="#unrecoverable-errors-with-panic">Unrecoverable Errors with <code>panic!</code></a></h4>
<p>Fun Fact: In C, attempting to read beyond the end of a data structure is undefined behavior. You might get whatever is at the location in memory that would correspond to that element in the data structure, even though the memory doesn’t belong to that structure. This is called a buffer overread and can lead to security vulnerabilities if an attacker is able to manipulate the index in such a way as to read data they shouldn’t be allowed to that is stored after the data structure. In Rust, you'll encounter a <code>panic!()</code> in such cases.</p>
<ul>
<li>
<p>When the <code>panic!</code> macro executes, Rust does the following:</p>
<ul>
<li>Print a failure message</li>
<li>Unwind and clean up the stack</li>
<li>Quit</li>
</ul>
</li>
<li>
<p>Panic is usually used, when a bug appears and the programmer doesn't know how to handle it.</p>
</li>
<li>
<p>If you don't want your program to &quot;slowly unwind and clean up the stack&quot; instead &quot;abort the program and let OS handle the cleaning&quot;. You may do that by adding following lines to the <code>Cargo.toml</code> file. Refer <a href="https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html#unwinding-the-stack-or-aborting-in-response-to-a-panic">here</a> for more.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[profile.release]
panic = 'abort'
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>To receive a backtrace in case of panic, you might need to run the following command:</p>
<pre><code class="language-zsh">RUST_BACKTRACE=1 cargo run
</code></pre>
</li>
<li>
<p>The best way to read backtraces is to ready from top to bottom, once you see the first instance mentioning a file that you've written, you should probably try to solve from there.</p>
</li>
<li>
<p>Debug symbols (they are required to receive backtraces) are enabled by default when using <code>cargo build</code> or <code>cargo run</code> without the <code>--release</code> flag.</p>
</li>
</ul>
<h4 id="recoverable-errors-with-result"><a class="header" href="#recoverable-errors-with-result">Recoverable Errors with <code>Result</code></a></h4>
<ul>
<li>
<p>Result is an enum, that considers two possible outcomes: success (<code>Ok(T)</code>) or failure (<code>Err(E)</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Handling recoverable errors using the <code>match</code> expression.</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file, // Handling Success
        Err(error) =&gt; panic!(&quot;Problem opening the file: {:?}&quot;, error), // Handling Failure
    };
}</code></pre></pre>
</li>
<li>
<p>Matching on different errors:</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    // Match on File, whether it gets opened or not
    let f = match f {
        Ok(file) =&gt; file,
        // If file not found, then create a new file and transfer file handle,
        // this error is part of io::ErrorKind, which was found using error.kind()
        Err(error) =&gt; match error.kind() {
            // In case we receive ErrorKind::NotFound, we'll apply
            // match again to check whether creation of file, fails or succeeds
            ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&quot;Problem creating the file: {:?}&quot;, e),
            },
            other_error =&gt; {
                panic!(&quot;Problem opening the file: {:?}&quot;, other_error)
            }
        },
    };
}</code></pre></pre>
</li>
<li>
<p>In case you don't like using a lot of match statements (refer above example), you may use <code>unwrap_or_else</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io::ErrorKind;

fn main() {
   let f = File::open(&quot;hello.txt&quot;).unwrap_or_else(|error| {
     if error.kind() == ErrorKind::NotFound {
       File::create(&quot;hello.txt&quot;).unwrap_or_else( |error| {
         panic!(&quot;Problem creating the file: {:?}&quot;, error);
       }
       )
     } else {
       panic!(&quot;Problem opening the file: {:?}&quot;, error);
     }
   })
}</code></pre></pre>
</li>
<li>
<p>In case you want a shortcut, you may only use <code>unwrap()</code>. It either returns what's inside <code>Ok(T)</code>, or panics in case of <code>Err(E)</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap();
}</code></pre></pre>
</li>
<li>
<p>For those cases, when you want to send a panic message but only want to unwrap in one line, you may use <code>expect</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;); // Same as unwrap but contains panic message
}</code></pre></pre>
</li>
<li>
<p>Propogating errors using the <code>Result</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e), // This is a std::io error type
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e), // This is also a std::io error type
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>The shortcut of above code can be done using <code>?</code>. <code>unwrap</code> panics in case of Err(E), but this operator returns the error, same as the code above.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ? operator changes the error type to the mentioned
// Error type in the fn declaration using the from implementation
use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>It is possible to use the <code>?</code> operator multiple times in a single line:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>There's a Rust's official implementation of the functionality mentioned in the above code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string(&quot;hello.txt&quot;)
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>The <code>?</code> operator can only be used in the functions that has a return type of <code>Result&lt;Ok(T), Err(E)&gt;</code>, <code>Option&lt;Some(T), None&gt;</code>, or another type that implements FromResidual:</p>
<pre><pre class="playground"><code class="language-rust">// FAIL: main() doensn't returns a Result&lt;&gt;
// but the ? operator requires that
use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;)?;
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// It works with the Option
fn last_char_of_first_line(text: &amp;str) -&gt; Option&lt;char&gt; {
  text.lines().next()?.chars().last()
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>There's a way to use <code>?</code> inside <code>main()</code>. The <code>main()</code> either returs <code>0</code> on success or other integer on failure. Also, it's possible to return <code>&lt;Result(), E&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let f = File::open(&quot;hello.txt&quot;)?;

    Ok(())
}</code></pre></pre>
</li>
<li>
<p>Differences between <code>unwrap</code>, <code>unwrap_or</code>, and <code>?</code> operator</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Property</th><th><code>unwrap</code></th><th><code>expect</code></th><th><code>unwrap_or</code></th><th><code>?</code> operator</th></tr></thead><tbody>
<tr><td>Error Handling</td><td>Panics</td><td>Panics with the given message</td><td>Executes code inside it's parantheses</td><td>Returns error</td></tr>
<tr><td>Can be used on <code>Result</code></td><td>:heavy_check_mark:</td><td>:heavy_check_mark:</td><td>:heavy_check_mark:</td><td>:heavy_check_mark:</td></tr>
<tr><td>Can be used on <code>Option</code></td><td>:heavy_check_mark:</td><td>:heavy_check_mark:</td><td>:heavy_check_mark:</td><td>:heavy_check_mark:</td></tr>
<tr><td>Function return type to be same as wrapped item</td><td>:x:</td><td>:x:</td><td>:x:</td><td>:heavy_check_mark:</td></tr>
</tbody></table>
</div>
<p>Note: You can only use the <code>?</code> operator on a <code>Result</code> in a function that returns <code>Result</code>, and you can use the <code>?</code> operator on an <code>Option</code> in a function that returns <code>Option</code>.</p>
<ul>
<li>
<p>To <code>panic!</code> or Not to <code>panic!</code></p>
<ul>
<li>
<p>When to use <code>Result</code></p>
<ul>
<li>When <code>panic!</code> is called, there is no way to recover the program, so if there is a slightest possiblity to recover the program, it's recommended to use that instead of <code>panic!</code>.</li>
<li>Always try to prevent converting a recoverable error into an unrecoverable one. Hence, always prefer <code>Result</code> over <code>panic!</code>.</li>
<li>The <code>unwrap</code> and <code>expect</code> methods are very handy when prototyping, and if you want to make your program more robust, you may add better error handling.</li>
</ul>
</li>
<li>
<p>When to use <code>panic!</code></p>
<ul>
<li>In case you want your test to fail in certain cases, even if a certain fn is not exactly what the test is for, it's better to <code>panic!</code> in those situations.</li>
<li>It’s advisable to have your code panic when it’s possible that your code could end up in a <code>bad state</code>. The bad state is something that is unexpected, as opposed to something that will likely happen occasionally, like a user entering data in the wrong format. You don't want to carry this bad state throughout the program and instead would prefer it to end through <code>panic!</code>.</li>
<li>If someone calls your code and passes in values that don’t make sense, the best choice might be to call <code>panic!</code> and alert the person using your library to the bug in their code so they can fix it during development.</li>
<li>Similarly, <code>panic!</code> is often appropriate if you’re calling external code that is out of your control and it returns an invalid state that you have no way of fixing.</li>
<li>When your code performs operations on values, your code should verify the values are valid first and panic if the values aren’t valid. This is mostly for safety reasons: attempting to operate on invalid data can expose your code to vulnerabilities.</li>
<li>However, having lots of error checks in all of your functions would be verbose and annoying. Fortunately, you can use Rust’s type system (and thus the type checking the compiler does) to do many of the checks for you. If your function has a particular type as a parameter, you can proceed with your code’s logic knowing that the compiler has already ensured you have a valid value. For example, if you have a type rather than an Option, your program expects to have something rather than nothing.</li>
<li>Another example is using an unsigned integer type such as u32, which ensures the parameter is never negative.</li>
</ul>
</li>
<li>
<p>When to call <code>unwrap()</code></p>
<ul>
<li>
<p>In case you exactly know that the code won't <code>panic!</code>, then it's better to use <code>unwrap()</code>, and stop caring about the other possibilities. Here's an Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::net::IpAddr;

// Compile isn't smart enough to see this string is a valid IP address
// but we are
let home: IpAddr = &quot;127.0.0.1&quot;.parse().unwrap();
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="medium-concepts"><a class="header" href="#medium-concepts">Medium Concepts</a></h1>
<p>This section will cover the functional programming features like closures and iterators. Also, it'll talk about how you can perform Object Oriented Programming in Rust. It'll also talk about other features like generics, traits and lifetimes etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="generics"><a class="header" href="#generics">Generics</a></h3>
<ul>
<li>Generics are used to prevent the duplication of <strong>concepts</strong> and are generalized over a type.</li>
<li>Some examples of generics are <code>Result&lt;T,E&gt;</code>, <code>Option&lt;T&gt;</code>, <code>Vec&lt;T&gt;</code>, and <code>HashMap&lt;K,V&gt;</code>.</li>
<li>Possible Use Cases:
<ul>
<li>You can define an enum or struct which can accomodate different data types.</li>
<li>You can define a function which can provide same functionality for different types. For Example, finding the largest element inside a vector of numbers or chars.</li>
</ul>
</li>
<li>In Rust, declaring generics aren't any slower than using concrete types, because it uses a process called <em>Monomorphization</em> to achieve that. Monomorphization is the process of turning generic code into specific code by filling in the concrete types that are used when compiled.</li>
</ul>
<h4 id="generics-on-structs"><a class="header" href="#generics-on-structs">Generics on structs</a></h4>
<ul>
<li>
<p>To create a generic struct:</p>
<pre><pre class="playground"><code class="language-rust">// We used type T to make the struct generic
// so that it can accomodate any type
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };

    // FAIL: First is i32 and the other is f32, hence different types.
    let wont_work = Point { x: 5, y: 4.0 };
}</code></pre></pre>
</li>
<li>
<p>To make the <code>wont_work</code> to work fine, we'll need to change the code as follows:</p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };

    let will_work = Point { x: 5, y: 4.0 };
}</code></pre></pre>
</li>
</ul>
<h4 id="generics-on-enums"><a class="header" href="#generics-on-enums">Generics on Enums</a></h4>
<ul>
<li>
<p>The <code>Option&lt;T&gt;</code> enum:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
  Some(T),
  None
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>The <code>Result&lt;T, E&gt;</code> enum uses two types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h4 id="generics-on-functions"><a class="header" href="#generics-on-functions">Generics on Functions</a></h4>
<ul>
<li>
<p>To use generics on <code>impl</code> blocks:</p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

// By using T after impl means that
impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

// impl for just one concrete type
impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}</code></pre></pre>
</li>
<li>
<p>To use on <code>impl</code> on different types:</p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;X1, Y1&gt; {
    x: X1,
    y: Y1,
}

impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {
    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c' };

    let p3 = p1.mixup(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}</code></pre></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="traits"><a class="header" href="#traits">Traits</a></h3>
<ul>
<li>
<p>A <em>trait</em> tells the Rust compiler about functionality a particular type has and can share with other types.</p>
</li>
<li>
<p>They are similar to the interfaces in other languages. They are used to define the method signature.</p>
</li>
<li>
<p>You may define the code implementations inside the <code>impl</code> block of the types that implement that trait.</p>
</li>
<li>
<p>It is also possible to define a default implementation and then override it in <code>impl</code> block.</p>
</li>
<li>
<p>Use cases:</p>
<ul>
<li>
<p>For example, you're creating a library that wants to summarize an article or a tweet. We want to implement this shared functionality.</p>
</li>
<li>
<p>We can define a trait to define the interface of this functionality.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Now each type implementing this trait must provide its own custom behavior for the body of the method.</p>
</li>
</ul>
</li>
</ul>
<h4 id="implementing-a-trait"><a class="header" href="#implementing-a-trait">Implementing a trait</a></h4>
<ul>
<li>
<p>Implementing trait on different types</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Using types that implements trait:</p>
<pre><pre class="playground"><code class="language-rust">// You'll require to pull both trait along with the desired type
use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
}</code></pre></pre>
</li>
</ul>
<h4 id="restrictions"><a class="header" href="#restrictions">Restrictions</a></h4>
<ul>
<li>One restriction to note with trait implementations is that we can implement a trait on a type only if at least one of the trait or the type is local to our crate.
<ul>
<li>For example, we can implement standard library traits like <code>Display</code> on a custom type like <code>Tweet</code> as part of our <code>aggregator</code> crate functionality, because the type Tweet is local to our aggregator crate.</li>
<li>But we can’t implement external traits on external types. For example, we can’t implement the <code>Display</code> trait on <code>Vec&lt;T&gt;</code> within our <code>aggregator</code> crate, because <code>Display</code> and <code>Vec&lt;T&gt;</code> are defined in the standard library and aren’t local to our <code>aggregator</code> crate.</li>
</ul>
</li>
<li>This restriction is part of a property of programs called <em>coherence</em>, and more specifically the <em>orphan rule</em>, so named because the parent type is not present. This rule ensures that other people’s code can’t break your code and vice versa.</li>
</ul>
<h4 id="default-implementations"><a class="header" href="#default-implementations">Default Implementations</a></h4>
<ul>
<li>
<p>We can define a default implementation by adding code inside the method signatures of traits.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from(&quot;(Read more...)&quot;)
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>To use default implementation on a type, we can do that by using empty braces <code>{}</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Summary for NewsArticle {}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>It is possible to keep a trait with a mix of method signatures and method signatures with default implementations.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Now we only need to require to define <code>summarize_author</code> method inside the <code>impl</code> block of the type that's implementing the trait.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }

    // We do not require to define the summarize() method
    // as we can use the trait's default implementation
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>Note: Calling the default implementation from an overriding implementation won't work.</p>
<h4 id="traits-as-paramteres"><a class="header" href="#traits-as-paramteres">Traits as Paramteres</a></h4>
<ul>
<li>
<p>You can define the <code>type</code> of parameters of a function as a trait.</p>
</li>
<li>
<p>Then, you can pass any type that implements the specified trait.</p>
</li>
<li>
<p>Here's the syntax for that:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify(item: &amp;impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Code that calls the function with any other type, such as a <code>String</code> or an <code>i32</code>, won’t compile because those types don’t implement Summary.</p>
</li>
<li>
<p>The above syntax is the simpler version of this original syntax, known as &quot;<em>trait bound syntax</em>&quot;:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>It is possible to use this syntax like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>It is possible to define multiple trait bounds for a single parameter:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In both these cases, item must be a type that
// implements both traits Summary and Display

// Method 1 -&gt;
pub fn notify(item: &amp;(impl Summary + Display)) {

// Method 2 -&gt;
pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>You can use <code>where</code> clause to declutter the signature. For Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Similar to function parameters, it is possible to return types that implements traits:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Signature says that it'll return any type that implements the trait Summary
fn returns_summarizable() -&gt; impl Summary {
    // Tweet is some type that implements Summary
    Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>However, you can only use <code>impl Trait</code> if you’re returning a single type. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// FAIL: Either return NewsArticle or Tweet (only one type that implements Summary)
fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
          ...
        }
    } else {
        Tweet {
          ...
        }
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Finding the largest character of an array of integer or an array of characters using generics and traits:</p>
<pre><pre class="playground"><code class="language-rust">// Generic is used as we defined T in the signature, allowing any type to pass
// Trait bound is specified as PartialOrd is added to the signature, allowing any type that allows comparison, and copy (both i32 and char do)
fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}</code></pre></pre>
</li>
<li>
<p>Using Trait Bounds to Conditionally Implement Methods:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

// cmp_display will only run on types bounded by traits Display and PartialOrd, hence works conditionally
impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {}&quot;, self.y);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h2>
<p>Fun Fact: The developers who are programming Rust are constantly programming the patterns into the compiler’s code so the borrow checker could infer the lifetimes in some situations and wouldn’t need explicit annotations. These patterns programmed into Rust’s analysis of references are called the <em>lifetime elision rules</em>. Thus, making lifetimes easier to use day by day.</p>
<ul>
<li>
<p>Lifetime is a way to specify how long the multiple references will live. So, it doesn't make sense to add lifetime to just one reference, they must be multiple.</p>
</li>
<li>
<p>Ways to add lifetime specifiers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&amp;i32        // a reference
&amp;'a i32     // a reference with an explicit lifetime
&amp;'a mut i32 // a mutable reference with an explicit lifetime
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>Note: We'll may or may not use lifetimes only when we're dealing with references.</p>
<ul>
<li>
<p>For example, let’s say we have a function with the parameter <code>first</code> that is a reference to an <code>i32</code> with lifetime <code>'a</code>. The function also has another parameter named <code>second</code> that is another reference to an <code>i32</code> that also has the lifetime <code>'a</code>. The lifetime annotations indicate that the references <code>first</code> and <code>second</code> must both live as long as that generic lifetime.</p>
</li>
<li>
<p><em>Every reference</em> in Rust has a <em>lifetime</em>.</p>
</li>
<li>
<p>Here's an exmple of dangling reference:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// FAIL: Rust prevents dangling references
    {
        let r;                // ---------+-- 'a
                              //          |
        {                     //          |
            let x = 5;        // -+-- 'b  |
            r = &amp;x;           //  |       |
        }                     // -+       | &lt;- x dies but r stores reference of x, hence r stores a dangling referece
                              //          |
        println!(&quot;r: {}&quot;, r); //          |
    }                         // ---------+
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Rust won't compile the above code, as it uses a <code>borrow checker</code>, to verify whether a reference or borrow is valid or not.</p>
</li>
<li>
<p>We may fix it by fixing the lives of variables by declaring them at different places:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    {
        let x = 5;            // ----------+-- 'b
                              //           |
        let r = &amp;x;           // --+-- 'a  |
                              //   |       |
        println!(&quot;r: {}&quot;, r); //   |       |
                              // --+       |
    }                         // ----------+
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>This code will not compile, it'll require lifetime specifiers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// FAIL: Rust can’t tell whether the reference being returned refers to x or y.
fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Compiler will ask us to rewrite the signature like this
fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
// Lifetimes on function or method parameters are called input lifetimes, and lifetimes on return values are called output lifetimes.
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>The reason why Rust asks us to specify the lifetimes are due to these reasons:</p>
<ul>
<li>We don’t know whether the if case or the else case will execute.</li>
<li>We also don’t know the concrete lifetimes of the references that will be passed in.</li>
</ul>
</li>
<li>
<p>When we add the lifetime specifiers as specified by the compiler, it means, the generic lifetime <code>'a</code> will get the concrete lifetime that is equal to the smaller of the lifetimes of <code>x</code> and <code>y</code> (the variables passed in).</p>
</li>
</ul>
<p>Note: Remember, when we specify the lifetime parameters in this function signature, we’re not changing the lifetimes of any values passed in or returned. Rather, we’re specifying that the borrow checker should reject any values that don’t adhere to these constraints. Note that the longest function doesn’t need to know exactly how long <code>x</code> and <code>y</code> will live, only that some scope can be substituted for <code>'a</code> that will satisfy this signature.</p>
<ul>
<li>How borrow checker will allow:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">// Works: result is valid until the inner scope ends, string2 and string1 are valid too, hence borrow checker allows
fn main() {
    let string1 = String::from(&quot;long string is long&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let result = longest(string1.as_str(), string2.as_str());
        println!(&quot;The longest string is {}&quot;, result);
    }
}

// FAILS: The way we've specified lifetimes, result should have a shorter lifetime, equivalent to that of string2. Since, the code doesn't follows the rule, it fails.
fn main() {
    let string1 = String::from(&quot;long string is long&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;The longest string is {}&quot;, result);
}</code></pre></pre>
<ul>
<li>In the second case, this is the error that the compiler will throw:</li>
</ul>
<pre><code class="language-zsh">  |
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^^^^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!(&quot;The longest string is {}&quot;, result);
  |                                          ------ borrow later used here
</code></pre>
<ul>
<li>
<p>The below code will not compile because even though we’ve specified a lifetime parameter <code>'a</code> for the return type, this implementation will fail to compile because the return value lifetime is not related to the lifetime of the parameters at all.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from(&quot;really long string&quot;);
    result.as_str()
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>The compiler will throw this error, since Rust will prevent us from creating dangling reference.</p>
<pre><code class="language-zsh">  --&gt; src/main.rs:11:5
   |
11 |     result.as_str()
   |     ^^^^^^^^^^^^^^^ returns a reference to data owned by the current function
</code></pre>
</li>
<li>
<p>In this case, the best fix would be to return an owned data type rather than a reference so the calling function is then responsible for cleaning up the value.</p>
</li>
<li>
<p>Rust is improving day by day to not require programmers to use lifetimes in some places. For Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Even though we're dealing with references in functions,
// compiler won't ask us to specify lifetimes, it's because
// rust devs improved the rust compiler so that the borrow
// checker need not to not ask for lifetimes in this case
fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}

// In earlier version (pre-1.0), the signature would've looked like this
fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h4 id="rules-of-lifetimes"><a class="header" href="#rules-of-lifetimes">Rules of lifetimes</a></h4>
<ul>
<li>
<p>There are 3 rules that compiler follows to verify whether lifetimes are valid or not.</p>
<ul>
<li><strong>First Rule:</strong> <em>Each parameter that is a reference gets its own lifetime parameter.</em>
<ul>
<li>A function with one parameter gets one lifetime parameter: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>;</li>
<li>A function with two parameters gets two separate lifetime parameters: <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32);</code> and so on.</li>
</ul>
</li>
<li><strong>Second Rule:</strong> <em>If there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters.</em>
<ul>
<li>For Example, <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</li>
<li>There was only one parameter, hence one lifetime for inputs, so the same lifetime was assigned to the output.</li>
</ul>
</li>
<li><strong>Third Rule:</strong> <em>If there are multiple input lifetime parameters, but one of them is <code>&amp;self</code> or <code>&amp;mut self</code> because this is a method, the lifetime of <code>self</code> is assigned to all output lifetime parameters.</em>
<ul>
<li>This third rule makes methods much nicer to read and write because fewer symbols are necessary.</li>
<li>Please note that this rule only applies to methods (functions that uses <code>self</code>), and not to simple functions.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>You can read in detail about How compiler automatically applies lifetimes and the about the rules of lifetimes in <a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision"><em>Lifetime Elision</em></a>.</p>
</li>
</ul>
<h4 id="lifetimes-in-structs-and-methods"><a class="header" href="#lifetimes-in-structs-and-methods">Lifetimes in Structs and Methods</a></h4>
<ul>
<li>
<p>Lifetimes in struct. It’s possible for structs to hold references, but in that case we would need to add a lifetime annotation on every reference in the struct’s definition.</p>
<pre><pre class="playground"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    // Since, string slice is a referece, we added lifetime, such that field part and struct lives together
    part: &amp;'a str,
}

fn main() {
    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}</code></pre></pre>
</li>
<li>
<p>Lifetimes in <code>impl</code> blocks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The lifetime parameter declaration after impl and its use after the type name are required,
// but we’re not required to annotate the lifetime of the reference to self because of the first elision rule.
impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    // No need to apply in the method below due to the first elision rule
    fn level(&amp;self) -&gt; i32 {
        3
    }
    // No need to apply in the method below due to the third elision rule
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
      println!(&quot;Attention please: {}&quot;, announcement);
      self.part
  }
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h4 id="the-static-lifetime"><a class="header" href="#the-static-lifetime">The static lifetime</a></h4>
<ul>
<li>
<p>The <code>'static</code> is a lifetime which means that this reference can live for the entire duration of the program.</p>
</li>
<li>
<p>All string literals have the <code>'static</code> lifetime.</p>
</li>
<li>
<p>You may use it as shown in the code below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = &quot;I have a static lifetime.&quot;;
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>Note: You might see suggestions to use the <code>'static</code> lifetime in error messages. But before specifying <code>'static</code> as the lifetime for a reference, think about whether the reference you have actually lives the entire lifetime of your program or not. You might consider whether you want it to live that long, even if it could. Most of the time, the problem results from attempting to create a dangling reference or a mismatch of the available lifetimes. In such cases, the solution is fixing those problems, not specifying the <code>'static</code> lifetime.</p>
<h3 id="generic-type-parameters-trait-bounds-and-lifetimes-together"><a class="header" href="#generic-type-parameters-trait-bounds-and-lifetimes-together">Generic Type Parameters, Trait Bounds, and Lifetimes Together</a></h3>
<ul>
<li>You may consider the code below, it prints the type (they type <code>T</code> can be filled with any type that implements <code>Display</code> trait), also it returns the longest string slice.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Generic Type: T
// Trait Bounds: Display
// Lifetime: 'a
use std::fmt::Display;

// Because lifetimes are a type of generic, the declarations of
// the lifetime parameter 'a and the generic type parameter T go
// in the same list inside the angle brackets after the function name.
fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    println!(&quot;Announcement! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="functional-language-features"><a class="header" href="#functional-language-features">Functional Language Features</a></h2>
<p>Fun Fact: The implementations of closures and iterators are such that runtime performance is not affected. It means as if you've written to an optimized low level code, like in Assembly Language. This is part of Rust’s goal to strive to provide <em>zero-cost abstractions</em>.</p>
<ul>
<li>Programming in a functional style often includes using functions as values by passing them in arguments, returning them from other functions, assigning them to variables for later execution, and so forth.</li>
<li>Specifically, functional programming includes:
<ul>
<li><em>Closures</em>: A function-like construct you can store in a variable.</li>
<li><em>Iterators</em>: A way of processing a series of elements.</li>
</ul>
</li>
</ul>
<h4 id="closures"><a class="header" href="#closures">Closures</a></h4>
<ul>
<li>
<p>They are &quot;Anonymous Functions that Can Capture Their Environment&quot;.</p>
</li>
<li>
<p>An example of closure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let expensive_closure = |num| {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    num
};
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Why closures don't require type annotations, but functions (<code>fn</code>) do?</p>
<ul>
<li>Type annotations are required on functions because they’re part of an explicit interface exposed to your users. Defining this interface rigidly is important for ensuring that everyone agrees on what types of values a function uses and returns.</li>
<li>But closures aren’t used in an exposed interface like this: they’re stored in variables and used without naming them and exposing them to users of our library.</li>
</ul>
</li>
<li>
<p>In case, we still want to explicitly define type annotations, we can do it by:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let expensive_closure = |num: u32| -&gt; u32 {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    num
};
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Comparisons for Functions and closures syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Closures will always have only one concrete type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// FAIL: Closure inferred two different types of x, which is against the rules
let example_closure = |x| x;

let s = example_closure(String::from(&quot;hello&quot;));
let n = example_closure(5);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Performing <em>memoization</em> or <em>lazy evaluation</em>:</p>
<ul>
<li>
<p>We can create a struct that will hold the closure and the resulting value of calling the closure.</p>
</li>
<li>
<p>The struct will execute the closure only if we need the resulting value, and it will cache the resulting value so the rest of our code doesn’t have to be responsible for saving and reusing the result.</p>
</li>
<li>
<p>All closures implement at least one of the traits: <code>Fn</code>, <code>FnMut</code>, or <code>FnOnce</code>.</p>
</li>
<li>
<p>Using this information, we can create a <code>Cacher</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Cacher will store a closure inside calculation
// and the computed value inside value
struct Cacher&lt;T&gt;
where
    T: Fn(u32) -&gt; u32,
{
    calculation: T,
    value: Option&lt;u32&gt;,
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>The use of the memoization is that, we can store the closure, that contains computation which takes very long time to finish. Then we can save it's computed value inside the struct, so that we can reuse to computation (thereby preventing expensive computation again and again), as well as update the computed value whenever necessary.</p>
</li>
<li>
<p>We'll need to write an implementation block to make the <code>Cacher</code> easier to use:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Cacher&lt;T&gt;
where
    T: Fn(u32) -&gt; u32,
{
    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
        Cacher {
            calculation,
            value: None
        }
    }

    fn value(&amp;mut self, arg: u32) -&gt; u32 {
        match self.value {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.calculation)(arg);
                self.value = v;
                v
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>The only limitation of this <code>Cacher</code> is that it assumes that, it'll only receive one value, that means even if we call the <code>value()</code> function multiple with different arguments, it'll still return the same value every time and that value will be the computed value when the closure was called for the first time. Here's the explanation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut c = Cacher::new(|a| a);

let v1 = c.value(1); // v1 = 1
let v2 = c.value(2); // v2 = 1
let v3 = c.value(3); // v3 = 1
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>So, here is a better version of the above cacher that can memorize all the arguments and their computed value inside a HashMap, which is also generic. You may refer it's implementation over <a href="https://gist.github.com/utkarshg6/c8a5cb39ef89b8f16fcce3098754c001">here</a>.</p>
</li>
</ul>
</li>
<li>
<p>Capturing the Environmet with closures:</p>
<ul>
<li>
<p>You can't don the following thing using simple functions:</p>
<pre><pre class="playground"><code class="language-rust">// FAIL: Functions can't capture their environment, hence x shouldn't live inside the function
fn main() {
    let x = 4;

    fn equal_to_x(z: i32) -&gt; bool {
        z == x
    }

    let y = 4;

    assert!(equal_to_x(y));
}</code></pre></pre>
</li>
<li>
<p>But, you can easliy do this using closure:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}</code></pre></pre>
</li>
<li>
<p>Closures can capture values from their environment in three ways, which directly map to the three ways a function can take a parameter: taking ownership, borrowing mutably, and borrowing immutably. These are encoded in the three Fn traits as follows:</p>
<ul>
<li><code>FnOnce</code> consumes the variables it captures from its enclosing scope, known as the closure’s environment. To consume the captured variables, the closure must take ownership of these variables and move them into the closure when it is defined. The Once part of the name represents the fact that the closure can’t take ownership of the same variables more than once, so it can be called only once.</li>
<li><code>FnMut</code> can change the environment because it mutably borrows values.</li>
<li><code>Fn</code> borrows values from the environment immutably.</li>
</ul>
</li>
<li>
<p>When you create a closure, Rust infers which trait to use based on how the closure uses the values from the environment. All closures implement <code>FnOnce</code> because they can all be called at least once. Closures that don’t move the captured variables also implement <code>FnMut</code>, and closures that don’t need mutable access to the captured variables also implement <code>Fn</code>. In Listing 13-12, the equal_to_x closure borrows x immutably (so equal_to_x has the Fn trait) because the body of the closure only needs to read the value in x.</p>
</li>
<li>
<p>If you want to force the closure to take ownership of the values it uses in the environment, you can use the <code>move</code> keyword before the parameter list. This technique is mostly useful when passing a closure to a new thread to move the data so it’s owned by the new thread. The <code>move</code> closures may still implement Fn or FnMut, even though they capture variables by move. This is because the traits implemented by a closure type are determined by what the closure does with captured values, not how it captures them. The move keyword only specifies the latter.</p>
</li>
<li>
<p>An example of <code>move</code>:</p>
<pre><pre class="playground"><code class="language-rust">// FAIL: We tried to print x even though it is moved inside closure
fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    println!(&quot;can't use x here: {:?}&quot;, x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}</code></pre></pre>
</li>
<li>
<p>Most of the time when specifying one of the <code>Fn</code> trait bounds, you can start with <code>Fn</code> and the compiler will tell you if you need <code>FnMut</code> or <code>FnOnce</code> based on what happens in the closure body.</p>
</li>
</ul>
</li>
</ul>
<h4 id="iterators"><a class="header" href="#iterators">Iterators</a></h4>
<ul>
<li>
<p>Iterators are lazy in rust, meaning they have no effect until you call methods that consume the iterator to use it up.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1 = vec![1, 2, 3];

let v1_iter = v1.iter(); // It won't do anything useful until called upon

for val in v1_iter { // Now, the iterator is called upon and used
    println!(&quot;Got: {}&quot;, val);
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>To just get the next element stored in iterator:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1 = vec![1, 2, 3];

// Calling the next() method changes the state of iterator,
// hence we'll need to use mut in this case
let mut v1_iter = v1.iter();

assert_eq!(v1_iter.next(), Some(&amp;1));
assert_eq!(v1_iter.next(), Some(&amp;2));
assert_eq!(v1_iter.next(), Some(&amp;3));
assert_eq!(v1_iter.next(), None);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Why is it required to use <code>mut</code> when using <code>next()</code>, but not when using <code>for</code> loop?</p>
<ul>
<li><code>next()</code> - Each call to <code>next</code> eats up an item from the iterator. Hence, we need to define it as <code>mut</code> to be able to do that.</li>
<li><code>for</code> - The loop takes ownership of the iterator and made it mutable behind the scenes. Hence, we don't need to use <code>mut</code> there.</li>
</ul>
</li>
<li>
<p>Difference between <code>iter</code>, <code>into_iter</code>, and <code>iter_mut</code></p>
<ul>
<li>
<p>They all return iterator, except the way they return differs. Here are the differences:</p>
<ul>
<li><code>into_iter</code>: It yields any of <code>T</code>, <code>&amp;T</code> or <code>&amp;mut T</code>, depending on the context.</li>
<li><code>iter</code>: It yields <code>&amp;T</code>.</li>
<li><code>iter_mut</code>: It yields <code>&amp;mut T</code>.</li>
</ul>
</li>
<li>
<p>For more details refer to this <a href="https://stackoverflow.com/questions/34733811/what-is-the-difference-between-iter-and-into-iter">stackoverflow answer</a>.</p>
</li>
</ul>
</li>
<li>
<p><code>Consuming Adaptors</code>: Some methods inside <code>Iterator</code> trait uses <code>next()</code>. It means those functions will also eat away the iterator, just like how <code>next()</code> does. Here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

let total: i32 = v1_iter.sum(); // sum() uses the next() and hence will eat away the iterator
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><code>Iterator Adaptors</code>: Some methods inside <code>Iterator</code> allows you to change iterators into different kinds of iterators. It is also possible to use <code>Iterator</code>, <code>Enumerator</code>, <code>Map</code>, and <code>Filter</code> together. Rust has these functions inside the Iterator Trait.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1: Vec&lt;u32&gt; = vec![0, 1, 2, 3, 4, 5];
let iterator = v1.iter()
                 .enumerate()
                 .filter(|(i, val)| i % 2 == 0)
                 .map(|(i, val)| val); // On it's own it won't do anything, because iterators are lazy

// You can either print them one by one using for loop (remember it'll consume the iterator)
for val in iterator {
    println!(&quot;{}&quot;, val);
}

// Or you can collect them inside a vector, make sure you explicitly specify the type (`Vec&lt;_&gt;`) too.
let new_vector: Vec&lt;_&gt; = iterator.collect();
println!(&quot;New Vector: {:?}&quot;)
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Creating your own iterator:</p>
<ul>
<li>
<p>You'll need to implement <code>Iterator</code> trait on your type.</p>
</li>
<li>
<p>You'll only need to define one function, that is <code>next()</code>, it'll be sufficient.</p>
<pre><pre class="playground"><code class="language-rust">struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Self {
        Self {
            count: 0,
        }
    }
}

impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.count &lt; 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}

fn main() {
    let counter = Counter::new();
    for val in counter {
        println!(&quot;{:?}&quot;, val);
    }

    // Since we have next() method we can use any default implementation of the Iterator trait
    let sum: u32 = Counter::new()
        .zip(Counter::new().skip(1)) // Skips first element only and generate pairs { (1,2) (2,3) (3,4) (4,5) } because (5,None) is ignored
        .map(|(a, b)| a * b) // [2, 6, 12, 20]
        .filter(|x| x % 3 == 0) // [6, 12]
        .sum(); // 18
}</code></pre></pre>
</li>
</ul>
</li>
<li>
<p>Which is faster, <code>for</code> loop or <code>iterator adapters</code>?</p>
<ul>
<li>
<p>Here are the benchmarks:</p>
<pre><code class="language-zsh">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
</li>
<li>
<p>Iterators, although a high-level abstraction, get compiled down to roughly the same code as if you’d written the lower-level code yourself. Iterators are one of Rust’s <code>zero-cost abstractions</code>, which means that using the abstraction imposes no additional runtime overhead.</p>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="smart-pointers"><a class="header" href="#smart-pointers">Smart Pointers</a></h3>
<ul>
<li>Differences between Pointer and Smart Pointer:</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Pointer</th><th>Smart Pointer</th></tr></thead><tbody>
<tr><td>A pointer is a general concept for a variable that contains an address in memory.</td><td>Smart pointers, on the other hand, are data structures that not only act like a pointer but also have additional metadata and capabilities.</td></tr>
<tr><td>References are pointers that only borrow data.</td><td>Smart pointers <em>own</em> the data they point to.</td></tr>
<tr><td>The most common kind of pointer in Rust is a reference and is indicated by <code>&amp;</code>.</td><td>The commonly used smart pointers are <code>String</code> and <code>Vec&lt;T&gt;</code>.</td></tr>
</tbody></table>
</div>
<ul>
<li>Smart pointers are usually implemented using <code>structs</code>.</li>
<li>The characteristic that distinguishes a smart pointer from an ordinary struct is that smart pointers implement the <code>Deref</code> and <code>Drop</code> traits.
<ul>
<li><code>Deref</code>: Allows an instance of the smart pointer struct to behave like a reference so you can write code that works with either references or smart pointers.</li>
<li><code>Drop</code>: Allows you to customize the code that is run when an instance of the smart pointer goes out of scope.</li>
</ul>
</li>
</ul>
<h4 id="boxt"><a class="header" href="#boxt"><code>Box&lt;T&gt;</code></a></h4>
<ul>
<li>
<p>For allocating values on Heap.</p>
</li>
<li>
<p>Box allows you to store <em>data on heap</em> and the <em>pointer to the heap data on stack</em>.</p>
</li>
<li>
<p>You’ll use them most often in these situations:</p>
<ul>
<li>When you have a type whose size can’t be known at compile time and you want to use a value of that type in a context that requires an exact size</li>
<li>When you have a large amount of data and you want to transfer ownership but ensure the data won’t be copied when you do so</li>
<li>When you want to own a value and you care only that it’s a type that implements a particular trait rather than being of a specific type</li>
</ul>
</li>
<li>
<p>Once Box goes out of scope, the deallocation happens for the box (stored on the stack) and the data it points to (stored on the heap).</p>
</li>
<li>
<p>Using <code>Box&lt;T&gt;</code> for the recursive call:</p>
<ul>
<li>
<p>Let's try to create an enum which will create it's variant recursively:</p>
<pre><pre class="playground"><code class="language-rust">// FAIL: While computing Size for Cons, Rust will detect an inifinite memory allocation
enum List {
    Cons(i32, List),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}</code></pre></pre>
</li>
<li>
<p>When Rust will try to recognize the size, it'll recognize that it is an infinite loop:</p>
<img src="https://doc.rust-lang.org/book/img/trpl15-01.svg" alt="Infinite List Containing Infinite Cons Value" width="400"/>
</li>
<li>
<p>Now, to make it easier for Rust to identify the size of enum at compile time, we can use <code>Box&lt;T&gt;</code> for the recursive call. Since <code>Box&lt;T&gt;</code> is a pointer, Rust will need not to find the size what's inside of it, instead just allocate the memory for it's pointer.</p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}</code></pre></pre>
</li>
<li>
<p>Conceptually, we still have a list, created with lists “holding” other lists, but this implementation is now more like placing the items next to one another rather than inside one another.</p>
<img src="https://doc.rust-lang.org/book/img/trpl15-02.svg" alt="List that is not infinitely sized" width="400"/>
</li>
</ul>
</li>
<li>
<p>Since <code>Box&lt;T&gt;</code> implements the <code>Deref</code> trait, so you can use the <code>*</code> operator to dereference it.</p>
</li>
</ul>
<h4 id="deref-trait"><a class="header" href="#deref-trait"><code>Deref</code> Trait</a></h4>
<ul>
<li>
<p>Note that the <code>*</code> operator is replaced with a call to the deref method and then a call to the <code>*</code> operator. It means that <code>*y</code>, translates into:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>*(y.deref())
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>We're trying to re-create <code>Box&lt;T&gt;</code> and it's capabilities to dereference itself. One important thing to notice, here we're only mimicing the dereferencing because the data doesn't actually get stored on heap.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Deref;

struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
  fn new(x: T) -&gt; MyBox&lt;T&gt;  {
      MyBox(x)
  }
}

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h4 id="deref-coercion"><a class="header" href="#deref-coercion">Deref Coercion</a></h4>
<ul>
<li>
<p>Deref coercion can convert <code>&amp;String</code> to <code>&amp;str</code>. It's possible because <code>String</code> implements the <code>Deref</code> trait such that it returns <code>&amp;str</code>.</p>
</li>
<li>
<p>They are meant for the arguments of functions and methods. The ease is that, you can pass <code>&amp;String</code> into a function that accepts <code>&amp;str</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn hello(name: &amp;str) {
    println!(&quot;Hello, {}!&quot;, name);
}

fn main() {
  let name = String::from(&quot;Bob&quot;);
  hello(&amp;name);
}</code></pre></pre>
</li>
<li>
<p>Deref coercion was added to Rust so that programmers writing function and method calls don’t need to add as many explicit references and dereferences with <code>&amp;</code> and <code>*</code>.</p>
</li>
<li>
<p>How does Rust automatically converts <code>&amp;String</code> to <code>&amp;str</code>?</p>
<ul>
<li>It happens because <code>Deref</code> trait is implemented.</li>
<li>Rust simplifies all the deref implementations.</li>
</ul>
</li>
<li>
<p>Here's an even complex example of deref coercion, using the <code>MyBox</code>, that we created earlier:</p>
<ul>
<li>
<p>Instead of calling this:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;(*m)[..]);
}</code></pre></pre>
</li>
<li>
<p>Here we are manually converting:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(*m) =&gt; MyBox&lt;String&gt; -&gt; String
[..] =&gt; String -&gt; str
&amp; =&gt; str -&gt; &amp;str
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>We can just call this:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;m);
}</code></pre></pre>
</li>
<li>
<p>Rust simplifies the deref implementations by calling the <code>deref()</code> again and again. First It'll call <code>deref()</code> for <code>MyBox</code> then for <code>String</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&amp;MyBox&lt;String&gt; -&gt; &amp;String -&gt; &amp;str
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
</li>
</ul>
<p>Note: When the Deref trait is defined for the types involved, Rust will analyze the types and use <code>Deref::deref</code> as many times as necessary to get a reference to match the parameter’s type. The number of times that <code>Deref::deref</code> needs to be inserted is resolved at compile time, so there is no runtime penalty for taking advantage of deref coercion!</p>
<ul>
<li>
<p>Rust does deref coercion when it finds types and trait implementations in three cases:</p>
<ul>
<li>From <code>&amp;T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;mut U</code> when <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
</ul>
</li>
</ul>
<p>Note: The first case states that if you have a <code>&amp;T</code>, and <code>T</code> implements <code>Deref</code> to some type <code>U</code>, you can get a <code>&amp;U</code> transparently. the second case is similar. The third case is a bit different as mutable reference changes into immutable reference, though vice versa is not true.</p>
<h4 id="drop-trait"><a class="header" href="#drop-trait"><code>Drop</code> Trait</a></h4>
<ul>
<li>
<p>In Rust, you can specify that a particular bit of code be run whenever a value goes out of scope, and the compiler will insert this code automatically.</p>
</li>
<li>
<p>As a result, you don’t need to be careful about placing cleanup code everywhere in a program that an instance of a particular type is finished with—you still won’t leak resources!</p>
<pre><pre class="playground"><code class="language-rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping CustomSmartPointer with data `{}`!&quot;, self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;my stuff&quot;),
    };
    let d = CustomSmartPointer {
        data: String::from(&quot;other stuff&quot;),
    };
    println!(&quot;CustomSmartPointers created.&quot;);
}
// Output -
// CustomSmartPointers created.
// Dropping CustomSmartPointer with data `other stuff`!
// Dropping CustomSmartPointer with data `my stuff`!</code></pre></pre>
</li>
<li>
<p>Notice that, variables are dropped in the reverse order, <code>d</code> was dropped before <code>c</code>.</p>
</li>
<li>
<p>There might be some cases when you want to manually drop the Smart Pointer, instead of waiting for the scope to end. For example, you want to release the lock so that other code in the same scope can acquire the lock.</p>
<ul>
<li>
<p>First thing is that, you can't call the <code>drop()</code> from the <code>Drop</code> trait.</p>
<pre><pre class="playground"><code class="language-rust">// FAIL: This is not allowed in Rust, compiler will throw &quot;explicit destructor calls not allowed&quot;
fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;some data&quot;),
    };
    println!(&quot;CustomSmartPointer created.&quot;);
    c.drop();
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}</code></pre></pre>
<pre><code class="language-zsh">  --&gt; src/main.rs:16:7
   |
16 |     c.drop();
   |     --^^^^--
   |     | |
   |     | explicit destructor calls not allowed
   |     help: consider using `drop` function: `drop(c)`
</code></pre>
</li>
<li>
<p>Compiler uses term <code>destructor</code>, which is the general programming term for a function that cleans up an instance. It is analogous to the word <code>constructor</code>.</p>
</li>
<li>
<p>The reason that compiler doesn't allows us to do that, is to prevent the <em>double free error</em>.</p>
</li>
<li>
<p>The alternative is to use <code>drop()</code> from <code>std::mem::drop</code>, good thing is it's already in the <code>prelude</code>, so you don't need to import it.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;some data&quot;),
    };
    println!(&quot;CustomSmartPointer created.&quot;);
    drop(c); // Notice, we're passing it as an argument
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}

// Ouput -
// CustomSmartPointer created.
// Dropping CustomSmartPointer with data `some data`!
// CustomSmartPointer dropped before the end of main.</code></pre></pre>
</li>
<li>
<p>It solves the <em>double free error</em> through the ownership rules, as we pass it as an argument.</p>
</li>
</ul>
</li>
</ul>
<h4 id="rct"><a class="header" href="#rct"><code>Rc&lt;T&gt;</code></a></h4>
<ul>
<li>
<p>Also known as <em>Reference Counted Smart Pointer</em>, it allows multiple ownership.</p>
</li>
<li>
<p>It does that by keeping the count of references. When the count becomes 0, it means that there are no references linked to data, so it's safe to clean.</p>
</li>
<li>
<p>Imagine <code>Rc&lt;T&gt;</code> as a TV in a family room. When one person enters to watch TV, they turn it on. Others can come into the room and watch the TV. When the last person leaves the room, they turn off the TV because it’s no longer being used. If someone turns off the TV while others are still watching it, there would be uproar from the remaining TV watchers!</p>
</li>
<li>
<p>Use case:</p>
<ul>
<li>We want to allocate data on heap and we want multiple parts of our code to read it.</li>
<li>The problem is that we don't know which part will stop reading it last, that's why we can't make someone as an owner.</li>
<li>For those cases, <code>Rc&lt;T&gt;</code> will help us, it'll save us from deciding someone as owner and will allow multiple parts to read it at the same time.</li>
</ul>
</li>
<li>
<p>With <code>Rc&lt;T&gt;</code> it is possible to create two lists that both share ownership of a third list.</p>
<img src="https://doc.rust-lang.org/book/img/trpl15-03.svg" alt="List that is not infinitely sized" width="400"/>
<ul>
<li>
<p>Trying to do this with <code>Box&lt;T&gt;</code> fails:</p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}</code></pre></pre>
</li>
<li>
<p>We can also use references with lifetimes to solve this problem, but <code>Rc&lt;T&gt;</code> is better here.</p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a)); // Notice that we don't need to use Rc&lt;T&gt; here, since no one will be owning b and c
    let c = Cons(4, Rc::clone(&amp;a)); // Also notice that we're using Rc::clone() and passing reference to create owners
}</code></pre></pre>
</li>
<li>
<p><code>Rc::clone()</code> never makes deep copy, unlike <code>clone()</code>. <code>Rc::clone()</code> only increments the reference count, which doesn’t take much time.</p>
</li>
<li>
<p>To Increase Count: <code>Rc::clone()</code>, To Decrease Count: <code>Drop</code> does when the variable goes out of scope.</p>
</li>
</ul>
</li>
</ul>
<p>Note: <code>Rc&lt;T&gt;</code> can only allow multiple owners to read data and not to mutate it. For interior mutability there is another Smart Pointer named <code>RefCell&lt;T&gt;</code>.</p>
<h4 id="refcellt"><a class="header" href="#refcellt"><code>RefCell&lt;T&gt;</code></a></h4>
<ul>
<li>
<p>Allows interior mutability to the immutable data.</p>
</li>
<li>
<p>Interior mutability is a design pattern in Rust that allows you to mutate data even when there are immutable references to that data; normally, this action is disallowed by the borrowing rules.</p>
</li>
<li>
<p>It uses <code>unsafe</code> rust code to function.</p>
</li>
<li>
<p>An example:</p>
</li>
<li>
<p>Consider one <code>trait</code> named <code>Messanger</code> and another <code>struct</code> named <code>LimitTracker</code>.</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: Messenger&gt; {
  messenger: &amp;'a T,
  value: usize;
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
where
    T: Messenger,
{
    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
      ...
    }

    pub fn set_value(&amp;mut self, value: usize) { // Problem 1: We want mutable reference of self, but it includes immutable reference to messenger
      self.value = value;

      if (value &gt; 100) {
        self.messenger.send(&quot;Error: You are over your quota!&quot;); // Problem 2: send() is an immutable function in trait, but self should be mutable.
      }
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>
<p><code>LimitTracker</code> takes in a reference of <code>struct</code> that implements <code>Messenger</code>, so that it can store it as one of it's field.</p>
</li>
<li>
<p>Inside <code>LimitTracker</code>, the problem is that <code>set_value()</code> takes <strong>mutable reference</strong> of <code>self</code>, but the <code>messenger</code> is an immutable reference and it's function send is also <code>immutable</code>. So, how can we test this <code>set_value()</code>?</p>
</li>
<li>
<p>This will fail to compile:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// FAIL: send() is required to be mutable by LimitTracker but immutable due to trait Messenger
#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: vec![], // This is immutable
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
             // We're trying to push on immutbale field, we also can't make send() mutable
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Here's the solution using <code>RefCell&lt;T&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        // RefCell will make sent_messages mutable even though
        // it's parent MockMessenger can seem immutable to others
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                // Now, RefCell will wrap the vector and will allow it to be mutable
                // at places where it's parent is asked to be immutable
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            // MockMessenger will seem immutable to send() but
            // sent_messages is mutable, and items can be pushed into it
            self.sent_messages.borrow_mut().push(String::from(message)); // borrow_mut() will generate mutable reference for push()
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--

        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1); // borrow() will generate the immutable reference, since we're only reading
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>We use the <code>&amp;</code> and <code>&amp;mut</code> syntax with references. With <code>RefCell&lt;T&gt;</code>, we use the <code>borrow()</code> and <code>borrow_mut()</code> methods and they return <code>Ref&lt;T&gt;</code> and <code>RefMut&lt;T&gt;</code> respectively. They both implement <code>Deref</code> trait.</p>
</li>
<li>
<p><code>RefCell&lt;T&gt;</code> lets us have many immutable borrows or one mutable borrow at any point in time. It keeps a count of whenever we call the <code>borrow()</code>.</p>
</li>
<li>
<p>In case of an error, it won't be just a compile error, but will appear on Runtime, and will cause a panic.</p>
</li>
</ul>
<h4 id="differences-between-boxt-rct-and-refcellt"><a class="header" href="#differences-between-boxt-rct-and-refcellt">Differences between <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code></a></h4>
<div class="table-wrapper"><table><thead><tr><th>Property</th><th><code>Box&lt;T&gt;</code></th><th><code>Rc&lt;T&gt;</code></th><th><code>RefCell&lt;T&gt;</code></th></tr></thead><tbody>
<tr><td>Ownership</td><td>Single Ownership</td><td>Multiple Ownership</td><td>Single Ownership</td></tr>
<tr><td>Mutability of Inner Data</td><td>Immutable or Mutable</td><td>Only Immutable</td><td>Immutable or Mutable</td></tr>
<tr><td>Borrowing Rules Check</td><td>Compiled Time (compiler errors)</td><td>Compiled Time (compiler errors)</td><td>Runtime (panics at runtime)</td></tr>
<tr><td>Multithreading</td><td></td><td>Only for Single Threaded Scenarios</td><td>Only for Single Threaded Scenarios</td></tr>
</tbody></table>
</div>
<h4 id="using-refcellt-with-rct"><a class="header" href="#using-refcellt-with-rct">Using <code>RefCell&lt;T&gt;</code> with <code>Rc&lt;T&gt;</code></a></h4>
<ul>
<li>
<p>It'll give you superpowers.</p>
</li>
<li>
<p>Now you can have a value that has multiple owners and can also mutate.</p>
</li>
<li>
<p>To use it, you'll have to wrap it like this, <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>.</p>
</li>
<li>
<p>Here's our modified <code>Cons</code> list:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Now, we can have a list like this:</p>
<pre><code class="language-zsh">b --|
    a---Nil
c --|
</code></pre>
</li>
<li>
<p>Here, <code>a</code> can have multiple owners <code>b</code> and <code>c</code>, and it's value can also mutate.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let value = Rc::new(RefCell::new(5)); // Created a value that can have multiple owners and can also mutate

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil))); // Make a such that it can be owned by multiple people

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a)); // Make b the owner of a
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a)); // Made c the owner of a

    *value.borrow_mut() += 10; // Rc -&gt; RefCell -&gt; &amp;mut -&gt; inner_element, then 10 is added to the inner_element in place

    println!(&quot;a after = {:?}&quot;, a); // Value of a: Cons(RefCell { value: 15 }, Nil)
    println!(&quot;b after = {:?}&quot;, b); // Value of b: Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
    println!(&quot;c after = {:?}&quot;, c); // Value of c: Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
}</code></pre></pre>
</li>
<li>
<p>Other Types to provide interior mutability:</p>
<ul>
<li><code>Cell&lt;T&gt;</code>: It copies the data instead of giving references.</li>
<li><code>Mutex&lt;T&gt;</code>: It provides interior mutability that's safe to use in multiple threads.</li>
</ul>
</li>
</ul>
<h4 id="memory-leak"><a class="header" href="#memory-leak">Memory Leak</a></h4>
<ul>
<li>
<p>When we accidentally create memory that is never cleaned up is called <em>Memory Leak</em>.</p>
</li>
<li>
<p>Rust’s memory safety guarantees make it difficult, but not impossible.</p>
</li>
<li>
<p>Rust allows memory leaks by using <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>.</p>
</li>
<li>
<p>By using both of them together, it's possible to create a <em>reference cycle</em>.</p>
</li>
<li>
<p>A <em>reference cycle</em> happens when reference of <code>a</code> is owned by <code>b</code> and reference of <code>b</code> is owned by <code>a</code>.</p>
</li>
<li>
<p>First of all, this will cause an infinite loop of references.</p>
</li>
<li>
<p>Also, it'll be impossible for Rust to <code>Drop</code> the values of <code>a</code> and <code>b</code>, as their reference count will never be zero.</p>
</li>
<li>
<p>This is one of Rust's limitations, and is referred to the <em>problem of Memory Leak</em>.</p>
</li>
<li>
<p>Reference Cycle in Action:</p>
<pre><pre class="playground"><code class="language-rust">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;), // We can replace the list in place now
    Nil
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil)))); // a = (5, Nil)


    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a)))); // b = (10, a)

    if let Some(link) = a.tail() {
        *link.borrow_mut() = b; // a = (5, b)
    }

    // At this point, Rc Count of a: 2, b: 2

    // This will try to print the lists infinitely
    // and then will crash with the stack overflow error
    println!(&quot;a next item = {:?}&quot;, a.tail());
}

// In case, we comment out the println!()
// At the end of scope, Rust will try to decrease the count of references
// Rc Count of b will decrease to 1
// Rc Count of a will decrease to 1
// Neither a nor b will be dropped as their count is not 0 and
// will still stay on the heap, causing Memory Leak</code></pre></pre>
</li>
<li>
<p>You may take help of this diagram to understand better:</p>
<img src="https://doc.rust-lang.org/book/img/trpl15-04.svg" alt="List that is not infinitely sized" width="400"/>
</li>
</ul>
<p>Important Lesson:
You can't rely on Rust's memory safety while using <code>RefCell&lt;T&gt;</code> and <code>Rc&lt;T&gt;</code> together, or another combination with interior mutability, as it may cause the problem of <em>Memory Leak</em>.</p>
<p>Solutions to prevent Reference Cycles:</p>
<ul>
<li>Use Automated tests, Code reviews, and other Software development practices to minimize.</li>
<li>Reorganize data structure so that some references express ownership and some references don't.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Strong Count</th><th>Weak Count</th></tr></thead><tbody>
<tr><td>Rust will only drop an element if this count becomes zero.</td><td>Rust will drop an element in case it gets out of scope, even if the count is not zero.</td></tr>
<tr><td><code>Rc&lt;T&gt;</code> uses strong count.</td><td><code>Weak&lt;T&gt;</code> uses weak count.</td></tr>
<tr><td>It's hard to prevent reference cycle.</td><td>It's easier to prevent reference cycle.</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>Preventing Reference Cycle using <code>Weak&lt;T&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;, // Child won't own it's parent
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}

fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![])
    });

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)])
    });

    // The downgrade() changes Rc -&gt; Weak
    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    // The upgrade() returns Some() or None, representing the value
    println!(&quot;Leaf parent: {:?}&quot;, leaf.parent.borrow().upgrade());
}</code></pre></pre>
</li>
<li>
<p>The output will look like this:</p>
<pre><code class="language-zsh">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
</li>
<li>
<p>Notice, at some places only <code>Weak</code> is there, and the whole element is not printed. This is Rust's way of preventing infinite output.</p>
</li>
<li>
<p>This lack of inifinite output, indicates that reference cycle is prevented.</p>
</li>
<li>
<p>Here's another example, using the same struct to show how strong count and weak count will change:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    // leaf strong = 1, weak = 0

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        // Since Rc is downgrading branch, branch's weak count will increase by 1
        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        // branch strong = 1, weak = 1

        // leaf strong = 2, weak = 0
    }

    // leaf strong = 1, weak = 0
}</code></pre></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h2>
<ul>
<li>Difference between Concurrency and Parallel programming:</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Concurrent Programming</th><th>Parallel Programming</th></tr></thead><tbody>
<tr><td>Where different parts of program execute independently.</td><td>Where different parts of program execute at the same time.</td></tr>
</tbody></table>
</div>
<h4 id="using-threads"><a class="header" href="#using-threads">Using Threads</a></h4>
<ul>
<li>
<p>OS manages multiple processes at once.</p>
</li>
<li>
<p>An executed program's code is run in a process.</p>
</li>
<li>
<p>You can write programs such that there are indpendent pieces of code that run simultaneously.</p>
</li>
<li>
<p>The features that run these parts simultaneously are called <em>threads</em>.</p>
</li>
<li>
<p>Threads can run simultaneously, there’s no inherent guarantee about the order in which parts of your code on different threads will run. This causes the following problems:</p>
<ul>
<li><strong>Race conditions</strong>: Where threads are accessing data or resources in an inconsistent order.</li>
<li><strong>Deadlocks</strong>: Where two threads are waiting for each other to finish using a resource the other thread has, preventing both threads from continuing.</li>
<li><strong>Bugs</strong>: Hard to reproduce bugs, and only happens in certain situations.</li>
</ul>
</li>
<li>
<p>Many operating systems provide an API for creating new threads. This model where a language calls the operating system APIs to create threads is sometimes called <strong><em>1:1</em></strong>, meaning <em>1 OS Thread / 1 Language Thread</em>. The rust standard library provides the implementation for only <em>1:1</em>.</p>
</li>
<li>
<p>Creating a new thread with <code>spawn</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
  thread::spawn(|| {
    for i in 1..10 {
      println!(&quot;hi number {} from the spawned thread&quot;, i);
      thread::sleep(Duration::from_millis(1));
    }
  });

  for i in 1..5 {
    println!(&quot;hi number {} from the main thread&quot;, i);
    thread::sleep(Duration::from_millis(1));
  }
}</code></pre></pre>
</li>
<li>
<p>The output will be:</p>
<pre><code class="language-zsh">hi number 1 from the main thread
hi number 1 from the spawned thread
hi number 2 from the main thread
hi number 2 from the spawned thread
hi number 3 from the main thread
hi number 3 from the spawned thread
hi number 4 from the main thread
hi number 4 from the spawned thread
hi number 5 from the spawned thread
</code></pre>
</li>
<li>
<p>The spawned thread will automatically die as the main thread ends.</p>
</li>
<li>
<p>That's why spawned thread ran 5 times, 4 times same as main thread and the 5th time, which is exectued to break the condition for the main thread's for loop condition.</p>
</li>
<li>
<p>Which thread will execute first is not guaranteed, you may notice in our case, the main thread runs first, even though according to the code, the spawned thread should have ran first.</p>
</li>
<li>
<p>In fact, there is not even a guarantee that this spwaned thread will even run at all.</p>
</li>
<li>
<p>We can make sure that the spawned thread will definitely run and will execute completely, by using the <code>join()</code></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    // Let's store the thread in a variable
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }

    // This will make sure that the spawned thread
    // finishes before the main thread ends
    handle.join().unwrap();
}</code></pre></pre>
</li>
<li>
<p>The two threads will now continue alternating, but the main thread will wait because of the call to <code>handle.join()</code> and will not end until the spawned thread is finished.</p>
</li>
<li>
<p>It is very important, where you call the <code>handle.join()</code>, as it may create an unexpected behaviour:</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre></pre>
</li>
<li>
<p>This will give us this output:</p>
<pre><code class="language-zsh">hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
</code></pre>
</li>
<li>
<p>So, make sure that you're calling the <code>handle.join()</code> to prevent undesired behaviour.</p>
</li>
<li>
<p>When we use closure, Rust will infer that we want to only borrow the variable.</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    // Notice, here v is only borrowed here,
    // it's possible that the closure may outlive
    // and v may die early, so Rust will throw us
    // error, and will ask us to use move
    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join().unwrap();
}</code></pre></pre>
</li>
<li>
<p>So, we need to expicitly add the <code>move</code> keyword, to tell Rust to transfer ownership of <code>v</code> to the closure.</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    // Now, we cannot use v over here, inside the main thread for any reason

    handle.join().unwrap();
}</code></pre></pre>
</li>
</ul>
<h4 id="using-message-passing-to-transfer-data-between-threads"><a class="header" href="#using-message-passing-to-transfer-data-between-threads">Using Message Passing to Transfer Data Between Threads</a></h4>
<p><em>“Do not communicate by sharing memory; instead, share memory by communicating.” - Go Language Documentation</em></p>
<ul>
<li>
<p>Rust sends messages between threads to accomplish concurrency.</p>
</li>
<li>
<p>Rust uses <em>channel</em> for the message-sending concurrency (it works similar to a river stream), it has two parts:</p>
<ul>
<li><em>Transmitter</em>: The upstream location</li>
<li><em>Receiver</em>: The downstream location</li>
</ul>
</li>
<li>
<p>A channel is said to be <em>closed</em> if either the transmitter or receiver half is dropped.</p>
</li>
<li>
<p>You may create a channel just like this:</p>
<ul>
<li>
<p>A channel can have multiple producer of values (multiple sources of river), but only 1 consumer of those values (all rivers will mix into one river).</p>
</li>
<li>
<p>A channel produces it's two parts, inside a tuple and are abbreviated as <code>tx</code> and <code>rx</code>, for transmitter and receiver respectively.</p>
<pre><pre class="playground"><code class="language-rust">// mpsc stands for multiple producer, single consumer
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        // We'll send the value to the receiver's end
        // and in case there's a problem at receiving
        // end, it'll thrown an error and cause a panic
        tx.send(val).unwrap();
    });

    // The recv()
    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}</code></pre></pre>
</li>
</ul>
</li>
<li>
<p>Ways to receive the values from the channel:</p>
<ul>
<li><code>recv()</code>: It'll block the main thread’s execution and wait until a value is sent down the channel.</li>
<li><code>try_recv()</code>: This method <strong>doesn't block</strong>, but may not contain any value for some time. So, you'll need to call this every so often, by writing a loop.</li>
</ul>
</li>
<li>
<p>Sending and Receiving multiple values:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;hi&quot;),
            String::from(&quot;from&quot;),
            String::from(&quot;the&quot;),
            String::from(&quot;thread&quot;),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;more&quot;),
            String::from(&quot;messages&quot;),
            String::from(&quot;from&quot;),
            String::from(&quot;you&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    // We’re not calling the recv function explicitly anymore:
    // When the channel is closed, iteration will end.
    for received in rx {
        println!(&quot;Got: {}&quot;, received);
    }
}</code></pre></pre>
</li>
</ul>
<h4 id="shared-state-concurrency"><a class="header" href="#shared-state-concurrency">Shared-State Concurrency</a></h4>
<ul>
<li>Shared memory concurrency is like multiple ownership: multiple threads can access the same memory location at the same time.</li>
<li>We can use <em>Mutex</em> to allow access to data from one thread at a time.</li>
</ul>
<h5 id="mutex"><a class="header" href="#mutex">Mutex</a></h5>
<ul>
<li>
<p><em>Mutex</em> is an abbreviation of <em>Mutual Exclusion</em>.</p>
</li>
<li>
<p>It locks the data such that others can use. Lock is a data structure that keeps track of who currently has exclusive access to the data.</p>
</li>
<li>
<p>These are the rules that you'll have to follow while using a Mutex:</p>
<ul>
<li>You must attempt to acquire the lock before using the data.</li>
<li>When you’re done with the data that the mutex guards, you must unlock the data so other threads can acquire the lock.</li>
</ul>
</li>
<li>
<p>Here's an example:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock() // It'll block the old thread, until we unlock the mutex
                       .unwrap(); // lock() may fail if the old thread panics, so unwrap() will also panic the current thread
        *num = 6; // Mutex returns a Smart Pointer named MutexGuard, that's why we need to dereference it to change it's value
    } // MutexGuard has a Drop trait implementation, which automatically unlocks the mutex when it goes out of scope

    println!(&quot;m = {:?}&quot;, m);
}</code></pre></pre>
</li>
<li>
<p>Here's an example wehere the varaible <code>counter</code> will be shared among 10 threads, where each of them will try to increment it by 1.</p>
<ul>
<li>Why can't we directly use <code>Mutex</code> within multiple threads?
<ul>
<li>The threads use <code>move</code>, which moves the ownership of variable to the thread.</li>
<li>Rust won't allow us to move the ownership of lock counter in multiple threads.</li>
</ul>
</li>
<li>Why can't we use <code>Rc&lt;T&gt;</code>, to provide multiple ownership to individual threads?
<ul>
<li><code>Rc&lt;T&gt;</code> is not safe to share across threads. It is possible if we use <code>Rc&lt;T&gt;</code> in multiple threads, then both threads might update the reference count at same time.</li>
<li>It doesn’t use any concurrency primitives to make sure that changes to the count can’t be interrupted by another thread.</li>
<li>That could lead to Wrong Counts and Memory Leak.</li>
</ul>
</li>
<li>What do we need then?
<ul>
<li>What we need is a type exactly like <code>Rc&lt;T&gt;</code> but one that makes changes to the reference count in a thread-safe way.</li>
<li>Fortunately, we have <code>Arc&lt;T&gt;</code> (atomically referenced counter), it is almost like <code>Rc&lt;T&gt;</code>, except the counts are maintained atomically.</li>
<li>Atomics are primitives that are safe to share across threads.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    // Mutex is used to lock a variable so that other thread can use
    // Arc provides multiple ownership like Rc&lt;T&gt; and it is thread safe
    let counter = Arc::new(Mutex::new(0)); // Notice counter is immutable, it's because Mutex provides interior mutability, similar to RefCell
    let mut handles = vec![];

    for _ in 1..=10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut value = counter.lock().unwrap();
            *value += 1
        });

        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;The value of counter: {}&quot;, *counter.lock().unwrap());
}</code></pre></pre>
</li>
<li>
<p>The combination of <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>, is analogous to <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>.</p>
</li>
<li>
<p>Keep in mind using <code>Mutex&lt;T&gt;</code> is risky, as logical errors may lead to <em>deadlocks</em>.</p>
</li>
</ul>
<h4 id="send-and-sync-trait"><a class="header" href="#send-and-sync-trait"><code>Send</code> and <code>Sync</code> trait</a></h4>
<ul>
<li>
<p>These two traits are part of the language itself, unlike otheer features of concurrency as they were part of the standard library.</p>
</li>
<li>
<p>They are called <code>std::marker</code> traits.</p>
</li>
<li>
<p><code>Send</code> vs <code>Sync</code></p>
<div class="table-wrapper"><table><thead><tr><th><code>Send</code></th><th><code>Sync</code></th></tr></thead><tbody>
<tr><td>It is safe to transfer ownership of a type between threads.</td><td>It is safe to use that type's reference betweeen threads.</td></tr>
<tr><td>Any type <code>T</code> that implements <code>Sync</code></td><td>Type <code>T</code> is <code>Sync</code>, if it's reference (<code>&amp;T</code>) is <code>Send</code> or if type <code>T</code> implements <code>Sync</code>.</td></tr>
<tr><td>Except <code>Rc&lt;T&gt;</code>, almost all types are <code>Send</code>. (use <code>Arc&lt;T&gt;</code> instead).</td><td>Primitive Types, <code>Mutex&lt;T&gt;</code> are <code>Sync</code> but <code>Rc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code> are not.</td></tr>
</tbody></table>
</div></li>
<li>
<p>We don't need to implement <code>Send</code> and <code>Sync</code> for the types that are made up of those types that implements these traits.</p>
</li>
<li>
<p>In case you need to implement thes traits for a particular type than it means you'll need to write some <code>unsafe</code> rust code. You can learn the Dark Arts of Unsafe Code from this book <a href="https://doc.rust-lang.org/nomicon/index.html">“The Rustonomicon”</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="oop-object-oriented-programming"><a class="header" href="#oop-object-oriented-programming">OOP (Object Oriented Programming)</a></h2>
<ul>
<li>Characterstics of OOP:
<ul>
<li><em>Objects contain data and behaviour</em>:
<ul>
<li>Programs should make up of objects.</li>
<li>An object packages both data and it's methods.</li>
<li>Rust offers <code>struct</code>, <code>enum</code> and <code>impl</code> blocks to provide this characterstic.</li>
</ul>
</li>
<li><em>Encapsulation</em>:
<ul>
<li>When the implementation details are hidden from the code that is using the object.</li>
<li>The only way to use an object is through it's public API.</li>
<li>This enables the programmer to change and refactor an object’s internals without needing to change the code that uses the object.</li>
<li>Rust encapsulates everything by default and offers <code>pub</code> keyword to make things public.</li>
</ul>
</li>
<li><em>Inheritance</em>:
<ul>
<li>When an object can inherit from another object’s definition, so that it can use it's parent object's data and behavior without defining them again.</li>
<li>Rust doesn't offers inheritance between <code>struct</code>, but has <code>trait</code> where you can use default methods that is both reusable and can be overridden.</li>
<li>The reasons to use inheritance are: <em>code reusability</em> and <em>polymorphism</em>.</li>
<li>Polymorphism means that you don't need to explicitly define the type in code, but can be detected during runtime. It is useful when two types share same characterstics.</li>
<li>Rust offers polymorphism in a more general manner. It offers <code>generics</code> to generalize the accepted types and <code>trait bounds</code>, to constraint the allowed types.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Note: People think &quot;polymorphism is synonymous with inheritance&quot;. But it is a more general concept which means that a certain code can be referred to multiple types. It is used when two types share some common characterstics. In inheritance, those types are only subclasses.</p>
<ul>
<li>
<p>Problems with Inheritance:</p>
<ul>
<li>It adds the risk of sharing more code than necessary.</li>
<li>Subclasses are forced to share all the characterstics of the parents, even though sometimes it's not necessary or even undesired.</li>
<li>Sometimes calling the functions on the subclass doen't makes sense and even cause errors.</li>
<li>Due to this, some programming languages will only allow a subclass to inherit from one class, further restricting the flexibility of a program’s design.</li>
</ul>
</li>
<li>
<p>Rust is different, it takes a completely different approach by using trait objects instead of inheritance.</p>
</li>
</ul>
<h4 id="defining-a-common-behaviour-using-trait"><a class="header" href="#defining-a-common-behaviour-using-trait">Defining a common behaviour using trait</a></h4>
<ul>
<li>
<p>A <code>trait</code> object points to both:</p>
<ul>
<li>An instance of a type implementing our specified trait</li>
<li>A table used to look up trait methods on that type at runtime.</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Property</th><th><code>struct</code> or <code>enum</code></th><th><code>trait</code></th><th>Objects in other languages</th></tr></thead><tbody>
<tr><td>Stores Data</td><td>Yes</td><td>No</td><td>Yes</td></tr>
<tr><td>Stores Behaviour</td><td>No</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Data and behaviour</td><td>Seperated by <code>impl</code> blocks.</td><td>Combined</td><td>Combined</td></tr>
<tr><td>Uses</td><td>Store same items together</td><td>Store common behaviour and allow abstraction</td><td>Store same items and their common behavior</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>An example:</p>
<ul>
<li>
<p><em>Problem:</em> Let's say initially we have components such as <code>Button</code> and <code>Image</code> that may use a common functionality <em>to draw</em> on the screen. It's possible that someday programmers want to introduce one more component named <code>SelectBox</code>. So, what we'll end up with are different types of structures that wants to use a common functionality.</p>
</li>
<li>
<p><em>Solution:</em> We can invent a common function named <code>draw()</code>, which will have different implementations for different types of components.</p>
</li>
<li>
<p><em>How to build:</em> We'll initialise a <code>trait</code> that can be shared among various components and a <code>struct</code> that can hold these compoenents.</p>
</li>
<li>
<p>The <code>trait</code> will look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A common functionality shared between multiple components
pub trait Draw {
    fn draw(&amp;self);
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>We can build a <code>struct</code> that holds the components that implements the <code>Draw</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Screen {
    // Box will allow to store the components on heap
    // dyn keyword will add the ability to detect a type that implements Draw on runtime
    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}

impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>The difference with the alternative implementation using trait bounds in <code>struct</code> is that it restricts us to a <code>Screen</code> instance that has a list of components all of type <code>Button</code> or all of type <code>TextField</code>. At compile time, the definitions will be monomorphized.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
where
    T: Draw,
{
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Programmers can now create new components like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use gui::Draw;

pub struct Button {
    // Some fields
}

impl Draw for Button {
    fn draw(&amp;self) {
        // code to actually draw something
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Users of this library can now use it like this:</p>
<pre><pre class="playground"><code class="language-rust">use gui::{Button, Screen};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from(&quot;Yes&quot;),
                    String::from(&quot;Maybe&quot;),
                    String::from(&quot;No&quot;),
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from(&quot;OK&quot;),
            }),
        ],
    };

    screen.run();
}</code></pre></pre>
</li>
<li>
<p>This concept is similar to the concept like <em>duck typing</em>: if it walks like a duck and quacks like a duck, then it must be a duck!</p>
</li>
<li>
<p>Use Cases:</p>
<ul>
<li>Generics with trait bounds: If you’ll only ever have homogeneous collections. For Example, all elements of vector will be of type <code>Button</code>.</li>
<li><code>Box&lt;dyn T&gt;</code>: You can use heterogeneous collections. For Example, elements can be a mix of <code>Button</code>, <code>TextField</code> etc.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Static Dispatch vs Dynamic Dispatch:</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Static Dispatch</th><th>Dynamic Dispatch</th></tr></thead><tbody>
<tr><td>Concrete types are decided at compile time.</td><td>The compiler emits code that at runtime will figure out which method to call.</td></tr>
<tr><td>Compiler writes some new code for various concrete types.</td><td>At runtime, it is decided whether a selected type can follow the requirements.</td></tr>
<tr><td>When we use trait bounds on generics, static dispatch happens.</td><td>When we want to perform dynamic dispatch, we can use the <code>dyn</code> keyword.</td></tr>
<tr><td>No runtime cost is added.</td><td>Some runtime cost is added.</td></tr>
</tbody></table>
</div>
<h4 id="the-state-pattern"><a class="header" href="#the-state-pattern">The State Pattern</a></h4>
<ul>
<li>
<p>The <em>state pattern</em> is an object-oriented design pattern.</p>
</li>
<li>
<p>The current state is stored inside the struct, along with it's value(s).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Post {
    // Box and dyn are used because the state variable
    // will have different states during the life of Post
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>There are <em>state objects</em>, you can create a new object by implementing this trait.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait State {
    // The first two functions, results in transitions to different states.
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    // This function, can be called on any state object,
    // similar to the above two functions, except instead
    // of causing a state transition, it will return value
    // as if we conditionally returned output for each state
    fn content&lt;'a&gt;(&amp;self, _post: &amp;'a Post) -&gt; &amp;'a str {
        &quot;&quot;
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>
<p>The state pattern is built such that, methods defined on <em>state objects</em> will cause changes in the <code>Post</code>, but the methods defined on <code>Post</code> will have no idea what these changes will look like. Hence, <em>state objects</em> will encapsulate behaviour changes from the main <em>struct</em>.</p>
</li>
<li>
<p>You can look at it's complete implementation over <a href="https://gist.github.com/utkarshg6/642859eef3d79fde55eeafb6cb4ed520">here</a>.</p>
</li>
<li>
<p>Some downsides of State Pattern:</p>
<ul>
<li>Extra Modifications: If we add a new state, we'll need to modify other states too. It's due to the reason that one state can only make transitions to another state.</li>
<li>Code Duplication: It leads us to write common code inside state objects, as we cannot write directly in trait's default implementation because traits don't know about the concrete type.</li>
</ul>
</li>
<li>
<p>There's another implementation of state pattern in Rust. It doesn't follow the classic OOP pattern, as we'll require to store the object in new variable, whenever a state transition will happen. Here's the <a href="https://gist.github.com/utkarshg6/507560be53345b20aca8304f477fa0b0">code</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This will cause a state transition from PendingReview to Published
let post = post.approve();
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-concepts"><a class="header" href="#advanced-concepts">Advanced Concepts</a></h1>
<ul>
<li>You'll learn about macros, it is a form of code that writes more code. We'll talk about unsafe rust which is a form of rust which gives you superpowers by removing the rust safety checks. You'll also learn some other advanced forms of traits, types and pattern matching.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pattern-matching-1"><a class="header" href="#pattern-matching-1">Pattern Matching</a></h2>
<ul>
<li>
<p><code>match</code> Arms</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Conditional <code>if let</code> statements</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = &quot;34&quot;.parse();

    if let Some(color) = favorite_color {
        println!(&quot;Using your favorite color, {}, as the background&quot;, color);
    } else if is_tuesday {
        println!(&quot;Tuesday is green day!&quot;);
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!(&quot;Using purple as the background color&quot;);
        } else {
            println!(&quot;Using orange as the background color&quot;);
        }
    } else {
        println!(&quot;Using blue as the background color&quot;);
    }
}</code></pre></pre>
</li>
<li>
<p><code>while let</code> loops</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut stack = Vec::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    while let Some(top) = stack.pop() {
        println!(&quot;{}&quot;, top);
    }
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><code>for</code> loops</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!(&quot;{} is at index {}&quot;, value, index);
    }
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><code>let</code> statements</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let (x, y, z) = (1, 2, 3);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>function parameters</p>
<pre><pre class="playground"><code class="language-rust">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!(&quot;Current location: ({}, {})&quot;, x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}</code></pre></pre>
</li>
</ul>
<h4 id="forms-of-pattern"><a class="header" href="#forms-of-pattern">Forms of Pattern</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Refutable</th><th>Irrefutable</th></tr></thead><tbody>
<tr><td>Patterns that can fail to match for some possible value.</td><td>Patterns that'll match for any possible value.</td></tr>
<tr><td>For Example, in <code>if let Some(x) = a_value</code>, the <code>Some(x)</code> can fail to match if <code>a_value</code> is <code>None</code>.</td><td>For Example, in <code>let x = 5;</code>, the <code>x</code> matches anything and therefore cannot fail to match.</td></tr>
<tr><td>The <code>if let</code> and <code>while let</code> expressions accept refutable and irrefutable patterns, but the compiler warns against irrefutable patterns.</td><td>Function parameters, <code>let</code> statements, and <code>for</code> loops can only accept irrefutable patterns, because the program cannot do anything meaningful when values don’t match.</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>Using a refutable pattern where Rust requires an irrefutable pattern:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// FAIL: The code doesn't know what to do with a None value
// Some(x) is a refutable pattern
// let requires an irrefutable pattern
let Some(x) = some_option_value;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Using irrefutable pattern where Rust requires a refutable pattern:</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WARN: It doesn’t make sense to use if let with an irrefutable pattern
// x is an irrefutable pattern
// if let is a refutable pattern
if let x = 5 {
    println!(&quot;{}&quot;, x);
};
<span class="boring">}</span></code></pre></pre>
<ul>
<li>In <code>match</code> statements, all arms use refutable pattern except the last one that uses <code>_</code>, which uses irrefutable pattern.</li>
</ul>
<h4 id="pattern-syntax"><a class="header" href="#pattern-syntax">Pattern Syntax</a></h4>
<h5 id="inside-the-match-expression"><a class="header" href="#inside-the-match-expression">Inside the <code>match</code> expression</a></h5>
<ul>
<li>
<p>Each <code>match</code> expression creates a new scope, hence varaibles defined in scope will shadow the variables defined outside.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(y) =&gt; println!(&quot;Matched, y = {:?}&quot;, y), // This y will shadow the y defined outside of this scope
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);

    // Output =&gt;
    // Matched, y = 5
    // at the end: x = Some(5), y = 10
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>It's possible to use the &quot;or&quot; using the <code>|</code> syntax</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!(&quot;one or two&quot;),
        3 =&gt; println!(&quot;three&quot;),
        _ =&gt; println!(&quot;anything&quot;),
    }

    // Output =&gt;
    // one or two
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>You may also specify ranges in the arm, only numbers and <code>char</code> values are allowed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!(&quot;one through five&quot;),
        _ =&gt; println!(&quot;something else&quot;),
    }

    let y = 'c';

    match y {
        'a'..='j' =&gt; println!(&quot;early ASCII letter&quot;),
        'k'..='z' =&gt; println!(&quot;late ASCII letter&quot;),
        _ =&gt; println!(&quot;something else&quot;),
    }

    // Output =&gt;
    // one through five
    // early ASCII letter
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h5 id="destructuring"><a class="header" href="#destructuring">Destructuring</a></h5>
<ul>
<li>
<p>Destructuring structs</p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    // It's possible to destructure a struct into variables
    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);

    // A shorthand, will directly store respective values in x and y
    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}</code></pre></pre>
</li>
<li>
<p>Destructring as well as matching the structs</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;On the x axis at {}&quot;, x),
        Point { x: 0, y } =&gt; println!(&quot;On the y axis at {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;On neither axis: ({}, {})&quot;, x, y),
    }
}</code></pre></pre>
</li>
<li>
<p>Destructuring enums</p>
<pre><pre class="playground"><code class="language-rust">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::Quit =&gt; {
            println!(&quot;The Quit variant has no data to destructure.&quot;)
        }
        Message::Move { x, y } =&gt; {
            println!(
                &quot;Move in the x direction {} and in the y direction {}&quot;,
                x, y
            );
        }
        Message::Write(text) =&gt; println!(&quot;Text message: {}&quot;, text),
        Message::ChangeColor(r, g, b) =&gt; println!(
            &quot;Change the color to red {}, green {}, and blue {}&quot;,
            r, g, b
        ),
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; println!(
            &quot;Change the color to red {}, green {}, and blue {}&quot;,
            r, g, b
        ),
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; println!(
            &quot;Change the color to hue {}, saturation {}, and value {}&quot;,
            h, s, v
        ),
    }
}</code></pre></pre>
</li>
<li>
<p>We can mix, match, and nest destructuring patterns in even more complex ways</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h5 id="ignoring-values"><a class="header" href="#ignoring-values">Ignoring Values</a></h5>
<ul>
<li>
<p>You may use <code>_</code> or <code>..</code> to ignore values:</p>
<ul>
<li><code>_</code> : It is used when you want to ignore a warning of unused variable, inside match expression for the remaining values or using a name that starts with underscore.</li>
<li><code>..</code> : Ignore remaining parts of the value.</li>
</ul>
</li>
<li>
<p>You may use <code>_</code> for ignoring an unused variable</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}</code></pre></pre>
</li>
<li>
<p>It's possible to use <code>_</code> in functions</p>
<pre><pre class="playground"><code class="language-rust">fn foo(_: i32, y: i32) {
    println!(&quot;This code only uses the y parameter: {}&quot;, y);
}

fn main() {
    foo(3, 4);
}</code></pre></pre>
</li>
<li>
<p>There is a subtle difference between using only <code>_</code> and using a name that starts with an underscore.</p>
<ul>
<li>
<p>The syntax <code>_x</code> still binds the value to the variable.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// FAIL: s lost it's ownership to _s, but was attempted to use again for printing
let s = Some(String::from(&quot;Hello!&quot;));

// _s binds the value, the value of s is moved
if let Some(_s) = s {
    println!(&quot;found a string&quot;);
}

println!(&quot;{:?}&quot;, s);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Whereas <code>_</code> doesn’t bind at all.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;Hello!&quot;));

    // _ never binds the value, hence s stays the owner
    if let Some(_) = s {
        println!(&quot;found a string&quot;);
    }

    println!(&quot;{:?}&quot;, s);
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
</li>
</ul>
<p>Note: Ignoring a function parameter can be especially useful in some cases, for example, when implementing a trait when you need a certain type signature but the function body in your implementation doesn’t need one of the parameters. The compiler will then not warn about unused function parameters, as it would if you used a name instead.</p>
<ul>
<li>
<p>Ignoring remaining parts of <code>struct</code> with <code>..</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    // It prevents using _ multiple times
    Point { x, .. } =&gt; println!(&quot;x is {}&quot;, x),
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Skipping middle values using <code>..</code></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!(&quot;Some numbers: {}, {}&quot;, first, last);
        }
    }
}</code></pre></pre>
</li>
<li>
<p>You can only use <code>..</code> once per tuple</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!(&quot;Some numbers: {}&quot;, second)
        },
    }
}</code></pre></pre>
</li>
</ul>
<h5 id="match-guard"><a class="header" href="#match-guard">Match Guard</a></h5>
<ul>
<li>
<p><em>Match Guard</em> is an additional <code>if</code> condition specified after the pattern in a match arm that must also match along with the pattern matching, <em>for that arm to be chosen</em>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 =&gt; println!(&quot;The number {} is even&quot;, x),
        Some(x) =&gt; println!(&quot;The number {} is odd&quot;, x),
        None =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>The downside of this additional expressiveness is that the compiler doesn't try to check for exhaustiveness when match guard expressions are involved.</p>
</li>
<li>
<p>Using Match Guard with <code>|</code> operator</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        // It works like this =&gt; (4 | 5 | 6) if y =&gt; ...
        // And not like this =&gt; 4 | 5 | (6 if y) =&gt; ...
        4 | 5 | 6 if y =&gt; println!(&quot;yes&quot;),
        _ =&gt; println!(&quot;no&quot;),
    }

    // Output =&gt;
    // no
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><code>@</code> Bindings</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The at operator (@) lets us create a variable that holds a value at the same time
// we’re testing that value to see whether it matches a pattern.

enum Message {
    Hello { id: i32 },
}

let msg = Message::Hello { id: 5 };

match msg {
    Message::Hello {
        id: id_variable @ 3..=7,
    } =&gt; println!(&quot;Found an id in range: {}&quot;, id_variable), // Value of &quot;id&quot; is stored in &quot;id_variable&quot;, hence it was knwon here
    Message::Hello { id: 10..=12 } =&gt; {
        println!(&quot;Found an id in another range&quot;) // Range was specified, Value of &quot;id&quot; is not stored inside any variable, hence it is unknown here
    }
    Message::Hello { id } =&gt; println!(&quot;Found some other id: {}&quot;, id), // Range was not specified, Value of &quot;id&quot; is stored inside &quot;id&quot;, hence it was known here
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="unsafe-rust"><a class="header" href="#unsafe-rust">Unsafe Rust</a></h3>
<p><em>Rust has a second language hidden inside it that doesn’t enforce the memory safety guarantees: it’s called <strong>unsafe Rust</strong> and works just like regular Rust, but gives us extra superpowers.</em></p>
<ul>
<li>
<p>Why it exists?</p>
<ul>
<li>It’s better for Rust to reject some valid programs rather than accept some invalid programs.</li>
<li>That makes the static analysis of the Rust compiler conservative.</li>
<li>Although the code might be okay, if the Rust compiler doesn’t have enough information to be confident, it will reject the code.</li>
<li>In these cases, you can use unsafe code to tell the compiler, “Trust me, I know what I’m doing.”</li>
<li>Another reason Rust has an unsafe alter ego is that the underlying computer hardware is inherently unsafe. Hence, it'll allow you to write low-level systems code, such as directly interacting with the OS, or even write your own OS.</li>
</ul>
</li>
<li>
<p>Any Downsides?</p>
<ul>
<li>Use it at your own risk.</li>
<li>Problems due to memory unsafety, such as null pointer dereferencing, can occur.</li>
</ul>
</li>
<li>
<p>Answers to some common misconceptions:</p>
<ul>
<li>It’s important to understand that <code>unsafe</code> doesn’t turn off the borrow checker or disable any other of Rust’s safety checks: if you use a reference in unsafe code, it will still be checked.</li>
<li>Hence, you'll get only the above mentioned features along with some safety.</li>
<li>Also, it does not necessarily mean that code inside <code>unsafe</code> is necessarily dangerous or that it will definitely have memory safety problems.</li>
<li>It is programmer's responsibilty to ensure that the code is memory safe.</li>
</ul>
</li>
<li>
<p>How to write code safely using <code>unsafe</code>?</p>
<ul>
<li>Keep unsafe blocks small and it'll be easier to investigate the memory bugs.</li>
<li>You can also wrap unsafe code in a safe abstraction. It prevents the uses of unsafe from leaking out in all the other places.</li>
</ul>
</li>
<li>
<p>What Superpowers can I get?</p>
<ul>
<li>Dereference a raw pointer</li>
<li>Call an unsafe function or method</li>
<li>Access or modify a mutable static variable</li>
<li>Implement an unsafe trait</li>
<li>Access fields of <code>union</code>s</li>
</ul>
</li>
</ul>
<h4 id="dereferencing-a-raw-pointer"><a class="header" href="#dereferencing-a-raw-pointer">Dereferencing a Raw Pointer</a></h4>
<ul>
<li>
<p>Raw Pointers are meant for unsafe rust and are similar to references. They are of two types:</p>
<ul>
<li><code>*const T</code>: Immutable Raw Pointer</li>
<li><code>*mut T</code>: Mutable Raw Pointer</li>
</ul>
</li>
<li>
<p>Here <code>*</code> is not a dereference operator but a part of the type name.</p>
</li>
<li>
<p>Unlike references and Smart Pointers, they break the following rules of Rust's safety:</p>
<ul>
<li>They are allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location</li>
<li>Aren’t guaranteed to point to valid memory</li>
<li>Are allowed to be null</li>
<li>Don’t implement any automatic cleanup</li>
</ul>
</li>
<li>
<p>This is how you can create raw pointers out of a variable.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut num = 5;

let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>We can create raw pointers in safe code; we just can’t dereference raw pointers outside an unsafe block.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut num = 5;

// Notice it's possible to create raw pointers inside safe code
let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;

// But to dereference a raw pointer you'll require an unsafe block
unsafe {
    println!(&quot;r1 is: {}&quot;, *r1);
    println!(&quot;r2 is: {}&quot;, *r2);
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>We broke the Rust's safety measures, as we are able to use a mutable and immutable reference to a value. Now, as a programmer we made sure that these references are used properly inside the <code>unsafe</code> block.</p>
</li>
<li>
<p>Uses of creating raw pointers:</p>
<ul>
<li>Mostly used when interfacing with C code.</li>
<li>Calling an Unsafe Function or Method.</li>
<li>Building safe abstractions over unsafe code.</li>
</ul>
</li>
</ul>
<h4 id="call-an-unsafe-function-or-method"><a class="header" href="#call-an-unsafe-function-or-method">Call an unsafe function or method</a></h4>
<ul>
<li>
<p>Defining an unsafe function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn dangerous() {}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Calling an unsafe function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// By calling an unsafe function within an unsafe block,
// we’re saying that we’ve read this function’s documentation
// and take responsibility for upholding the function’s contracts.
unsafe {
    dangerous();
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h5 id="wrappping-unsafe-code-in-safe-abstractions"><a class="header" href="#wrappping-unsafe-code-in-safe-abstractions">Wrappping unsafe code in safe abstractions</a></h5>
<ul>
<li>
<p>We want to create a function that can split a vector into two by index</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// FAIL: Rust won't allow us to have two immutable borrow of the same vector
// Only we know that the two immutable borrow aren't overlapping and won't
// cause any trouble so we would like to silent the compiler by using unsafe
fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();

    assert!(mid &lt;= len);

    (&amp;mut slice[..mid], &amp;mut slice[mid..])
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Here is it's implementation using unsafe</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::slice;

// Notice the function isn't using unsafe in it's signature, hence unsafe is
// wrapped in a safe abstraction
fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr(); // Raw pointer

    assert!(mid &lt;= len);

    // This is an acceptable use of unsafe
    // We need unsafe block to call these functions because
    // we're slicing and adding to the raw pointers, which may
    // have a chance to become invalid, iff programmer hasn't
    // written in properly
    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid), // It will give the slice of range [ptr, ptr + mid)
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>If you want to create a raw pointer with unexpected behaviour, you can do this</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// FAIL: It won't point to a valid i32 value
use std::slice;

let address = 0x01234usize;
let r = address as *mut i32;

let slice: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h5 id="call-the-code-from-other-languages-using-extern"><a class="header" href="#call-the-code-from-other-languages-using-extern">Call the code from other languages using <code>extern</code></a></h5>
<ul>
<li>
<p>Rust uses <code>extern</code> keyword to use <em>Foreign Function Interface (FFI)</em>, it is a way for a programming language to define functions and enable a different (foreign) programming language to call those functions.</p>
</li>
<li>
<p>Functions declared within extern blocks <strong>are always unsafe to call</strong> from Rust code.</p>
</li>
<li>
<p>This is how you can call <code>C</code> code in Rust:</p>
<pre><pre class="playground"><code class="language-rust">// After extern you need to specify ABI (Application Binary Interface)
// Here we are using extern to use ABI of other languages
extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));
    }
}</code></pre></pre>
</li>
<li>
<p>It is possible to write Rust code such that other languages can call.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This code is not unsafe
#[no_mangle] // This doesn't allows the compiler to rename the functions name
pub extern &quot;C&quot; fn call_from_c() {   // Here we are using extern to create an ABI for other languages
    println!(&quot;Just called a Rust function from C!&quot;);
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h4 id="accessing-or-modifying-a-mutable-static-variable"><a class="header" href="#accessing-or-modifying-a-mutable-static-variable">Accessing or Modifying a Mutable Static Variable</a></h4>
<ul>
<li>
<p>In Rust, <strong>global</strong> variables are called <em>static variables</em>.</p>
</li>
<li>
<p>It is problematic as it may cause a data race if two threads are accessing the same mutable global variable.</p>
</li>
<li>
<p>This is how you can create a global or static variable.</p>
<pre><pre class="playground"><code class="language-rust">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;name is: {}&quot;, HELLO_WORLD);
}</code></pre></pre>
</li>
<li>
<p>The references for static variable is <code>'static</code> by default. So, we need to specify it's lifetime anywhere.</p>
</li>
<li>
<p>Also, it's completely safe to access an immutable static variable.</p>
</li>
</ul>
<h5 id="constants-and-static-variable"><a class="header" href="#constants-and-static-variable">Constants and Static Variable</a></h5>
<div class="table-wrapper"><table><thead><tr><th>Constants</th><th>Static Variable</th></tr></thead><tbody>
<tr><td>Dynamic address in memory</td><td>Fixed address in memory</td></tr>
<tr><td>Constants duplicate their data whenever used.</td><td>Using the value will always access the same data.</td></tr>
<tr><td>Constants are never mutable.</td><td>Static variable can be both mutable and immutable, and for modifying mutable static variable, you'll need to use <code>unsafe</code>.</td></tr>
</tbody></table>
</div>
<h5 id="implementing-static-variables"><a class="header" href="#implementing-static-variables">Implementing Static Variables</a></h5>
<ul>
<li>
<p>This is how you can implement static variables.</p>
<pre><pre class="playground"><code class="language-rust">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!(&quot;COUNTER: {}&quot;, COUNTER);
    }
}</code></pre></pre>
</li>
<li>
<p>Notice that, it's not causing us any trouble because this code is single threaded, but if we tried to mutate the static variable in multiple threads it could lead to data races.</p>
</li>
<li>
<p>Static Variables (<em>or Global Variables</em>) are unsafe. That's because it's difficult to ensure that there are no data races for a global variable.</p>
</li>
<li>
<p>It’s preferable to use the concurrency techniques and thread-safe smart pointers.</p>
</li>
</ul>
<h4 id="implementing-an-unsafe-trait"><a class="header" href="#implementing-an-unsafe-trait">Implementing an unsafe trait</a></h4>
<ul>
<li>
<p>A trait is unsafe when at least <em>one of its methods</em> has some invariant that the compiler can’t verify.</p>
</li>
<li>
<p>Here's an implementation:</p>
<pre><pre class="playground"><code class="language-rust">unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}

fn main() {}</code></pre></pre>
</li>
<li>
<p>If we implement a type that contains a type that is not <code>Send</code> or <code>Sync</code> (i.e. doesn't already implements the safe ways of sending a type in multiple threads), such as <em>raw pointers</em>, and we want to mark that type as <code>Send</code> or <code>Sync</code>, we must use unsafe.</p>
</li>
</ul>
<h4 id="accessing-fields-of-a-union"><a class="header" href="#accessing-fields-of-a-union">Accessing Fields of a Union</a></h4>
<ul>
<li>A <code>union</code> is similar to a <code>struct</code>, but only one declared field is used in a particular instance at one time.</li>
<li>Unions are primarily used to interface with unions in C code.</li>
<li>Accessing union fields is unsafe because Rust can’t guarantee the type of the data currently being stored in the union instance.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="advanced-traits"><a class="header" href="#advanced-traits">Advanced Traits</a></h3>
<h4 id="associated-types"><a class="header" href="#associated-types">Associated Types</a></h4>
<ul>
<li>
<p>This is how you can create an associate type inside a trait</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item; // You see, this is the associated type

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;; // Now, this trait can use this type in it's signatures
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Here's an implementation of this trait on one of our types Counter:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --snip--
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Now, you might be wondering, can't we do something like this with using traits with generics?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Here are the differences between Associated Types and Traits with generics?</p>
<div class="table-wrapper"><table><thead><tr><th>Traits with Associated Types</th><th>Traits with Generics</th></tr></thead><tbody>
<tr><td>There will be only one implementation for a type.</td><td>There can be multiple implementations for a type, using individual concrete type.</td></tr>
<tr><td>For Example, <code>impl Iterator for Counter</code></td><td>For Example, <code>impl Iterator&lt;String&gt; for Counter</code>, and many more.</td></tr>
<tr><td>Using functions of these traits will not require you to provide type annotations.</td><td>You'll need to provide type annotations to provide which iteration to use.</td></tr>
</tbody></table>
</div></li>
</ul>
<h4 id="operator-overloading"><a class="header" href="#operator-overloading">Operator Overloading</a></h4>
<ul>
<li>
<p>This is how you can add two types by using the <code>+</code> operator</p>
<pre><pre class="playground"><code class="language-rust">// This library `std::ops` contains all the overloadable operators
use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point; // associated type will restrict the number of implementations

    fn add(self, other: Point) -&gt; Point { // This fn will decide how the `+` will behave for the type Point
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}</code></pre></pre>
</li>
<li>
<p>This is how the trait <code>Add</code> is defined in the Rust's library <code>std::ops</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This syntax `&lt;Rhs=Self&gt;` is called &quot;default parameters&quot;
// In case, someone implementing this trait doesn't define the type
// then the type defined in default parameter will be used everywhere in this trait
trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output; // The &quot;default parameter&quot; is used here inside argument `rhs`
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>You can also customize <code>Rhs</code>, that'll mean you'll be adding a value of different type to the main type</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters { // Modified Rhs to Meters, otherwise the default will be Self (or Millimeters)
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>You’ll use default type parameters in two main ways:</p>
<ul>
<li>To extend a type without breaking existing code</li>
<li>To allow customization in specific cases most users won’t need</li>
</ul>
</li>
</ul>
<h4 id="function-with-same-name-in-multiple-traits"><a class="header" href="#function-with-same-name-in-multiple-traits">Function with same name in multiple traits</a></h4>
<ul>
<li>
<p>Following things are allowed:</p>
<ul>
<li>Multiple traits to have functions with same name</li>
<li>A type implementing all these traits</li>
</ul>
</li>
<li>
<p>Here's an implementation:</p>
<pre><pre class="playground"><code class="language-rust">trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!(&quot;This is your captain speaking.&quot;);
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!(&quot;Up!&quot;);
    }
}

impl Human {
    fn fly(&amp;self) {
        println!(&quot;*waving arms furiously*&quot;);
    }
}

fn main() {
    let person = Human;
    Pilot::fly(&amp;person); // You'll have to pass the reference to the person, because it takes self as an argument
    Wizard::fly(&amp;person); // if we had two types that both implement one trait, this self would recognize the correct type
    person.fly(); // The direct implementation will get called first, instead you can also use Human::fly(&amp;person)
}</code></pre></pre>
</li>
<li>
<p>Let's see what happens if the <em>associated function</em> of a <em>struct</em> and a <em>trait</em> has same name</p>
<pre><pre class="playground"><code class="language-rust">trait Animal {
    // Notice, there is no self passed inside,
    // multiple types can implement this trait,
    // Calling this function won't be direct,
    // as the trait won't be able to infer
    // which type's implementation to call
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    // This is an associated function, which can be called
    // using `Dog::baby_name()`, just like any other
    // associated fn without self
    fn baby_name() -&gt; String {
        String::from(&quot;Spot&quot;)
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;puppy&quot;)
    }
}

fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Dog::baby_name()); // The direct implementation will get called
    println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name()); // Won't work, this associated fn don't has self, remember? It can't infer the type
    println!(&quot;A baby dog is called a {}&quot;, &lt;Dog as Animal&gt;::baby_name()); // We need to tell Rust that we want to use the implementation of Animal for Dog
}</code></pre></pre>
</li>
<li>
<p>This is the fully qualified syntax, used for all associated functions (including methods)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...); // You don't need to provide all the information that Rust can infer
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h4 id="supertraits"><a class="header" href="#supertraits">Supertraits</a></h4>
<ul>
<li>
<p>Sometimes, you might need one trait to use another trait’s functionality.</p>
</li>
<li>
<p>The traits you would be using to build your own trait is called <em>Supertrait</em>.</p>
</li>
<li>
<p>One important thing is that, now your trait can only be implemented on the types that already implements the Supertrait.</p>
</li>
<li>
<p>Here's an implementation. This <code>OutlinePrint</code> can <strong>only</strong> be implemented on any trait that implements <code>Display</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

trait OutlinePrint: fmt::Display { // It is also like bounding a trait with another trait
    fn outline_print(&amp;self) {
        let output = self.to_string(); // It works only because all the types already implements `Display`
        let len = output.len();
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;* {} *&quot;, output);
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>For reference, you can also implement <code>fmt::Display</code> on your type, like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
}

use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Now, we know that <code>Point</code> implements <code>Display</code>, now we can implement <code>OutlinePrint</code> like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl OutlinePrint for Point {}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>The output will look like this for the fn <code>outline_print</code></p>
<pre><code class="language-zsh">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
</li>
</ul>
<h4 id="newtype-pattern"><a class="header" href="#newtype-pattern">Newtype Pattern</a></h4>
<p><em>The <strong>Orphan Rule</strong> states that we’re allowed to implement a trait on a type as long as either the trait or the type are local to our crate.</em></p>
<ul>
<li>
<p>The <em>newtype pattern</em> , helps us to get around this restriction.</p>
</li>
<li>
<p>All we need to do is to create a new type in a tuple struct.</p>
</li>
<li>
<p>Let's say, we want to implement <code>Display</code> on <code>Vec&lt;T&gt;</code>. Both of them are not local to our code, thereby orphan rule will prevent us from implementing it.</p>
</li>
<li>
<p>Now, we can use this newtype pattern for getting a workaround. What we'll be building is a wrapper that will make the <code>Vec&lt;T&gt;</code> local to us.</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Wrapper(Vec&lt;String&gt;); // A new struct, which is just a wrapper for Vec&lt;String&gt;

impl fmt::Display for Wrapper { // Now, we can implement Display on Wrapper, but we can't do directly on Vec&lt;T&gt;
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;)) // self.0 is used to take the Vector out
    }
}

fn main() {
    // The only disadvantage is that, we'll need to create
    // a vector inside a wrapper to use the Display trait
    let w = Wrapper(vec![String::from(&quot;hello&quot;), String::from(&quot;world&quot;)]);
    println!(&quot;w = {}&quot;, w);
}</code></pre></pre>
</li>
<li>
<p>If we wanted the new type to have every method the inner type has, <a href="https://doc.rust-lang.org/book/ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait">implementing the Deref trait</a> on the Wrapper to return the inner type would be a solution.</p>
</li>
<li>
<p>If we don’t want the Wrapper type to have all the methods of the inner type — for example, to restrict the Wrapper type’s behavior — we would have to implement just the methods we do want manually.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="advanced-types"><a class="header" href="#advanced-types">Advanced Types</a></h3>
<h4 id="uses-of-the-newtype-pattern"><a class="header" href="#uses-of-the-newtype-pattern">Uses of the Newtype Pattern</a></h4>
<ul>
<li><em>Type Safety</em>: We can wrap <code>u32</code> values with structs <code>Millimeters</code> and <code>Meters</code>. Now, if a value is stored in <code>Millimeters</code>, it is safe to say that this value can't call functions defined for <code>Meters</code>, and vice versa is true.</li>
<li><em>Abstraction</em>: We could provide a <code>People</code> type to wrap a <code>HashMap&lt;i32, String&gt;</code> that stores a person’s ID associated with their name. Code using <code>People</code> would only interact with the public API we provide, such as a method to add a name string to the People collection; that code <strong>wouldn’t need to know</strong> that we assign an <code>i32</code> ID to names internally.</li>
</ul>
<h4 id="type-aliases"><a class="header" href="#type-aliases">Type Aliases</a></h4>
<ul>
<li>
<p>This is how you can create a type alias:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Kilometers = i32;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>How it works?</p>
<ul>
<li>Values with type <code>Kilometers</code> will be treated same as <code>i32</code>.</li>
<li>We aren't creating a new type, we're just adding a <em>synonym</em> to <code>i32</code>, called <code>Kilometers</code></li>
</ul>
</li>
<li>
<p>Hence, doing something like this is totally fine:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i32 = 5;
let y: Kilometers = 5;

println!(&quot;x + y = {}&quot;, x + y); // This will work
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>The advantage is that it will give us the flexibility that any function with an argument of <code>i32</code>, we can pass <code>Kilometers</code> value to it.</p>
</li>
<li>
<p>The disadvantage is that we don't get the type checks as we get in the newtype pattern.</p>
</li>
<li>
<p>You can create an alias where you want to prevent naming a complex type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;; // A type that stores closure

let f: Thunk = Box::new(|| println!(&quot;hi&quot;)); // We don't need to specify the longer type, instead we can say just &quot;Thunk&quot;

fn takes_long_type(f: Thunk) { // Again, we don't need to specify the longer type, just &quot;Thunk&quot;
  ...
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>Fun Fact: Thunk is a word for code to be evaluated at a later time, so it’s an appropriate name for a closure that gets stored</p>
<ul>
<li>
<p>We can also shorten a <code>Result</code> values of I/O operations like this</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Now, <code>Result&lt;usize, Error&gt;</code> can be replaced with <code>Result&lt;usize&gt;</code> and <code>Result&lt;(), Error&gt;</code> can be replaced with <code>Result&lt;()&gt;</code>. Also, we can use the <code>?</code> operator, since it's the same type.</p>
</li>
</ul>
<h4 id="the-never-type-"><a class="header" href="#the-never-type-">The never type <code>!</code></a></h4>
<ul>
<li>
<p>This type never returns. In type theory lingo it is known as the <em>empty type</em> because it has no values.</p>
</li>
<li>
<p>Rust prefers to call it the never type because it stands in the place of the return type when a function will never return.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// People read it as, &quot;the function bar(), returns never&quot;, and are called diverging functions
fn bar() -&gt; ! {
    // --snip--
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Rust never allows a variable to have different possible data types.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// FAIL: You can't create a variable &quot;guess&quot;, that may have either number or string
let guess = match guess.trim().parse() {
    Ok(_) =&gt; 5,
    Err(_) =&gt; &quot;hello&quot;,
};
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>But this is possible:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue, // Wait a minute, how's this even allowed?
};
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>The <code>continue</code> has a never type (<code>!</code>), which means it'll never return any value. That is, when Rust computes the type of <code>guess</code>, it looks at both match arms, the former with a value of <code>u32</code> and the latter with a <code>!</code> value. Because <code>!</code> can never have a value, Rust decides that the type of guess is <code>u32</code>.</p>
</li>
<li>
<p>You can remember it this way, the <code>!</code> can get coerced to any other type.</p>
</li>
<li>
<p>This is the original implementation of <code>unwrap!()</code>. Here, the return type is coerced to a single type <code>T</code>, and that's because <code>panic!()</code> ends the program and has a never type (<code>!</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>The value of the expression of <code>loop</code> is also of the type <code>!</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print!(&quot;forever &quot;);

loop {
    print!(&quot;and ever &quot;);
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h4 id="dynamically-sized-traits-and-the-sized-trait"><a class="header" href="#dynamically-sized-traits-and-the-sized-trait">Dynamically Sized Traits and the <code>Sized</code> trait</a></h4>
<ul>
<li>
<p><em>DSTs</em> or <em>unsized</em> types let us write code using values whose size can only be known at runtime.</p>
</li>
<li>
<p>So, Rust doesn't let us create strings with <code>str</code> (not <code>&amp;str</code>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1: str = &quot;Hello there!&quot;;
let s2: str = &quot;How's it going?&quot;;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Why's that?</p>
<ul>
<li>Rust needs to know a fixed size of a type. Here <code>s1</code> takes 12 bytes and <code>s2</code> takes <code>15</code> bytes.</li>
<li>It's not possible to accomodate all the strings in a single fixed size.</li>
</ul>
</li>
<li>
<p>What's the solution?</p>
<ul>
<li><code>&amp;str</code> is the solution.</li>
<li>It stores two values: the address of the <code>str</code> and its length.</li>
<li>So, that makes <code>&amp;str</code> will only need two <code>usize</code>, one for the address and the other for the length.</li>
<li>That's why, we always know the size of a <code>&amp;str</code>, no matter how long the string it refers to is.</li>
</ul>
</li>
<li>
<p>In general, this is the way in which dynamically sized types are used in Rust.</p>
</li>
<li>
<p>The golden rule of dynamically sized types is that we must always put values of dynamically sized types behind a pointer of some kind.</p>
</li>
<li>
<p>The traits can be Dynamically Sixed too. All we need to do is to put them behind a pointer, such as <code>&amp;dyn Trait</code> or <code>Box&lt;dyn Trait&gt;</code>.</p>
</li>
<li>
<p>The <code>Sized</code> trait</p>
<ul>
<li>
<p>A trait that determines whether or not a type's size is known at compile time.</p>
</li>
<li>
<p>You may create a generic function like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generic&lt;T&gt;(t: T) {
    // --snip--
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>But, Rust treats it as if it was re-written like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This means generic functions will only work on
// types who's size is known at the compile time
fn generic&lt;T: Sized&gt;(t: T) {
    // --snip--
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>It's possible to get over with this restriction:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The ?Sized means “T may or may not be Sized”
// Now, this fn will accept T whose size may or may not be known at compile time
// The ?Trait syntax with this meaning is only available for Sized, not any other traits.
// Also, notice, we're using `&amp;T` and not `T`, now we'll use `T` behind some kind of pointer, here it's reference
fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --snip--
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="advanced-functions-and-closures"><a class="header" href="#advanced-functions-and-closures">Advanced Functions and Closures</a></h2>
<h4 id="pass-functions-to-the-functions"><a class="header" href="#pass-functions-to-the-functions">Pass functions to the functions</a></h4>
<ul>
<li>
<p>Just like you can pass closures to the functions, you can also pass &quot;funtions to the functions&quot;.</p>
</li>
<li>
<p>There's a type represented by <code>fn</code>, (don't confuse it with <code>Fn</code>, that is a closure trait).</p>
</li>
<li>
<p>This <code>fn</code> type is called <em>Function Pointer</em>.</p>
</li>
<li>
<p>Here's how you can use it:</p>
<pre><pre class="playground"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
  x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
  f(arg) + f(arg)
}

fn main() {
  let answer = do_twice(add_one, 5);
  println!(&quot;Answer: {}&quot;, answer);
}</code></pre></pre>
</li>
<li>
<p>Function pointers implement all three of the closure traits (<code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code>), so you can always pass a function pointer as an argument for a function that expects a closure.</p>
</li>
<li>
<p>So, instead of passing a closure, you can simply enter a function name, and it will work.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// You can either do this
let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec&lt;String&gt; =
    list_of_numbers
    .iter()
    .map(|i| i.to_string()) // Provide the closure
    .collect();


// Or you can simply enter the function name
let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec&lt;String&gt; =
    list_of_numbers
    .iter()
    .map(ToString::to_string) // Enter the function name, wohoo!
    .collect();
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>You can use enum variants as an initializer function. Also, we now know we can pass a function inside a function, so here's what we can also do:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Status {
    Value(u32), // So, this works as an initializer function too
    Stop,
}

let list_of_statuses: Vec&lt;Status&gt; = (0u32..20).map(Status::Value).collect(); // This will create Status instances of the variant Value
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>You can do the same thing by using closures, it's more of a personal preference. You can use whichever feels more clearer to you.</p>
</li>
</ul>
<h4 id="return-closures"><a class="header" href="#return-closures">Return Closures</a></h4>
<ul>
<li>
<p>First of all, you can't return functions, that's not allowed in rust.</p>
</li>
<li>
<p>Technically, you are not alllowed to use <code>fn</code> (Funciion Pointer) as a return type, but you can return closures.</p>
</li>
<li>
<p>Closures are represented by traits.</p>
</li>
<li>
<p>To return a type that implements a trait, you can do either of the two:</p>
<ul>
<li>Return a concrete type</li>
<li>Use dynamic dispatch (it'll allow the function to know concrete type at runtime).</li>
</ul>
</li>
<li>
<p>Closures don't have the concrete type, you can't send them directly, you'll need to use dynamic dispatch.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// FAIL: This will also not work
fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {
    |x| x + 1
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Now, Rust needs one more thing, the size of the closure. Remember the <code>Sized</code> trait.</p>
</li>
<li>
<p>The solution to this problem, is to wrap the return type with some sort of pointer, in case of strings we use references. For example, using <code>&amp;str</code> instead of <code>str</code>.</p>
</li>
<li>
<p>Here, we'll use <code>Box&lt;T&gt;</code> to simply store it on the heap.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is how you can successfully return a closure
fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>In case you want to understand better how you can use traits with dynamic dispatch, you can check <a href="ch-06-advanced-concepts/pg-05-advanced-functions-and-closures.html#defining-a-common-behaviour-using-trait">here</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="macros"><a class="header" href="#macros">Macros</a></h2>
<ul>
<li>
<p>Rust code that writes more rust code are called <em>Macros</em>. This kind of programming is called metaprogramming.</p>
</li>
<li>
<p>Here are the following things that you can only do with macros and not functions:</p>
<ul>
<li>Macros can take variable number of parameters, unlike functions. You can call <code>println!(&quot;hello&quot;)</code> with one argument or <code>println!(&quot;hello {}&quot;, name)</code> with two arguments.</li>
<li>Macros are expanded before the compiler interprets the meaning of the code. For example, macros can implement a trait on a given type. Functions can't because it gets called at runtime and a trait needs to be implemented at compile time.</li>
</ul>
</li>
<li>
<p>Drawbacks of Macros:</p>
<ul>
<li>It's hard to read, write and maintain.</li>
<li>You can define functions anywhere, but you need to bring the macros in scope before you can call them.</li>
</ul>
</li>
</ul>
<h4 id="declarative-macros"><a class="header" href="#declarative-macros">Declarative Macros</a></h4>
<ul>
<li>They are the most widely used types of macros.</li>
<li>Also referred to as &quot;macros by example&quot;, “<code>macro_rules!</code> macros”, or just plain “macros”.</li>
<li>They are similar to <code>match</code> statements, except they match on literal rust code, instead of some value.</li>
<li>Here is a simple implementation of the <code>vec!</code> macro:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>
<p>Explanation:</p>
<ul>
<li><code>#[macro_export]</code> - You can't export the macro without this line. For using this macro, you'll have to bring the crate into scope where this macro is defined.</li>
<li><code>macro_rules! name-of-macro</code> - Then we declare the macro with the <code>macro_rules!</code> along with the name of the macro without the exclamation mark. In our case, <code>vec</code>.</li>
<li><code>( $( $x:expr ),* ) =&gt;</code> - This is the match arm of the macro. In our case, the macro has only one match arm, if such an expression is passed to the macro which doesn't fall into it, it'll fail. Some complex macros will have multiple match arms.
<ul>
<li><code>( ) =&gt;</code> - A parantheses surrounds the whole pattern. It indicates that this is a match arm.</li>
<li><code>$( )</code> - Anything inside this parantheses will capture values.</li>
<li><code>$x: expr</code> - This matches any Rust expression and gives the expression the name <code>$x</code>.</li>
<li><code>,</code> - It means that the literal <code>,</code> might appear after the code that matches the code in <code>$()</code>.</li>
<li><code>*</code> - It means that the pattern matches zero or more of whatever precedes the <code>*</code>.</li>
<li><code>$()*</code> - For every time the expression in <code>$()</code> gets matched, the code inside <code>$()*</code> will get called.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>In Action:</p>
<ul>
<li>
<p>So, when we'll write <code>vec![1, 2, 3]</code> it will get compiled into, the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
  let mut temp_vec = Vec::new();
  temp_vec.push(1);
  temp_vec.push(2);
  temp_vec.push(3);
  temp_vec
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
</li>
</ul>
<p>Note: This vector that we created over here can take any number of arguments of any type. The implementation of <code>vec!</code> macro in standard library only accepts data of one type and it also has some extra code for preallocating memory for those types.</p>
<h4 id="procedural-macros"><a class="header" href="#procedural-macros">Procedural Macros</a></h4>
<ul>
<li>
<p>They act more like functions and they are a type of procedure.</p>
</li>
<li>
<p>They don't match against a pattern.</p>
</li>
<li>
<p>They simply accept some code, operates on it and produces some new code.</p>
</li>
<li>
<p>There are three kinds of procedural macros:</p>
<ul>
<li>Custom Derive</li>
<li>Attribute Like</li>
<li>Function Like</li>
</ul>
</li>
</ul>
<h5 id="custom-derive-macros"><a class="header" href="#custom-derive-macros">Custom Derive Macros</a></h5>
<ul>
<li>
<p>Using custom derive macros looks like this (it is used over structs or enums):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(HelloMacro)]
struct Pancakes;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Defining proceudral macros looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use proc_macro;

#[some_attribute] // This attribute tells us which kind of procedural macro we are creating
pub fn some_name(input: TokenStream) -&gt; TokenStream { // TokenStream is a type imported from the crate `proc_macro`. It represents a sequence of tokens.
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>An Example of a <em>Custom Derive</em> macro:</p>
<ul>
<li>
<p>What we want? We want to print the name of the struct which tries to call the function <code>hello_macro()</code>.</p>
<pre><pre class="playground"><code class="language-rust">use hello_macro::HelloMacro; // A trait which has an associated function hello_macro()
use hello_macro_derive::HelloMacro; // A macro that we can use

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro(); // This will print &quot;Hello, Macro! My name is Pancakes!&quot;
}</code></pre></pre>
</li>
<li>
<p>Part 1: Defining Traits</p>
<ul>
<li>
<p>First of all define the trait in different crate, created using <code>cargo new hello_macro --lib</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: src/lib.rs
pub trait HelloMacro {
    fn hello_macro();
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Then implement the trait for every struct (without using macro, this is what it looks like):</p>
<pre><pre class="playground"><code class="language-rust">// File: src/main.rs
use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!(&quot;Hello, Macro! My name is Pancakes!&quot;); // Programmer will have to implement this fn for each struct.
    }
}

fn main() {
    Pancakes::hello_macro();
}</code></pre></pre>
</li>
<li>
<p>Additionally, we can’t yet provide the <code>hello_macro</code> function with default implementation that will print the name of the type the trait is implemented on: Rust doesn’t have reflection capabilities, so it can’t look up the type’s name at runtime.</p>
</li>
</ul>
</li>
<li>
<p>Part 2: Implementing Procedural Macros</p>
<ul>
<li>
<p>At the time of this writing, procedural macros need to be in their own crate. Eventually, this restriction might be lifted. So, first create a new crate using:</p>
<pre><code class="language-zsh">cargo new hello_macro_derive --lib
</code></pre>
</li>
<li>
<p>This trait will work in parallel with the trait defined above. Both the traits are tightly related. Hence we'll have to keep both the crates (<code>hello_macro</code> and <code>hello_macro_derive</code>) in one directory. In case someone wants to use the macro, they'll have to pull both the crates as dependencies.</p>
</li>
<li>
<p>So inside the <code>cargo.toml</code> file of the crate <code>hello_macro_derive</code>, add the following lines:</p>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = &quot;1.0&quot;
quote = &quot;1.0&quot;
</code></pre>
</li>
<li>
<p>Now, we can define the macro inside the <code>src/lib.rs</code> file of the crate <code>hello_macro_derive</code>. The code for most of the procedural macros will be same as the code block below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Filename: src/lib.rs
use proc_macro::TokenStream; // this crate, proc_macro comes with rust, it allows to read and manipulate rust code from our code
use quote::quote; // Transforms DeriveInput -&gt; Rust Code
use syn; // Transforms Rust Code -&gt; DeriveInput

#[proc_macro_derive(HelloMacro)] // This line makes sure that whenever a user specifies #[derive(HelloMacro)] on a type, it calls the below fn
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_hello_macro(&amp;ast)
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Once the line <code>let ast = syn::parse(input).unwrap();</code> is executed (let's say for the <code>struct Pancakes {};</code>), it creates a <code>DeriveInput</code> struct, which looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>DeriveInput {
    // --snip--

    ident: Ident {
        ident: &quot;Pancakes&quot;,
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
</li>
<li>
<p>Now, we can convert the <code>DeriveInput</code> into <code>TokenStream</code> using the function <code>impl_hello_macro(&amp;ast)</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let name = &amp;ast.ident; // type is not &amp;str but &amp;syn::Ident
    let gen = quote! { // it turns Rust syntax tree data structures into tokens of source code
        impl HelloMacro for #name {
            fn hello_macro() {
                println!(&quot;Hello, Macro! My name is {}!&quot;, stringify!(#name)); // quote! is used here to replace #name with the value in the variable name
            }
        }
    };

    gen.into() // quote! can't directly convert into TokenStream so we call into()
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>The <code>stringify!</code> macro used here is built into Rust. It takes a Rust expression, such as <code>1 + 2</code>, and at compile time turns the expression into a string literal, such as <code>&quot;1 + 2&quot;</code>. This is different than <code>format!</code> or <code>println!</code>, macros which evaluate the expression and then turn the result into a String.</p>
</li>
<li>
<p>Now, we can create a crate named <code>pancakes</code> and then use our macro inside of it.</p>
<pre><code class="language-zsh">cargo new pancakes
</code></pre>
</li>
<li>
<p>The file structure should be like this:</p>
<pre><code class="language-zsh">.
├── hello_macro
│   ├── hello_macro_derive
│   │   └── ..
│   └── ..
└── pancakes
    └── ..
</code></pre>
</li>
<li>
<p>Then migrate the code as explained in the starting of this example to <code>src/main.rs</code>, and also add these lines to the dependencies:</p>
<pre><code class="language-toml">hello_macro = { path = &quot;../hello_macro&quot; }
hello_macro_derive = { path = &quot;../hello_macro/hello_macro_derive&quot; }
</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="attribute-like-macros"><a class="header" href="#attribute-like-macros">Attribute Like Macros</a></h5>
<ul>
<li>
<p>In Custom Derive Macros, the <code>derive</code> keyword is used and it generates some new code for the struct or enum.</p>
</li>
<li>
<p>Instead of generating new code, Attribute like macros allow you to create new attributes.</p>
</li>
<li>
<p>Unlike Custom Derive Macros, Attribute like macros are not limited to just structs or enums and can be applied to other items, such as functions.</p>
</li>
<li>
<p>Here's an example of how it can be used on a function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[route(GET, &quot;/&quot;)]
fn index() {
  ..
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>This <code>#[route]</code> attribute would be defined by the framework as a procedural macro. The signature of the macro definition function would look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {
  // attr: The GET, &quot;/&quot; will get stored in this argument
  // item: The code attached to above macro (fn index() {} in our case) will get stored in this argument
  ..
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Other than that, attribute-like macros work the same way as custom derive macros: you create a crate with the <code>proc-macro</code> crate type and implement a function that generates the code you want!</p>
</li>
</ul>
<h5 id="function-like-macros"><a class="header" href="#function-like-macros">Function Like Macros</a></h5>
<ul>
<li>
<p>These macros look like function calls but with a <code>!</code>.</p>
</li>
<li>
<p>They're more flexible than functions as they can accept variable number of arguments.</p>
</li>
<li>
<p>In declarative macros (<code>macro_rules !</code> macro) uses match-like syntax, the Function Like Macros take a <code>TokenStream</code> parameter, similar to the other two procedural macros.</p>
</li>
<li>
<p>Here's an example, here we want to parse SQL code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sql = sql!(SELECT * FROM posts WHERE id=1);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>If we tried to build this macro with the <code>macro_rules !</code> macro, then match-like pattern would've made it hard to implement. With using <code>TokenStream</code> it is a bit easier to implement:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {
  ..
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>It's implementation is closer to that of custom derive macros.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h2>
<h4 id="raw-identifers"><a class="header" href="#raw-identifers">Raw Identifers</a></h4>
<ul>
<li>
<p>Identifiers are the names of the functions, variable, structs etc.</p>
</li>
<li>
<p>Keywords are the words reserved by Rust. For example, <code>if</code>, <code>else</code>, <code>match</code>.</p>
</li>
<li>
<p>You're not allowed to use keywords as identifiers, but there's a hack.</p>
</li>
<li>
<p>Raw identifiers are the syntax that lets you use keywords where they wouldn’t normally be allowed. You use a raw identifier by prefixing a keyword with <code>r#</code>.</p>
</li>
<li>
<p>Here's something that you're not allowed to do:</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// FAIL: match is a keyword, but is used as an identifier
fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>If there's a need to use a keyword as identifier, you may use raw identifiers:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match(&quot;foo&quot;, &quot;foobar&quot;));
}</code></pre></pre>
<ul>
<li>What's the use?
<ul>
<li>Let's say you're integrating some code written in other languages to your Rust project. Now, there are some functions written in other languages whose name are keywords in Rust. So, you may use raw identifiers to overcome Rust's restriction.</li>
<li><code>try</code> isn’t a keyword in the 2015 edition but is in the 2018 edition. If you depend on a library that’s written using the 2015 edition and has a <code>try</code> function, you’ll need to use the raw identifier syntax, <code>r#try</code> in this case, to call that function from your 2018 edition code.</li>
</ul>
</li>
</ul>
<h4 id="derivable-traits"><a class="header" href="#derivable-traits">Derivable Traits</a></h4>
<h5 id="debug"><a class="header" href="#debug"><code>Debug</code></a></h5>
<ul>
<li>It can used to print elements by using <code>:?</code> within <code>{}</code> placeholders.</li>
<li>The <code>Debug</code> trait is required, for example, in use of the <code>assert_eq!</code> macro. This macro prints the values of instances given as arguments if the equality assertion fails so programmers can see why the two instances weren’t equal.</li>
</ul>
<h5 id="partialeq"><a class="header" href="#partialeq"><code>PartialEq</code></a></h5>
<ul>
<li>By deriving this trait you can use <code>==</code> and <code>!=</code> operators on structs an enums.</li>
<li>It implements the <code>eq</code> method.</li>
</ul>
<h5 id="eq"><a class="header" href="#eq"><code>Eq</code></a></h5>
<ul>
<li>
<p>It's purpose is to check that the annotated types are equal to itself.</p>
</li>
<li>
<p>It can only be implemented by the types that already implements <code>PartialEq</code>.</p>
</li>
<li>
<p>The mathematical difference between <code>Eq</code> and <code>PartialEq</code> is that <code>Eq</code> is reflexive, symmetric and transitive. However,<code>PartialEq</code> only guarantees <code>symmetric</code> and <code>transitive</code>.</p>
<pre><code class="language-math">reflexive: a == a;
symmetric: a == b implies b == a; and
transitive: a == b and b == c implies a == c.
</code></pre>
</li>
<li>
<p>An example of a type that follows <code>PartialEq</code> and doesn't follows <code>Eq</code> is floating point number. The implementation of floating point numbers states that two instances of the not-a-number (<code>NaN</code>) value are not equal to each other.</p>
</li>
<li>
<p>An example of when <code>Eq</code> is required is for keys in a <code>HashMap&lt;K, V&gt;</code> so the <code>HashMap&lt;K, V&gt;</code> can tell whether two keys are the same.</p>
</li>
</ul>
<h5 id="partialord"><a class="header" href="#partialord"><code>PartialOrd</code></a></h5>
<ul>
<li>A type that implements PartialOrd can be used with the <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code> operators.</li>
<li>The <code>PartialOrd</code> trait allows you to compare instances of a type for sorting purposes.</li>
<li>It implements the <code>partial_cmp</code> method, which returns an <code>Option&lt;Ordering&gt;</code> that will be <code>None</code> when the values given don’t produce an ordering.</li>
<li>Since floating point numbers can't compare (or order) the not-a-number (<code>NaN</code>), it doesn't support this trait.</li>
<li>When derived on enums, variants declared earlier in the enum definition are considered less than the variants listed later.</li>
<li>When derived on structs, it compares two instances by comparing the value in each field in the order in which the fields appear in the struct definition.</li>
</ul>
<h5 id="ord"><a class="header" href="#ord"><code>Ord</code></a></h5>
<ul>
<li>It implements the <code>cmp</code> method, which returns an <code>Ordering</code> rather than an <code>Option&lt;Ordering&gt;</code> because a valid ordering will always be possible.</li>
<li>You can only apply the <code>Ord</code> trait to types that also implement <code>PartialOrd</code> and <code>Eq</code> (and <code>Eq</code> requires <code>PartialEq</code>).</li>
<li>When derived on structs and enums, <code>cmp</code> behaves the same way as the derived implementation for <code>partial_cmp</code> does with <code>PartialOrd</code>.</li>
<li>An example of when Ord is required is when storing values in a <code>BTreeSet&lt;T&gt;</code>, a data structure that stores data based on the sort order of the values.</li>
</ul>
<h5 id="clone-1"><a class="header" href="#clone-1"><code>Clone</code></a></h5>
<ul>
<li>It allows you to perform a deep copy (copying the data on heap) of a value.</li>
<li>When you derive clone on a type, then it is required that the type's fields must also derive the clone.</li>
</ul>
<h5 id="copy"><a class="header" href="#copy"><code>Copy</code></a></h5>
<ul>
<li>It allows you to copy data on the stack.</li>
<li>Copying is a lot faster than cloning but it's undesirable for large items. For Example, String.</li>
<li>A type that implements copy must also implement clone. It is trivial because Clone performs the same task as Copy.</li>
</ul>
<h5 id="hash"><a class="header" href="#hash"><code>Hash</code></a></h5>
<ul>
<li>It allows you to take an <em>instance of a type</em> of arbitrary size and map that instance to a <em>value of fixed size</em> using a hash function.</li>
<li>It is required in storing keys in a <code>HashMap&lt;K, V&gt;</code> to store data efficiently.</li>
<li>If a type implements this trait then it's required that all of it fields must also implement this trait.</li>
</ul>
<h5 id="default"><a class="header" href="#default"><code>Default</code></a></h5>
<ul>
<li>It allows you to create a default value of a type.</li>
<li>The <code>Default::default</code> function is commonly used in combination with the struct update syntax.</li>
<li>You can customize a few fields of a struct and then set and use a default value for the rest of the fields by using <code>..Default::default()</code>.</li>
<li>You can use the method <code>unwrap_or_default()</code> on <code>Option&lt;T&gt;</code> instances.</li>
<li>For Example, If the <code>Option&lt;T&gt;</code> is <code>None</code>, the method <code>unwrap_or_default</code> will return the result of <code>Default::default</code> for the type <code>T</code> stored in the <code>Option&lt;T&gt;</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-tests"><a class="header" href="#rust-tests">Rust Tests</a></h1>
<p>You'll learn about the different forms of tests written in Rust. You'll also learn how to do Test Driven Development.</p>
<p>Fun Fact: In Rust, each test is run in a new thread, and when the main thread sees that a test thread has died, the test is marked as failed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<ul>
<li>
<p>You can create a boilerplate rust project that automatically has tests using the following commmand:</p>
<pre><code class="language-zsh">cargo new &lt;project-name&gt; --lib
</code></pre>
</li>
<li>
<p>A <code>test</code> in Rust is a function that’s annotated with the test attribute.</p>
</li>
<li>
<p>The bodies of test functions typically perform these three actions:</p>
<ol>
<li>Set up any needed data or state.</li>
<li>Run the code you want to test.</li>
<li>Assert the results are what you expect.</li>
</ol>
</li>
<li>
<p>Two attributes to keep in mind:</p>
<ol>
<li><code>#[test]</code> - To change a function into a test function, add <code>#[test]</code> on the line before <code>fn</code>.</li>
<li><code>#[should_panic]</code> - To declare before each test function that if this function panics then it is working correctly.</li>
</ol>
</li>
<li>
<p>After adding the attribute <code>#[test]</code>, the rust compiler is ready to run <code>cargo test</code>.</p>
</li>
<li>
<p>When you run the command, behind the scenes Rust builds a test runner binary that runs the functions annotated with the <code>test</code> attribute.</p>
</li>
<li>
<p>You can write the functions that are not tests inside the tests module, for example a helper function. So, the only way for the Rust to know whether a function is a test function is through the <code>#[test]</code> attribute.</p>
</li>
<li>
<p>The tests fail when something in the test function panics.</p>
</li>
<li>
<p>Here is the table for the logging statistics:</p>
<div class="table-wrapper"><table><thead><tr><th>Statistic</th><th>Meaning</th></tr></thead><tbody>
<tr><td>Passed</td><td>Passing Tests</td></tr>
<tr><td>Failed</td><td>Failing Tests</td></tr>
<tr><td>Ignored</td><td>Tests that were ignored due to <code>#[ignore]</code> attribute.</td></tr>
<tr><td>Measured</td><td>This is for benchmark tests that measure performance. (only in nightly Rust)</td></tr>
<tr><td>Filtered Out</td><td>While running specific tests, the left out tests are called <code>filtered</code>.</td></tr>
</tbody></table>
</div></li>
<li>
<p>Here is the table for the macros you mauy use for assertion:</p>
<div class="table-wrapper"><table><thead><tr><th>Assertion Macro</th><th>Use Case</th><th>Argument(s)</th></tr></thead><tbody>
<tr><td><code>assert!()</code></td><td>If the condition is true then passes else panics.</td><td>Condition</td></tr>
<tr><td><code>panic!()</code></td><td>Panics or fails the test with a message if given.</td><td>Message</td></tr>
<tr><td><code>assert_eq!()</code></td><td>Passes if equal else panics. (<code>==</code>)</td><td>(actual, expected)</td></tr>
<tr><td><code>assert_ne!()</code></td><td>Passes if not equal else panics. (<code>!=</code>)</td><td>(actual, not_expected)</td></tr>
</tbody></table>
</div></li>
<li>
<p>In rust the convention doesn't matter, we can either use actual as first argument or as second. It is the programmer's convention.</p>
</li>
<li>
<p>In case we are writing the tests in a module inside the same file then we'll need to use the <code>super::*;</code> inside the tests module to pull all the outside code of the current file.</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//Filename: src/lib.rs
fn do_something() {
  ...
}


#[cfg(test)]
mod tests {
    // The line below will pull all the code of outer module inside.
    use super::*;

    #[test]
    fn test_do_something() {
      ...
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>
<p>For structs and enums that you define, you’ll need to implement <code>PartialEq</code> to assert that values of those types are equal or not equal.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq, Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

#[cfg(test)]
mod tests {
    use super::*;

    // This test will only work if we'll add #[derive(PartialEq)] to the struct or enum.
    #[test]
    fn rectangle_is_of_same_size() {
        let rectangle1 = Rectangle {
            width: 8,
            height: 7,
        };
        let rectangle2 = Rectangle {
            width: 8,
            height: 7,
        };

        assert_eq!(rectangle1, rectangle2);
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>You’ll need to implement <code>Debug</code> to the struct or enum if you want to see the logs that say <code>(left != right)</code>.</p>
<pre><code class="language-zsh">---- tests::rectangle_is_of_same_size stdout ----
thread 'tests::rectangle_is_of_same_size' panicked at 'assertion failed: `(left == right)`
  left: `Rectangle { width: 8, height: 7 }`,
 right: `Rectangle { width: 8, height: 8 }`', src/lib.rs:56:9
</code></pre>
</li>
<li>
<p>The <code>assert!()</code> macro also allows the message to show in case the test fails.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert!(
  result.contains(&quot;something&quot;),
  &quot;The result doesn't contain something. This was the actual result: {}&quot;,
  result
)
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>There is an attribute named <code>#[should_panic]</code>, that you can write before any test function to declare that if this function panics then it is working correctly.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>This is the note that appears in case the function doesn't panics.</p>
<pre><code class="language-zsh">note: test did not panic as expected
</code></pre>
</li>
<li>
<p>To make the <code>![should_panic]</code> attribute more precise we can add the <code>expected</code> parameter and pass a string to it such that the string is a substring of the relevant panic message.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(
                &quot;Guess value must be greater than or equal to 1, got {}.&quot;,
                value
            );
        } else if value &gt; 100 {
            panic!(
                &quot;Guess value must be less than or equal to 100, got {}.&quot;,
                value
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // The below test only passes if both the two conditions satisfies:
    // 1. Code should panic
    // 2. The string passed in expected parameter is a substring of the panic message.
    #[test]
    #[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]
    fn greater_than_100() {
        Guess::new(200);
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>There is also an alternative approach possible to use <code>Ok()</code> and <code>Err()</code> inside a test.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from(&quot;two plus two does not equal four&quot;))
        }
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Pros: The only upside of writing tests such that they return a <code>Result&lt;T, E&gt;</code> enables you to use the question mark (<code>?</code>) operator in the body of tests, which can be a convenient way to write tests that should fail if any operation within them returns an Err variant.</p>
</li>
<li>
<p>Cons: If we write tests in above manner than we cannot use <code>#[should_panic]</code> attribute because we can use <code>Err()</code>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="controlling-tests"><a class="header" href="#controlling-tests">Controlling Tests</a></h2>
<ul>
<li>
<p>Command Line Options either go to:</p>
<ol>
<li><code>cargo test</code> - Run this command for help, <code>cargo test --help</code></li>
<li>The resulting test binary - Run this command for help, <code>cargo test -- --help</code>.</li>
</ol>
</li>
<li>
<p>In simple terms, if you want to pass something into tests binary you'll have to seperate them with <code>--</code>.</p>
</li>
</ul>
<h4 id="threading-while-running-tests"><a class="header" href="#threading-while-running-tests">Threading while running Tests</a></h4>
<ul>
<li>
<p>By default, Rust runs tests in different threads.</p>
</li>
<li>
<p>In case the test depends on each other. For example, tests perform read, write, and assert to a same file. If run concurrently, the file will get corrupt and the tests might fail.</p>
</li>
<li>
<p>To run tests on a single thread, one by one we can do it by:</p>
<pre><code class="language-zsh">cargo test -- --test-threads=1
</code></pre>
</li>
<li>
<p>This command will prevent parallelism, though the tests will take longer to run but it'll save us from the above problem.</p>
</li>
</ul>
<h4 id="printing-while-running-tests"><a class="header" href="#printing-while-running-tests">Printing while running tests</a></h4>
<ul>
<li>
<p>By default, when we run <code>cargo test</code>, the compiler never prints the statements.</p>
</li>
<li>
<p>To display print statements we can run this command:</p>
<pre><code class="language-zsh">cargo test -- --show-output
</code></pre>
</li>
</ul>
<h4 id="running-specific-tests"><a class="header" href="#running-specific-tests">Running Specific Tests</a></h4>
<ul>
<li>
<p>To run specific tests either 1 or more, we can do that by specifying the name of test.</p>
<ul>
<li>
<p>For One Test:</p>
<pre><code class="language-zsh">cargo test &lt;name-of-test&gt;
</code></pre>
</li>
<li>
<p>For more than one test (e.g. add_two, add_three, then substring add):</p>
<pre><code class="language-zsh">cargo test &lt;substring-of-tests-name&gt;
</code></pre>
</li>
</ul>
</li>
<li>
<p>When we run specific tests, the remaining tests will fall into the category of <code>filtered out</code>, you may see that in the logs.</p>
</li>
<li>
<p>Also note that the module in which a test appears becomes part of the test’s name, so we can run all the tests in a module by filtering on the module’s name.</p>
</li>
</ul>
<h4 id="ignoring-tests"><a class="header" href="#ignoring-tests">Ignoring Tests</a></h4>
<ul>
<li>
<p>Instead of filtering tests, you may like to ignore the tests by adding <code>#[ignore]</code> attribute above each test that you'd like to ignore.</p>
</li>
<li>
<p>Now, you may use the following commands to run the tests.</p>
<ul>
<li>
<p>To run the tests ignoring ones that use <code>#[ignore]</code> attribute:</p>
<pre><code class="language-zsh">cargo test
</code></pre>
</li>
<li>
<p>To run only the ignored tests:</p>
<pre><code class="language-zsh">cargo test -- --ignored
</code></pre>
</li>
<li>
<p>To run both ignored and not ignored tests:</p>
<pre><code class="language-zsh">cargo test -- --include-ignored
</code></pre>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test-organization"><a class="header" href="#test-organization">Test Organization</a></h1>
<h3 id="test-types"><a class="header" href="#test-types">Test Types</a></h3>
<ul>
<li>The Rust community thinks about tests in terms of two main categories <strong>Unit Tests</strong> and <strong>Integration tests</strong>.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Unit Tests</th><th>Integration tests</th></tr></thead><tbody>
<tr><td>Small and Focused</td><td>Large and Broad</td></tr>
<tr><td>Internal</td><td>External</td></tr>
<tr><td>Tests One Module</td><td>Tests Multiple Modules</td></tr>
<tr><td>Can Test Private Interfaces</td><td>Only Tests Public Interfaces</td></tr>
<tr><td>Testing Internally such that external code may not possibly do</td><td>Testing like some external code would do</td></tr>
<tr><td>Lives inside <code>src</code> directory inside each module</td><td>Lives in <code>tests</code> directory right outside <code>src</code> directory</td></tr>
<tr><td>Module named tests inside each module with <code>#[cfg(test)]</code></td><td>Different files inside <code>tests</code> directory without <code>#[cfg(test)]</code></td></tr>
</tbody></table>
</div>
<h4 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h4>
<ul>
<li>
<p>This annotation <code>#[cfg(test)]</code> tells Rust to only run this module on <code>cargo test</code>, not when you run <code>cargo build</code>.</p>
</li>
<li>
<p>Thus, the functions following this annotation are never part of compiled result, hereby saving some space.</p>
</li>
<li>
<p>Only used for unit tests, since integration tests are different directory they don't need to use it.</p>
</li>
<li>
<p>An example worth noting:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Both code and unit test lives in the same file.

pub fn public_fn() {
  ...
}

fn private_fn() {
  ...
}

// cfg stands for configuration
#[cfg(test)]
mod tests {
  // You'll use this line to pull code from outside this module but inside this file.
  use super::*;

  // A helper function
  fn helper() {
    ...
  }

  // Only this fn will be considered test, unlike above fn
  #[test]
  fn it_works() {
      // Can test both private and public functions.
      ...
  }
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h4 id="integration-tests"><a class="header" href="#integration-tests">Integration tests</a></h4>
<ul>
<li>
<p>For integration test, we create a new directory <code>target</code> beside the <code>src</code> directory.</p>
</li>
<li>
<p>Each file in the tests directory is compiled as its own separate crate.</p>
</li>
<li>
<p>Treating each integration test file as its own crate is useful to create separate scopes that are more like the way end users will be using your crate.</p>
</li>
<li>
<p>However, this means files in the tests directory don’t share the same behavior as files in src do.</p>
</li>
<li>
<p>The file structure of integration tests are:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rust_project
├── src
|  └── lib.rs
├── target
|  ├── ...
|  └── ...
├── tests
|  ├── common
|  |  └── mod.rs // contains helper functions for tests
|  └── integration_test.rs // contains integration tests
├── Cargo.lock
└── Cargo.toml
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>The helper functions lives inside file <code>tests/common/mod.rs</code>.</p>
</li>
<li>
<p>This is a naming convention that rust uses to prevent functions inside this file not to appear in output logs of tests.</p>
</li>
<li>
<p>Files in subdirectories of the tests directory don’t get compiled as separate crates or have sections in the test output.</p>
</li>
<li>
<p>It looks something like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn setup() {
    // setup code specific to your library's tests would go here
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>The <code>integration_test.rs</code> looks similar to this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Each file in the tests directory is a separate crate, so we need to bring our library into each test crate’s scope
use adder;

// Bring the common functions
mod common;

// No need to add `#[cfg(test)]` attribute, since we are in the tests directory.

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>To run all the tests in a particular integration test file, use:</p>
<pre><code class="language-zsh">cargo test --test &lt;integration-test-filename&gt;
</code></pre>
</li>
<li>
<p>We can't write integration tests for binary crates, the rust projects that only contains a <code>src/main.rs</code> file and doesn’t have a <code>src/lib.rs</code> file.</p>
</li>
<li>
<p>The reason is that we cannot bring functions defined in the <code>src/main.rs</code> file into scope of files in <code>tests</code> directory with a use statement.</p>
</li>
<li>
<p>Only library crates expose functions that other crates can use; binary crates are meant to be run on their own.</p>
</li>
<li>
<p>Though, if a project contains both <code>src/lib.rs</code> and <code>sr/main.rs</code>, we can write integration tests for the important functionality inside <code>src/lib.rs</code> using the <code>use</code> keyword.</p>
</li>
<li>
<p>If the important functionality works, the small amount of code in the <code>src/main.rs</code> file will work as well, and that small amount of code doesn’t need to be tested.</p>
</li>
</ul>
<h3 id="doc-tests"><a class="header" href="#doc-tests">Doc Tests</a></h3>
<ul>
<li>
<p>You can write doc tests above the item, using the <code>Examples</code> with the docs comment <code>///</code> like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Running <code>cargo test</code> will run the code examples in your documentation as tests! In case we change the function, the test will panic, and we'll require to update the docs to make it work.</p>
<pre><code class="language-zsh">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s
</code></pre>
</li>
</ul>
<h3 id="tests-output-log"><a class="header" href="#tests-output-log">Tests Output Log</a></h3>
<ul>
<li>The output logs section has three parts:
<ol>
<li>Unit Tests</li>
<li>Integration Tests</li>
<li>Doc Tests</li>
</ol>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test-driven-development"><a class="header" href="#test-driven-development">Test Driven Development</a></h1>
<h2 id="a-step-by-step-guide"><a class="header" href="#a-step-by-step-guide">A Step by Step guide</a></h2>
<p><strong>Step 1:</strong> <strong>Don't</strong> write any source code, write tests first. Elaboration: It's okay to frame out production data
structures and code patterns without tests; but they should contain no valid behavioral code. Use macros
like <code>unimplemented!()</code> or <code>todo!()</code> (the latter is prefered) to hold places for code that doesn't exist yet.</p>
<p><strong>Step 2 (Red!):</strong> Run the test, and see the test getting failed, to prove that some changes in the code are required to pass
the test. Elaboration: <em>Always</em> watch a test fail before you make it pass. If you don't see tests fail,
it's easy to accidentally test code you're not writing and write code that has very little to do with the
tests you're writing.</p>
<p><strong>Step 3 (Green!):</strong> Now, write code such that the failing test(s) passes. Elaboration: Don't write bad code just for
fun, but also don't worry too much about slavishly following best practices in everything in this step,
The important thing is to get the tests passing. If you have to commit atrocities to make the tests pass,
go ahead and commit them.</p>
<p><strong>Step 3.5 (Refactor!):</strong> Once you see all the tests passing, refactor your atrocities. <em>Do not</em> add any new functionality
to the production code, but rearrange (possibly redesign) it to be more elegant and pretty. As long as
you don't add any new functionality, you don't have to worry about accidentally screwing something up:
if you break the existing one, a test will fail.</p>
<p><strong>Step 4:</strong> Once the new code is refactored and beautiful, repeat the process from Step 1.</p>
<p>Maxim from <a href="https://github.com/searls">Justin Searls</a>: &quot;Every line of production code must be
demanded into existence by a failing test.&quot;</p>
<p>Note: Any code that doesn't drive new code is an overhead and it causes the cost of refactoring.
Refer <a href="https://github.com/utkarshg6/rust-tests/commit/c8219592c26fc2fcc32b805e3670bd0666c2e235#diff-b1a35a68f14e696205874893c07fd24fdb88882b47c23cc0e0c80a30c7d53759R33">here</a> for more explanation.</p>
<p><em>Postulated by <a href="https://github.com/dnwiebe">Dan Wiebe</a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="useful-snippets"><a class="header" href="#useful-snippets">Useful Snippets</a></h1>
<p>This section contains commonly used code snippets that you can use in your projects.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="useful-operations"><a class="header" href="#useful-operations">Useful operations</a></h2>
<ul>
<li>
<p>Taking Input and performing type conversions</p>
<pre><pre class="playground"><code class="language-rust">// Always import when you want to take input from user
use std::io;

fn main() {
  let mut input = String::new();

  // read_line() returns io::Result, which is an enum
  // It acts as a match, either returns Ok() with value or prints error.
  io::stdin().read_line(&amp;mut input)
             .expect(&quot;Failed to read line.&quot;);

  // Declaring a variable with same name again is called shadowing, mostly used for type conversions.
  // Trims whitespaces at start and end, `/n` (newline) and `/r/n` (windows carriage return and a newline)
  // parse() (returns Result), parses the string to a number, into the defined type
  let input: u32 = match guess.trim()
                              .parse()
                              .expect(&quot;Invalid Input&quot;);

  println!(&quot;Your input: {}&quot;, input);
}</code></pre></pre>
</li>
<li>
<p>Generating Random Numbers (need external crate <code>rand</code>)</p>
<pre><pre class="playground"><code class="language-rust">// The Rng trait defines the functions that we'll use to generate random numbers
use rand::Rng;

fn main() {
  // thread_rng() is a random number generator that is local to the current thread of execution and seeded by the operating system.
  // gen_range() is a function part of Rng and it generates a random number of range [inclusive, exclusive), 1..101 === 1..=100
  let random_number = rand::thread_rng().gen_range(1..101);
}</code></pre></pre>
</li>
<li>
<p>A hack to know type definitions, is to write a wrong definition, and read the error from logs, they'll tell you the correct type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// FAIL: It doesn't have u32 as type, we wrote wrong type,
// to find the correct one by reading error logs.
let f: u32 = File::open(&quot;hello.txt&quot;);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>To read the contents of a file into a string:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string(&quot;hello.txt&quot;)
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>To return the last character of first line in a text.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn last_char_of_first_line(text: &amp;str) -&gt; Option&lt;char&gt; {
  text.lines() // Converts string slice into iterator of lines
      .next()? // Returns First element of iterator or None
      .chars() // Converts string slice into iteratot of characters
      .last() // Returns last element
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Read command line arguments and store them into a vector.</p>
<pre><pre class="playground"><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    println!(&quot;{:?}&quot;, args);
}</code></pre></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="useful-functions"><a class="header" href="#useful-functions">Useful Functions</a></h1>
<h3 id="unwrap"><a class="header" href="#unwrap"><code>unwrap()</code></a></h3>
<ul>
<li>
<p>If we call unwrap it will make sure that if the result was an error, it will terminate our program, if it is a success it will yield the contents of it’s results.</p>
</li>
<li>
<p>We use it while taking input.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>io::stdin().read_line(&amp;mut input).unwrap();
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h3 id="trim"><a class="header" href="#trim"><code>trim()</code></a></h3>
<ul>
<li>
<p>This function removes all whitespaces from a string.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let trimmed_string = input_string.trim();
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h3 id="parse"><a class="header" href="#parse"><code>parse()</code></a></h3>
<ul>
<li>
<p>This function will parse the variable to different data type.</p>
</li>
<li>
<p>We’ll only have to provide the data type to the variable and the <code>parse()</code> will call the required parsing function.</p>
</li>
<li>
<p>The <code>parse()</code> returns a Result instead of parsed variable since it has a chance of failure. For Example, if we try to convert a string into floats which contains alphabets.</p>
</li>
<li>
<p>So, we use <code>unwrap()</code> along with parse, telling the compiler to stop the execution in case of failure.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let weight: f32 = input.trim().parse().unwrap();
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h3 id="or"><a class="header" href="#or"><code>or()</code></a></h3>
<ul>
<li>This function is used to handle the result and error variables.</li>
<li>If the result is ok, then it will return the unwrapped result, if error happens, it will return the error passed in the or function.</li>
<li>There is a question mark in the end, which is a shorthand for match block, if we don’t use question mark, we’ll have to still use the match block with <code>or</code> function.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Traditional Method
match str::from_utf8(buf) {
    Ok(request) =&gt; {},
    Err(_) =&gt; return Err(ParseError::InvalidEncoding)
}

// Using or function
str::from_utf8(buf).or(Err(ParseError::InvalidEncoding))?;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="useful-macros"><a class="header" href="#useful-macros">Useful Macros</a></h1>
<h3 id="todo"><a class="header" href="#todo"><code>todo!()</code></a></h3>
<ul>
<li>
<p>Indicates unfinished code.</p>
</li>
<li>
<p>This can be useful if you are prototyping and are just looking to have your code typecheck.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn untested_function() {
    // let's not worry about implementing untested_function() for now
    todo!();
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h3 id="dbg"><a class="header" href="#dbg"><code>dbg!()</code></a></h3>
<ul>
<li>
<p>This is a debug macro, we can pass any variable inside it to see debug logs in console.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_variable = 12.0;
dbg!(my_variable)
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="masq-rust-tools"><a class="header" href="#masq-rust-tools">MASQ Rust Tools</a></h1>
<p>This section contains the tools that are not the part of official Rust and are created by the dev team at MASQ for the development of the project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<p>The following sections contain reference material you may find useful in your Rust journey.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="installation"><a class="header" href="#installation">Installation</a></h3>
<p>For Linux and macOS:</p>
<ul>
<li>
<p>Download the rustup and install it using:</p>
<pre><code class="language-zsh">curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
</li>
<li>
<p>You may need to install C compiler, because it'll give you a linker and also because some common Rust packages depend on C code:</p>
<ul>
<li>
<p>For macOS:</p>
<pre><code class="language-zsh">xcode-select --install
</code></pre>
</li>
<li>
<p>For Linux:</p>
<p>Linux users should generally install GCC or Clang, according to their distribution’s documentation. For example, if you use Ubuntu, you can install the <code>build-essential</code> package.</p>
</li>
</ul>
</li>
</ul>
<p>For Windows:</p>
<ul>
<li>People should follow <a href="https://www.rust-lang.org/tools/install">these instructions</a> to install Rust. Also, install <a href="https://visualstudio.microsoft.com/visual-cpp-build-tools/">Build Tools for Visual Studio 2019</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-rust-commands"><a class="header" href="#basic-rust-commands">Basic Rust Commands</a></h1>
<ul>
<li>
<p>To check version or to verify that Rust is installed properly:</p>
<pre><code class="language-zsh">rustc --version
</code></pre>
</li>
<li>
<p>Update Rust:</p>
<pre><code class="language-zsh">rustup update
</code></pre>
</li>
<li>
<p>Uninstall Rust and rustup:</p>
<pre><code class="language-zsh">rustup self uninstall
</code></pre>
</li>
<li>
<p>Open Rust Docs locally on browser:</p>
<pre><code class="language-zsh">rustup doc
</code></pre>
</li>
<li>
<p>List the rustup toolchain</p>
<pre><code class="language-zsh">rustup toolchain list
</code></pre>
</li>
<li>
<p>Install rustup toolchain</p>
<pre><code class="language-zsh">rustup toolchain install nightly-x86_64-unknown-linux-gnu
</code></pre>
</li>
<li>
<p>Use nightly on a specific project (after this all the <code>rustc</code> and <code>cargo</code> commands will use nightly):</p>
<pre><code class="language-zsh">cd ~/projects/needs-nightly
rustup override set nightly
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="conventions-in-rust"><a class="header" href="#conventions-in-rust">Conventions in Rust</a></h3>
<ul>
<li>
<p>Rust code uses <em>snake case</em> as the conventional style for function and variable names, in which all letters are lowercase and underscores separate words.</p>
</li>
<li>
<p>Rust style is to indent with four spaces, not a tab.</p>
</li>
<li>
<p>Naming convention for constants is to use all uppercase with underscores between words.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>The names of static variables are in <code>SCREAMING_SNAKE_CASE</code> by convention.</p>
</li>
<li>
<p>The names of a <em>type</em> in rust uses CamelCase. For example, consider <code>T</code> in <code>Result&lt;T&gt;</code>.</p>
</li>
<li>
<p>Documentation Comments use <code>///</code>, and is converted to HTML, unlike simple comments <code>//</code>. So simply add the documentation above the items. <a href="ch-10-appendix/pg-03-conventions-in-rust.html#documentation">Learn more</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<ul>
<li>
<p>Always remember that, <em>programmers are interested in knowing how to use your crate as opposed to how your crate is implemented</em>.</p>
</li>
<li>
<p>You'll be using <code>///</code> for documentation. Notice that you'll need to add docs comment above your item, not inside the <code>{}</code>. Using this<code>///</code>, we're documenting the item that follows it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>You can use <code>cargo doc</code> to generate the docs as HTML, and can open it through <code>target/doc</code> directory or by running the command <code>cargo doc --open</code>.</p>
</li>
<li>
<p>Just like <code>Examples</code> as shown in the above code, you can use other sections too. Here are other <a href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#commonly-used-sections">commonly used sections</a>.</p>
</li>
<li>
<p>Running <code>cargo test</code> will run the code examples in your documentation as tests! In case we change the function, the test will panic, and we'll require to update the docs to make it work.</p>
<pre><code class="language-zsh">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s
</code></pre>
</li>
<li>
<p>To document a whole crate, <code>//!</code> is used in the crate root file (<code>src/lib.rs</code>). Using this <code>//!</code>, we’re documenting the item that contains this comment.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargo"><a class="header" href="#cargo">Cargo</a></h2>
<ul>
<li>
<p>It is the package manager for rust. It does the following things:</p>
<ul>
<li>Manages Rust Projects</li>
<li>Download packages or dependencies</li>
<li>Build both your code and it's dependencies</li>
</ul>
</li>
<li>
<p>Check Cargo Installation or Version:</p>
<pre><code class="language-bash">cargo --version
</code></pre>
</li>
<li>
<p>Create New Boilerplate Project:</p>
<pre><code class="language-bash">cargo new {project-name}
</code></pre>
</li>
<li>
<p>Create Boilerplate Binary Project (only <code>main.rs</code>):</p>
<pre><code class="language-bash">cargo new {project-name} --bin
</code></pre>
</li>
<li>
<p>Create Boilerplate Library Project (for writing tests, contains <code>lib.rs</code>):</p>
<pre><code class="language-bash">cargo new {project-name} --lib
</code></pre>
</li>
<li>
<p>Help for Cargo new:</p>
<pre><code class="language-bash">cargo new --help
</code></pre>
</li>
<li>
<p>Build a Project (Installing Dependencies and Compiling):</p>
<pre><code class="language-bash">cargo build
</code></pre>
</li>
<li>
<p>Run a Project (build + run):</p>
<pre><code class="language-bash">cargo run
</code></pre>
</li>
<li>
<p>Running through executable binary:</p>
<pre><code class="language-bash">./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
</code></pre>
</li>
<li>
<p>Compile but don't generate executable (it's just faster than <code>cargo build</code>):</p>
<pre><code class="language-bash">cargo check
</code></pre>
</li>
<li>
<p>Build for releases (it's optimized and binaries lives in <code>target/release</code>):</p>
<pre><code class="language-bash">cargo build --release
</code></pre>
</li>
<li>
<p>To generate docs, you can access them through <code>target/doc</code>:</p>
<pre><code class="language-zsh">cargo doc
</code></pre>
</li>
<li>
<p>To generate docs of all dependencies of your project and run them in browser:</p>
<pre><code class="language-zsh">cargo doc --open
</code></pre>
</li>
<li>
<p>We can install <code>cargo-expand</code> to use cargo libraries system wide.</p>
<pre><code class="language-zsh">cargo install cargo-expand
</code></pre>
</li>
<li>
<p>The cargo expand command</p>
<pre><code class="language-zsh">cargo expand
</code></pre>
</li>
<li>
<p>To install a package from crates.io into your system, you may use this command (only binary crates can be installed and ensure that <code>$HOME/.cargo/bin</code> is in your <code>$PATH</code>):</p>
<pre><code class="language-zsh">cargo install &lt;package-name&gt;
</code></pre>
</li>
<li>
<p>To list out custom cargo commands:</p>
<pre><code class="language-zsh">cargo --list
</code></pre>
</li>
<li>
<p>To automatically format code:</p>
<pre><code class="language-zsh">cargo fmt
</code></pre>
</li>
<li>
<p>To automatically fix warnings (fixable by compiler):</p>
<pre><code class="language-zsh">cargo fix
</code></pre>
</li>
<li>
<p>To Lint your code:</p>
<pre><code class="language-zsh">cargo clippy
</code></pre>
</li>
</ul>
<h4 id="the-opt-level"><a class="header" href="#the-opt-level">The <code>opt-level</code></a></h4>
<ul>
<li>
<p>The <code>opt-level</code> setting controls the number of optimizations Rust will apply to your code, with a range of <code>0</code> to <code>3</code>.</p>
<pre><code class="language-toml">// Filename: Cargo.toml
[profile.dev]
opt-level = 0 // Less Optimization, less compiling time

[profile.release]
opt-level = 3 // More Optimizations, more compiling time
</code></pre>
</li>
<li>
<p>You can override any default setting by adding a different value for it in <code>Cargo.toml</code>. To override, you can add these two lines below the above lines.</p>
<pre><code class="language-toml">// Filename: Cargo.toml
[profile.dev]
opt-level = 1
</code></pre>
</li>
<li>
<p>To learn more about customizing profiles, you can read the docs <a href="https://doc.rust-lang.org/cargo/reference/profiles.html">here</a>.</p>
</li>
</ul>
<p>For more information about Cargo, check out <a href="https://doc.rust-lang.org/cargo/">its documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="editions-in-rust"><a class="header" href="#editions-in-rust">Editions in Rust</a></h2>
<ul>
<li>
<p>When you use, <code>cargo new</code>, Rust adds a bit of metadata to your <code>cargo.toml</code> about edition under <code>[package]</code>.</p>
<pre><code class="language-toml">edition = &quot;2021&quot;
</code></pre>
</li>
<li>
<p>Here are the details about editions:</p>
<div class="table-wrapper"><table><thead><tr><th>Edition</th><th>Description</th></tr></thead><tbody>
<tr><td>2015</td><td>If no edition is specified, your project is using this edition.</td></tr>
<tr><td>2018</td><td>The Rust Book is written using this edition.</td></tr>
<tr><td>2021</td><td>This is the latest release at the moment.</td></tr>
</tbody></table>
</div></li>
<li>
<p>Rust has a 6-week release cycle.</p>
</li>
<li>
<p>Rust releases small changes very often rather than big changes less often.</p>
</li>
<li>
<p>Every 2-3 years, Rust team releases a new edition.</p>
</li>
<li>
<p>Rust supports backward compatibility, it means even if you update your Rust software your old code will still compile.</p>
</li>
<li>
<p>Here are the following cases you may consider:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Edition</th><th style="text-align: center">Dependency</th><th style="text-align: center">Will Compile?</th></tr></thead><tbody>
<tr><td style="text-align: center">2015</td><td style="text-align: center">2018</td><td style="text-align: center">:white_check_mark:</td></tr>
<tr><td style="text-align: center">2018</td><td style="text-align: center">2015</td><td style="text-align: center">:white_check_mark:</td></tr>
</tbody></table>
</div></li>
<li>
<p>For more details, the <a href="https://doc.rust-lang.org/stable/edition-guide/"><em>Edition Guide</em></a> is a complete book about editions that enumerates the differences between editions and explains how to automatically upgrade your code to a new edition via cargo fix.</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
