<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Smart Pointers - MASQ Rust Docs</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Welcome!</a></li><li class="chapter-item expanded "><a href="../ch-01-introduction/main.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch-01-introduction/pg-01-benefits-of-using-rust.html"><strong aria-hidden="true">1.1.</strong> Benefits of using rust</a></li><li class="chapter-item expanded "><a href="../ch-01-introduction/pg-02-the-hello-world-program.html"><strong aria-hidden="true">1.2.</strong> The Hello World Program</a></li></ol></li><li class="chapter-item expanded "><a href="../ch-02-basics-of-rust/main.html"><strong aria-hidden="true">2.</strong> Basics of Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch-02-basics-of-rust/pg-01-variables-and-mutability.html"><strong aria-hidden="true">2.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="../ch-02-basics-of-rust/pg-02-data-types.html"><strong aria-hidden="true">2.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="../ch-02-basics-of-rust/pg-03-advanced-data-types.html"><strong aria-hidden="true">2.3.</strong> Advanced Data Types</a></li><li class="chapter-item expanded "><a href="../ch-02-basics-of-rust/pg-04-functions.html"><strong aria-hidden="true">2.4.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../ch-02-basics-of-rust/pg-05-control-flow.html"><strong aria-hidden="true">2.5.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="../ch-02-basics-of-rust/pg-06-loops.html"><strong aria-hidden="true">2.6.</strong> Loops</a></li><li class="chapter-item expanded "><a href="../ch-02-basics-of-rust/pg-07-ownership.html"><strong aria-hidden="true">2.7.</strong> Ownership</a></li><li class="chapter-item expanded "><a href="../ch-02-basics-of-rust/pg-08-borrowing.html"><strong aria-hidden="true">2.8.</strong> Borrowing</a></li><li class="chapter-item expanded "><a href="../ch-02-basics-of-rust/pg-09-structs.html"><strong aria-hidden="true">2.9.</strong> Structs</a></li><li class="chapter-item expanded "><a href="../ch-02-basics-of-rust/pg-10-enums.html"><strong aria-hidden="true">2.10.</strong> Enums</a></li><li class="chapter-item expanded "><a href="../ch-02-basics-of-rust/pg-11-pattern-matching.html"><strong aria-hidden="true">2.11.</strong> Pattern Matching</a></li></ol></li><li class="chapter-item expanded "><a href="../ch-03-common-collections/main.html"><strong aria-hidden="true">3.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch-03-common-collections/pg-01-vector.html"><strong aria-hidden="true">3.1.</strong> Vector</a></li><li class="chapter-item expanded "><a href="../ch-03-common-collections/pg-02-hashmaps.html"><strong aria-hidden="true">3.2.</strong> HashMaps</a></li></ol></li><li class="chapter-item expanded "><a href="../ch-04-project-structuring-and-error-handling/main.html"><strong aria-hidden="true">4.</strong> Project Structuring and Error Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch-04-project-structuring-and-error-handling/pg-01-project-structuring.html"><strong aria-hidden="true">4.1.</strong> Project Structuring</a></li><li class="chapter-item expanded "><a href="../ch-04-project-structuring-and-error-handling/pg-02-modularizing.html"><strong aria-hidden="true">4.2.</strong> Modularizing</a></li><li class="chapter-item expanded "><a href="../ch-04-project-structuring-and-error-handling/pg-03-error-handling.html"><strong aria-hidden="true">4.3.</strong> Error Handling</a></li></ol></li><li class="chapter-item expanded "><a href="../ch-05-medium-concepts/main.html"><strong aria-hidden="true">5.</strong> Medium Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch-05-medium-concepts/pg-01-generics.html"><strong aria-hidden="true">5.1.</strong> Generics</a></li><li class="chapter-item expanded "><a href="../ch-05-medium-concepts/pg-02-traits.html"><strong aria-hidden="true">5.2.</strong> Traits</a></li><li class="chapter-item expanded "><a href="../ch-05-medium-concepts/pg-03-lifetimes.html"><strong aria-hidden="true">5.3.</strong> Lifetimes</a></li><li class="chapter-item expanded "><a href="../ch-05-medium-concepts/pg-04-functional-language-features.html"><strong aria-hidden="true">5.4.</strong> Functional Language Features</a></li><li class="chapter-item expanded "><a href="../ch-05-medium-concepts/pg-05-smart-pointers.html" class="active"><strong aria-hidden="true">5.5.</strong> Smart Pointers</a></li><li class="chapter-item expanded "><a href="../ch-05-medium-concepts/pg-06-concurrency.html"><strong aria-hidden="true">5.6.</strong> Concurrency</a></li><li class="chapter-item expanded "><a href="../ch-05-medium-concepts/pg-07-object-oriented-programming.html"><strong aria-hidden="true">5.7.</strong> Object Oriented Programming</a></li></ol></li><li class="chapter-item expanded "><a href="../ch-06-advanced-concepts/main.html"><strong aria-hidden="true">6.</strong> Advanced Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch-06-advanced-concepts/pg-01-advanced-pattern-matching.html"><strong aria-hidden="true">6.1.</strong> Advanced Pattern Matching</a></li><li class="chapter-item expanded "><a href="../ch-06-advanced-concepts/pg-02-unsafe-rust.html"><strong aria-hidden="true">6.2.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="../ch-06-advanced-concepts/pg-03-advanced-traits.html"><strong aria-hidden="true">6.3.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="../ch-06-advanced-concepts/pg-04-advanced-types.html"><strong aria-hidden="true">6.4.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="../ch-06-advanced-concepts/pg-05-advanced-functions-and-closures.html"><strong aria-hidden="true">6.5.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="../ch-06-advanced-concepts/pg-06-macros.html"><strong aria-hidden="true">6.6.</strong> Macros</a></li><li class="chapter-item expanded "><a href="../ch-06-advanced-concepts/pg-07-miscellaneous.html"><strong aria-hidden="true">6.7.</strong> Miscellaneous</a></li></ol></li><li class="chapter-item expanded "><a href="../ch-07-rust-tests/main.html"><strong aria-hidden="true">7.</strong> Rust Tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch-07-rust-tests/pg-01-getting-started.html"><strong aria-hidden="true">7.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="../ch-07-rust-tests/pg-02-controlling-tests.html"><strong aria-hidden="true">7.2.</strong> Controlling Tests</a></li><li class="chapter-item expanded "><a href="../ch-07-rust-tests/pg-03-test-organization.html"><strong aria-hidden="true">7.3.</strong> Test Organization</a></li><li class="chapter-item expanded "><a href="../ch-07-rust-tests/pg-04-test-driven-development.html"><strong aria-hidden="true">7.4.</strong> Test Driven Development</a></li></ol></li><li class="chapter-item expanded "><a href="../ch-08-useful-snippets/main.html"><strong aria-hidden="true">8.</strong> Useful Snippets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch-08-useful-snippets/pg-01-useful-operations.html"><strong aria-hidden="true">8.1.</strong> Useful Operations</a></li><li class="chapter-item expanded "><a href="../ch-08-useful-snippets/pg-02-useful-functions.html"><strong aria-hidden="true">8.2.</strong> Useful Functions</a></li><li class="chapter-item expanded "><a href="../ch-08-useful-snippets/pg-03-useful-macros.html"><strong aria-hidden="true">8.3.</strong> Useful Macros</a></li></ol></li><li class="chapter-item expanded "><a href="../ch-09-masq-rust-tools/main.html"><strong aria-hidden="true">9.</strong> MASQ Rust Tools</a></li><li class="chapter-item expanded "><a href="../ch-10-appendix/main.html"><strong aria-hidden="true">10.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch-10-appendix/pg-01-installation.html"><strong aria-hidden="true">10.1.</strong> Installaiton</a></li><li class="chapter-item expanded "><a href="../ch-10-appendix/pg-02-basic-rust-commands.html"><strong aria-hidden="true">10.2.</strong> Basic Rust Commands</a></li><li class="chapter-item expanded "><a href="../ch-10-appendix/pg-03-conventions-in-rust.html"><strong aria-hidden="true">10.3.</strong> Conventions in Rust</a></li><li class="chapter-item expanded "><a href="../ch-10-appendix/pg-04-documentation.html"><strong aria-hidden="true">10.4.</strong> Documentation</a></li><li class="chapter-item expanded "><a href="../ch-10-appendix/pg-05-cargo.html"><strong aria-hidden="true">10.5.</strong> Cargo</a></li><li class="chapter-item expanded "><a href="../ch-10-appendix/pg-06-editions-in-rust.html"><strong aria-hidden="true">10.6.</strong> Editions in Rust</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">MASQ Rust Docs</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h3 id="smart-pointers"><a class="header" href="#smart-pointers">Smart Pointers</a></h3>
<ul>
<li>Differences between Pointer and Smart Pointer:</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Pointer</th><th>Smart Pointer</th></tr></thead><tbody>
<tr><td>A pointer is a general concept for a variable that contains an address in memory.</td><td>Smart pointers, on the other hand, are data structures that not only act like a pointer but also have additional metadata and capabilities.</td></tr>
<tr><td>References are pointers that only borrow data.</td><td>Smart pointers <em>own</em> the data they point to.</td></tr>
<tr><td>The most common kind of pointer in Rust is a reference and is indicated by <code>&amp;</code>.</td><td>The commonly used smart pointers are <code>String</code> and <code>Vec&lt;T&gt;</code>.</td></tr>
</tbody></table>
</div>
<ul>
<li>Smart pointers are usually implemented using <code>structs</code>.</li>
<li>The characteristic that distinguishes a smart pointer from an ordinary struct is that smart pointers implement the <code>Deref</code> and <code>Drop</code> traits.
<ul>
<li><code>Deref</code>: Allows an instance of the smart pointer struct to behave like a reference so you can write code that works with either references or smart pointers.</li>
<li><code>Drop</code>: Allows you to customize the code that is run when an instance of the smart pointer goes out of scope.</li>
</ul>
</li>
</ul>
<h4 id="boxt"><a class="header" href="#boxt"><code>Box&lt;T&gt;</code></a></h4>
<ul>
<li>
<p>For allocating values on Heap.</p>
</li>
<li>
<p>Box allows you to store <em>data on heap</em> and the <em>pointer to the heap data on stack</em>.</p>
</li>
<li>
<p>You’ll use them most often in these situations:</p>
<ul>
<li>When you have a type whose size can’t be known at compile time and you want to use a value of that type in a context that requires an exact size</li>
<li>When you have a large amount of data and you want to transfer ownership but ensure the data won’t be copied when you do so</li>
<li>When you want to own a value and you care only that it’s a type that implements a particular trait rather than being of a specific type</li>
</ul>
</li>
<li>
<p>Once Box goes out of scope, the deallocation happens for the box (stored on the stack) and the data it points to (stored on the heap).</p>
</li>
<li>
<p>Using <code>Box&lt;T&gt;</code> for the recursive call:</p>
<ul>
<li>
<p>Let's try to create an enum which will create it's variant recursively:</p>
<pre><pre class="playground"><code class="language-rust">// FAIL: While computing Size for Cons, Rust will detect an inifinite memory allocation
enum List {
    Cons(i32, List),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}</code></pre></pre>
</li>
<li>
<p>When Rust will try to recognize the size, it'll recognize that it is an infinite loop:</p>
<img src="https://doc.rust-lang.org/book/img/trpl15-01.svg" alt="Infinite List Containing Infinite Cons Value" width="400"/>
</li>
<li>
<p>Now, to make it easier for Rust to identify the size of enum at compile time, we can use <code>Box&lt;T&gt;</code> for the recursive call. Since <code>Box&lt;T&gt;</code> is a pointer, Rust will need not to find the size what's inside of it, instead just allocate the memory for it's pointer.</p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}</code></pre></pre>
</li>
<li>
<p>Conceptually, we still have a list, created with lists “holding” other lists, but this implementation is now more like placing the items next to one another rather than inside one another.</p>
<img src="https://doc.rust-lang.org/book/img/trpl15-02.svg" alt="List that is not infinitely sized" width="400"/>
</li>
</ul>
</li>
<li>
<p>Since <code>Box&lt;T&gt;</code> implements the <code>Deref</code> trait, so you can use the <code>*</code> operator to dereference it.</p>
</li>
</ul>
<h4 id="deref-trait"><a class="header" href="#deref-trait"><code>Deref</code> Trait</a></h4>
<ul>
<li>
<p>Note that the <code>*</code> operator is replaced with a call to the deref method and then a call to the <code>*</code> operator. It means that <code>*y</code>, translates into:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>*(y.deref())
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>We're trying to re-create <code>Box&lt;T&gt;</code> and it's capabilities to dereference itself. One important thing to notice, here we're only mimicing the dereferencing because the data doesn't actually get stored on heap.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Deref;

struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
  fn new(x: T) -&gt; MyBox&lt;T&gt;  {
      MyBox(x)
  }
}

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h4 id="deref-coercion"><a class="header" href="#deref-coercion">Deref Coercion</a></h4>
<ul>
<li>
<p>Deref coercion can convert <code>&amp;String</code> to <code>&amp;str</code>. It's possible because <code>String</code> implements the <code>Deref</code> trait such that it returns <code>&amp;str</code>.</p>
</li>
<li>
<p>They are meant for the arguments of functions and methods. The ease is that, you can pass <code>&amp;String</code> into a function that accepts <code>&amp;str</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn hello(name: &amp;str) {
    println!(&quot;Hello, {}!&quot;, name);
}

fn main() {
  let name = String::from(&quot;Bob&quot;);
  hello(&amp;name);
}</code></pre></pre>
</li>
<li>
<p>Deref coercion was added to Rust so that programmers writing function and method calls don’t need to add as many explicit references and dereferences with <code>&amp;</code> and <code>*</code>.</p>
</li>
<li>
<p>How does Rust automatically converts <code>&amp;String</code> to <code>&amp;str</code>?</p>
<ul>
<li>It happens because <code>Deref</code> trait is implemented.</li>
<li>Rust simplifies all the deref implementations.</li>
</ul>
</li>
<li>
<p>Here's an even complex example of deref coercion, using the <code>MyBox</code>, that we created earlier:</p>
<ul>
<li>
<p>Instead of calling this:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;(*m)[..]);
}</code></pre></pre>
</li>
<li>
<p>Here we are manually converting:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(*m) =&gt; MyBox&lt;String&gt; -&gt; String
[..] =&gt; String -&gt; str
&amp; =&gt; str -&gt; &amp;str
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>We can just call this:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;m);
}</code></pre></pre>
</li>
<li>
<p>Rust simplifies the deref implementations by calling the <code>deref()</code> again and again. First It'll call <code>deref()</code> for <code>MyBox</code> then for <code>String</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&amp;MyBox&lt;String&gt; -&gt; &amp;String -&gt; &amp;str
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
</li>
</ul>
<p>Note: When the Deref trait is defined for the types involved, Rust will analyze the types and use <code>Deref::deref</code> as many times as necessary to get a reference to match the parameter’s type. The number of times that <code>Deref::deref</code> needs to be inserted is resolved at compile time, so there is no runtime penalty for taking advantage of deref coercion!</p>
<ul>
<li>
<p>Rust does deref coercion when it finds types and trait implementations in three cases:</p>
<ul>
<li>From <code>&amp;T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;mut U</code> when <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
</ul>
</li>
</ul>
<p>Note: The first case states that if you have a <code>&amp;T</code>, and <code>T</code> implements <code>Deref</code> to some type <code>U</code>, you can get a <code>&amp;U</code> transparently. the second case is similar. The third case is a bit different as mutable reference changes into immutable reference, though vice versa is not true.</p>
<h4 id="drop-trait"><a class="header" href="#drop-trait"><code>Drop</code> Trait</a></h4>
<ul>
<li>
<p>In Rust, you can specify that a particular bit of code be run whenever a value goes out of scope, and the compiler will insert this code automatically.</p>
</li>
<li>
<p>As a result, you don’t need to be careful about placing cleanup code everywhere in a program that an instance of a particular type is finished with—you still won’t leak resources!</p>
<pre><pre class="playground"><code class="language-rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping CustomSmartPointer with data `{}`!&quot;, self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;my stuff&quot;),
    };
    let d = CustomSmartPointer {
        data: String::from(&quot;other stuff&quot;),
    };
    println!(&quot;CustomSmartPointers created.&quot;);
}
// Output -
// CustomSmartPointers created.
// Dropping CustomSmartPointer with data `other stuff`!
// Dropping CustomSmartPointer with data `my stuff`!</code></pre></pre>
</li>
<li>
<p>Notice that, variables are dropped in the reverse order, <code>d</code> was dropped before <code>c</code>.</p>
</li>
<li>
<p>There might be some cases when you want to manually drop the Smart Pointer, instead of waiting for the scope to end. For example, you want to release the lock so that other code in the same scope can acquire the lock.</p>
<ul>
<li>
<p>First thing is that, you can't call the <code>drop()</code> from the <code>Drop</code> trait.</p>
<pre><pre class="playground"><code class="language-rust">// FAIL: This is not allowed in Rust, compiler will throw &quot;explicit destructor calls not allowed&quot;
fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;some data&quot;),
    };
    println!(&quot;CustomSmartPointer created.&quot;);
    c.drop();
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}</code></pre></pre>
<pre><code class="language-zsh">  --&gt; src/main.rs:16:7
   |
16 |     c.drop();
   |     --^^^^--
   |     | |
   |     | explicit destructor calls not allowed
   |     help: consider using `drop` function: `drop(c)`
</code></pre>
</li>
<li>
<p>Compiler uses term <code>destructor</code>, which is the general programming term for a function that cleans up an instance. It is analogous to the word <code>constructor</code>.</p>
</li>
<li>
<p>The reason that compiler doesn't allows us to do that, is to prevent the <em>double free error</em>.</p>
</li>
<li>
<p>The alternative is to use <code>drop()</code> from <code>std::mem::drop</code>, good thing is it's already in the <code>prelude</code>, so you don't need to import it.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;some data&quot;),
    };
    println!(&quot;CustomSmartPointer created.&quot;);
    drop(c); // Notice, we're passing it as an argument
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}

// Ouput -
// CustomSmartPointer created.
// Dropping CustomSmartPointer with data `some data`!
// CustomSmartPointer dropped before the end of main.</code></pre></pre>
</li>
<li>
<p>It solves the <em>double free error</em> through the ownership rules, as we pass it as an argument.</p>
</li>
</ul>
</li>
</ul>
<h4 id="rct"><a class="header" href="#rct"><code>Rc&lt;T&gt;</code></a></h4>
<ul>
<li>
<p>Also known as <em>Reference Counted Smart Pointer</em>, it allows multiple ownership.</p>
</li>
<li>
<p>It does that by keeping the count of references. When the count becomes 0, it means that there are no references linked to data, so it's safe to clean.</p>
</li>
<li>
<p>Imagine <code>Rc&lt;T&gt;</code> as a TV in a family room. When one person enters to watch TV, they turn it on. Others can come into the room and watch the TV. When the last person leaves the room, they turn off the TV because it’s no longer being used. If someone turns off the TV while others are still watching it, there would be uproar from the remaining TV watchers!</p>
</li>
<li>
<p>Use case:</p>
<ul>
<li>We want to allocate data on heap and we want multiple parts of our code to read it.</li>
<li>The problem is that we don't know which part will stop reading it last, that's why we can't make someone as an owner.</li>
<li>For those cases, <code>Rc&lt;T&gt;</code> will help us, it'll save us from deciding someone as owner and will allow multiple parts to read it at the same time.</li>
</ul>
</li>
<li>
<p>With <code>Rc&lt;T&gt;</code> it is possible to create two lists that both share ownership of a third list.</p>
<img src="https://doc.rust-lang.org/book/img/trpl15-03.svg" alt="List that is not infinitely sized" width="400"/>
<ul>
<li>
<p>Trying to do this with <code>Box&lt;T&gt;</code> fails:</p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}</code></pre></pre>
</li>
<li>
<p>We can also use references with lifetimes to solve this problem, but <code>Rc&lt;T&gt;</code> is better here.</p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a)); // Notice that we don't need to use Rc&lt;T&gt; here, since no one will be owning b and c
    let c = Cons(4, Rc::clone(&amp;a)); // Also notice that we're using Rc::clone() and passing reference to create owners
}</code></pre></pre>
</li>
<li>
<p><code>Rc::clone()</code> never makes deep copy, unlike <code>clone()</code>. <code>Rc::clone()</code> only increments the reference count, which doesn’t take much time.</p>
</li>
<li>
<p>To Increase Count: <code>Rc::clone()</code>, To Decrease Count: <code>Drop</code> does when the variable goes out of scope.</p>
</li>
</ul>
</li>
</ul>
<p>Note: <code>Rc&lt;T&gt;</code> can only allow multiple owners to read data and not to mutate it. For interior mutability there is another Smart Pointer named <code>RefCell&lt;T&gt;</code>.</p>
<h4 id="refcellt"><a class="header" href="#refcellt"><code>RefCell&lt;T&gt;</code></a></h4>
<ul>
<li>
<p>Allows interior mutability to the immutable data.</p>
</li>
<li>
<p>Interior mutability is a design pattern in Rust that allows you to mutate data even when there are immutable references to that data; normally, this action is disallowed by the borrowing rules.</p>
</li>
<li>
<p>It uses <code>unsafe</code> rust code to function.</p>
</li>
<li>
<p>An example:</p>
</li>
<li>
<p>Consider one <code>trait</code> named <code>Messanger</code> and another <code>struct</code> named <code>LimitTracker</code>.</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: Messenger&gt; {
  messenger: &amp;'a T,
  value: usize;
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
where
    T: Messenger,
{
    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
      ...
    }

    pub fn set_value(&amp;mut self, value: usize) { // Problem 1: We want mutable reference of self, but it includes immutable reference to messenger
      self.value = value;

      if (value &gt; 100) {
        self.messenger.send(&quot;Error: You are over your quota!&quot;); // Problem 2: send() is an immutable function in trait, but self should be mutable.
      }
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>
<p><code>LimitTracker</code> takes in a reference of <code>struct</code> that implements <code>Messenger</code>, so that it can store it as one of it's field.</p>
</li>
<li>
<p>Inside <code>LimitTracker</code>, the problem is that <code>set_value()</code> takes <strong>mutable reference</strong> of <code>self</code>, but the <code>messenger</code> is an immutable reference and it's function send is also <code>immutable</code>. So, how can we test this <code>set_value()</code>?</p>
</li>
<li>
<p>This will fail to compile:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// FAIL: send() is required to be mutable by LimitTracker but immutable due to trait Messenger
#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: vec![], // This is immutable
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
             // We're trying to push on immutbale field, we also can't make send() mutable
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Here's the solution using <code>RefCell&lt;T&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        // RefCell will make sent_messages mutable even though
        // it's parent MockMessenger can seem immutable to others
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                // Now, RefCell will wrap the vector and will allow it to be mutable
                // at places where it's parent is asked to be immutable
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            // MockMessenger will seem immutable to send() but
            // sent_messages is mutable, and items can be pushed into it
            self.sent_messages.borrow_mut().push(String::from(message)); // borrow_mut() will generate mutable reference for push()
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--

        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1); // borrow() will generate the immutable reference, since we're only reading
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>We use the <code>&amp;</code> and <code>&amp;mut</code> syntax with references. With <code>RefCell&lt;T&gt;</code>, we use the <code>borrow()</code> and <code>borrow_mut()</code> methods and they return <code>Ref&lt;T&gt;</code> and <code>RefMut&lt;T&gt;</code> respectively. They both implement <code>Deref</code> trait.</p>
</li>
<li>
<p><code>RefCell&lt;T&gt;</code> lets us have many immutable borrows or one mutable borrow at any point in time. It keeps a count of whenever we call the <code>borrow()</code>.</p>
</li>
<li>
<p>In case of an error, it won't be just a compile error, but will appear on Runtime, and will cause a panic.</p>
</li>
</ul>
<h4 id="differences-between-boxt-rct-and-refcellt"><a class="header" href="#differences-between-boxt-rct-and-refcellt">Differences between <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code></a></h4>
<div class="table-wrapper"><table><thead><tr><th>Property</th><th><code>Box&lt;T&gt;</code></th><th><code>Rc&lt;T&gt;</code></th><th><code>RefCell&lt;T&gt;</code></th></tr></thead><tbody>
<tr><td>Ownership</td><td>Single Ownership</td><td>Multiple Ownership</td><td>Single Ownership</td></tr>
<tr><td>Mutability of Inner Data</td><td>Immutable or Mutable</td><td>Only Immutable</td><td>Immutable or Mutable</td></tr>
<tr><td>Borrowing Rules Check</td><td>Compiled Time (compiler errors)</td><td>Compiled Time (compiler errors)</td><td>Runtime (panics at runtime)</td></tr>
<tr><td>Multithreading</td><td></td><td>Only for Single Threaded Scenarios</td><td>Only for Single Threaded Scenarios</td></tr>
</tbody></table>
</div>
<h4 id="using-refcellt-with-rct"><a class="header" href="#using-refcellt-with-rct">Using <code>RefCell&lt;T&gt;</code> with <code>Rc&lt;T&gt;</code></a></h4>
<ul>
<li>
<p>It'll give you superpowers.</p>
</li>
<li>
<p>Now you can have a value that has multiple owners and can also mutate.</p>
</li>
<li>
<p>To use it, you'll have to wrap it like this, <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>.</p>
</li>
<li>
<p>Here's our modified <code>Cons</code> list:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Now, we can have a list like this:</p>
<pre><code class="language-zsh">b --|
    a---Nil
c --|
</code></pre>
</li>
<li>
<p>Here, <code>a</code> can have multiple owners <code>b</code> and <code>c</code>, and it's value can also mutate.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let value = Rc::new(RefCell::new(5)); // Created a value that can have multiple owners and can also mutate

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil))); // Make a such that it can be owned by multiple people

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a)); // Make b the owner of a
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a)); // Made c the owner of a

    *value.borrow_mut() += 10; // Rc -&gt; RefCell -&gt; &amp;mut -&gt; inner_element, then 10 is added to the inner_element in place

    println!(&quot;a after = {:?}&quot;, a); // Value of a: Cons(RefCell { value: 15 }, Nil)
    println!(&quot;b after = {:?}&quot;, b); // Value of b: Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
    println!(&quot;c after = {:?}&quot;, c); // Value of c: Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
}</code></pre></pre>
</li>
<li>
<p>Other Types to provide interior mutability:</p>
<ul>
<li><code>Cell&lt;T&gt;</code>: It copies the data instead of giving references.</li>
<li><code>Mutex&lt;T&gt;</code>: It provides interior mutability that's safe to use in multiple threads.</li>
</ul>
</li>
</ul>
<h4 id="memory-leak"><a class="header" href="#memory-leak">Memory Leak</a></h4>
<ul>
<li>
<p>When we accidentally create memory that is never cleaned up is called <em>Memory Leak</em>.</p>
</li>
<li>
<p>Rust’s memory safety guarantees make it difficult, but not impossible.</p>
</li>
<li>
<p>Rust allows memory leaks by using <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>.</p>
</li>
<li>
<p>By using both of them together, it's possible to create a <em>reference cycle</em>.</p>
</li>
<li>
<p>A <em>reference cycle</em> happens when reference of <code>a</code> is owned by <code>b</code> and reference of <code>b</code> is owned by <code>a</code>.</p>
</li>
<li>
<p>First of all, this will cause an infinite loop of references.</p>
</li>
<li>
<p>Also, it'll be impossible for Rust to <code>Drop</code> the values of <code>a</code> and <code>b</code>, as their reference count will never be zero.</p>
</li>
<li>
<p>This is one of Rust's limitations, and is referred to the <em>problem of Memory Leak</em>.</p>
</li>
<li>
<p>Reference Cycle in Action:</p>
<pre><pre class="playground"><code class="language-rust">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;), // We can replace the list in place now
    Nil
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil)))); // a = (5, Nil)


    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a)))); // b = (10, a)

    if let Some(link) = a.tail() {
        *link.borrow_mut() = b; // a = (5, b)
    }

    // At this point, Rc Count of a: 2, b: 2

    // This will try to print the lists infinitely
    // and then will crash with the stack overflow error
    println!(&quot;a next item = {:?}&quot;, a.tail());
}

// In case, we comment out the println!()
// At the end of scope, Rust will try to decrease the count of references
// Rc Count of b will decrease to 1
// Rc Count of a will decrease to 1
// Neither a nor b will be dropped as their count is not 0 and
// will still stay on the heap, causing Memory Leak</code></pre></pre>
</li>
<li>
<p>You may take help of this diagram to understand better:</p>
<img src="https://doc.rust-lang.org/book/img/trpl15-04.svg" alt="List that is not infinitely sized" width="400"/>
</li>
</ul>
<p>Important Lesson:
You can't rely on Rust's memory safety while using <code>RefCell&lt;T&gt;</code> and <code>Rc&lt;T&gt;</code> together, or another combination with interior mutability, as it may cause the problem of <em>Memory Leak</em>.</p>
<p>Solutions to prevent Reference Cycles:</p>
<ul>
<li>Use Automated tests, Code reviews, and other Software development practices to minimize.</li>
<li>Reorganize data structure so that some references express ownership and some references don't.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Strong Count</th><th>Weak Count</th></tr></thead><tbody>
<tr><td>Rust will only drop an element if this count becomes zero.</td><td>Rust will drop an element in case it gets out of scope, even if the count is not zero.</td></tr>
<tr><td><code>Rc&lt;T&gt;</code> uses strong count.</td><td><code>Weak&lt;T&gt;</code> uses weak count.</td></tr>
<tr><td>It's hard to prevent reference cycle.</td><td>It's easier to prevent reference cycle.</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>Preventing Reference Cycle using <code>Weak&lt;T&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;, // Child won't own it's parent
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}

fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![])
    });

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)])
    });

    // The downgrade() changes Rc -&gt; Weak
    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    // The upgrade() returns Some() or None, representing the value
    println!(&quot;Leaf parent: {:?}&quot;, leaf.parent.borrow().upgrade());
}</code></pre></pre>
</li>
<li>
<p>The output will look like this:</p>
<pre><code class="language-zsh">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
</li>
<li>
<p>Notice, at some places only <code>Weak</code> is there, and the whole element is not printed. This is Rust's way of preventing infinite output.</p>
</li>
<li>
<p>This lack of inifinite output, indicates that reference cycle is prevented.</p>
</li>
<li>
<p>Here's another example, using the same struct to show how strong count and weak count will change:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    // leaf strong = 1, weak = 0

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        // Since Rc is downgrading branch, branch's weak count will increase by 1
        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        // branch strong = 1, weak = 1

        // leaf strong = 2, weak = 0
    }

    // leaf strong = 1, weak = 0
}</code></pre></pre>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../ch-05-medium-concepts/pg-04-functional-language-features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../ch-05-medium-concepts/pg-06-concurrency.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../ch-05-medium-concepts/pg-04-functional-language-features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../ch-05-medium-concepts/pg-06-concurrency.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
