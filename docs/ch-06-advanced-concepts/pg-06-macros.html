<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Macros - MASQ Rust Docs</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Welcome!</a></li><li class="chapter-item expanded "><a href="../ch-01-introduction/main.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch-01-introduction/pg-01-benefits-of-using-rust.html"><strong aria-hidden="true">1.1.</strong> Benefits of using rust</a></li><li class="chapter-item expanded "><a href="../ch-01-introduction/pg-02-the-hello-world-program.html"><strong aria-hidden="true">1.2.</strong> The Hello World Program</a></li></ol></li><li class="chapter-item expanded "><a href="../ch-02-basics-of-rust/main.html"><strong aria-hidden="true">2.</strong> Basics of Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch-02-basics-of-rust/pg-01-variables-and-mutability.html"><strong aria-hidden="true">2.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="../ch-02-basics-of-rust/pg-02-data-types.html"><strong aria-hidden="true">2.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="../ch-02-basics-of-rust/pg-03-advanced-data-types.html"><strong aria-hidden="true">2.3.</strong> Advanced Data Types</a></li><li class="chapter-item expanded "><a href="../ch-02-basics-of-rust/pg-04-functions.html"><strong aria-hidden="true">2.4.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../ch-02-basics-of-rust/pg-05-control-flow.html"><strong aria-hidden="true">2.5.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="../ch-02-basics-of-rust/pg-06-loops.html"><strong aria-hidden="true">2.6.</strong> Loops</a></li><li class="chapter-item expanded "><a href="../ch-02-basics-of-rust/pg-07-ownership.html"><strong aria-hidden="true">2.7.</strong> Ownership</a></li><li class="chapter-item expanded "><a href="../ch-02-basics-of-rust/pg-08-borrowing.html"><strong aria-hidden="true">2.8.</strong> Borrowing</a></li><li class="chapter-item expanded "><a href="../ch-02-basics-of-rust/pg-09-structs.html"><strong aria-hidden="true">2.9.</strong> Structs</a></li><li class="chapter-item expanded "><a href="../ch-02-basics-of-rust/pg-10-enums.html"><strong aria-hidden="true">2.10.</strong> Enums</a></li><li class="chapter-item expanded "><a href="../ch-02-basics-of-rust/pg-11-pattern-matching.html"><strong aria-hidden="true">2.11.</strong> Pattern Matching</a></li></ol></li><li class="chapter-item expanded "><a href="../ch-03-common-collections/main.html"><strong aria-hidden="true">3.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch-03-common-collections/pg-01-vector.html"><strong aria-hidden="true">3.1.</strong> Vector</a></li><li class="chapter-item expanded "><a href="../ch-03-common-collections/pg-02-hashmaps.html"><strong aria-hidden="true">3.2.</strong> HashMaps</a></li></ol></li><li class="chapter-item expanded "><a href="../ch-04-project-structuring-and-error-handling/main.html"><strong aria-hidden="true">4.</strong> Project Structuring and Error Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch-04-project-structuring-and-error-handling/pg-01-project-structuring.html"><strong aria-hidden="true">4.1.</strong> Project Structuring</a></li><li class="chapter-item expanded "><a href="../ch-04-project-structuring-and-error-handling/pg-02-modularizing.html"><strong aria-hidden="true">4.2.</strong> Modularizing</a></li><li class="chapter-item expanded "><a href="../ch-04-project-structuring-and-error-handling/pg-03-error-handling.html"><strong aria-hidden="true">4.3.</strong> Error Handling</a></li></ol></li><li class="chapter-item expanded "><a href="../ch-05-medium-concepts/main.html"><strong aria-hidden="true">5.</strong> Medium Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch-05-medium-concepts/pg-01-generics.html"><strong aria-hidden="true">5.1.</strong> Generics</a></li><li class="chapter-item expanded "><a href="../ch-05-medium-concepts/pg-02-traits.html"><strong aria-hidden="true">5.2.</strong> Traits</a></li><li class="chapter-item expanded "><a href="../ch-05-medium-concepts/pg-03-lifetimes.html"><strong aria-hidden="true">5.3.</strong> Lifetimes</a></li><li class="chapter-item expanded "><a href="../ch-05-medium-concepts/pg-04-functional-language-features.html"><strong aria-hidden="true">5.4.</strong> Functional Language Features</a></li><li class="chapter-item expanded "><a href="../ch-05-medium-concepts/pg-05-smart-pointers.html"><strong aria-hidden="true">5.5.</strong> Smart Pointers</a></li><li class="chapter-item expanded "><a href="../ch-05-medium-concepts/pg-06-concurrency.html"><strong aria-hidden="true">5.6.</strong> Concurrency</a></li><li class="chapter-item expanded "><a href="../ch-05-medium-concepts/pg-07-object-oriented-programming.html"><strong aria-hidden="true">5.7.</strong> Object Oriented Programming</a></li></ol></li><li class="chapter-item expanded "><a href="../ch-06-advanced-concepts/main.html"><strong aria-hidden="true">6.</strong> Advanced Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch-06-advanced-concepts/pg-01-advanced-pattern-matching.html"><strong aria-hidden="true">6.1.</strong> Advanced Pattern Matching</a></li><li class="chapter-item expanded "><a href="../ch-06-advanced-concepts/pg-02-unsafe-rust.html"><strong aria-hidden="true">6.2.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="../ch-06-advanced-concepts/pg-03-advanced-traits.html"><strong aria-hidden="true">6.3.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="../ch-06-advanced-concepts/pg-04-advanced-types.html"><strong aria-hidden="true">6.4.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="../ch-06-advanced-concepts/pg-05-advanced-functions-and-closures.html"><strong aria-hidden="true">6.5.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="../ch-06-advanced-concepts/pg-06-macros.html" class="active"><strong aria-hidden="true">6.6.</strong> Macros</a></li><li class="chapter-item expanded "><a href="../ch-06-advanced-concepts/pg-07-miscellaneous.html"><strong aria-hidden="true">6.7.</strong> Miscellaneous</a></li></ol></li><li class="chapter-item expanded "><a href="../ch-07-rust-tests/main.html"><strong aria-hidden="true">7.</strong> Rust Tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch-07-rust-tests/pg-01-getting-started.html"><strong aria-hidden="true">7.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="../ch-07-rust-tests/pg-02-controlling-tests.html"><strong aria-hidden="true">7.2.</strong> Controlling Tests</a></li><li class="chapter-item expanded "><a href="../ch-07-rust-tests/pg-03-test-organization.html"><strong aria-hidden="true">7.3.</strong> Test Organization</a></li><li class="chapter-item expanded "><a href="../ch-07-rust-tests/pg-04-test-driven-development.html"><strong aria-hidden="true">7.4.</strong> Test Driven Development</a></li></ol></li><li class="chapter-item expanded "><a href="../ch-08-useful-snippets/main.html"><strong aria-hidden="true">8.</strong> Useful Snippets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch-08-useful-snippets/pg-01-useful-operations.html"><strong aria-hidden="true">8.1.</strong> Useful Operations</a></li><li class="chapter-item expanded "><a href="../ch-08-useful-snippets/pg-02-useful-functions.html"><strong aria-hidden="true">8.2.</strong> Useful Functions</a></li><li class="chapter-item expanded "><a href="../ch-08-useful-snippets/pg-03-useful-macros.html"><strong aria-hidden="true">8.3.</strong> Useful Macros</a></li></ol></li><li class="chapter-item expanded "><a href="../ch-09-masq-rust-tools/main.html"><strong aria-hidden="true">9.</strong> MASQ Rust Tools</a></li><li class="chapter-item expanded "><a href="../ch-10-appendix/main.html"><strong aria-hidden="true">10.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch-10-appendix/pg-01-installation.html"><strong aria-hidden="true">10.1.</strong> Installaiton</a></li><li class="chapter-item expanded "><a href="../ch-10-appendix/pg-02-basic-rust-commands.html"><strong aria-hidden="true">10.2.</strong> Basic Rust Commands</a></li><li class="chapter-item expanded "><a href="../ch-10-appendix/pg-03-conventions-in-rust.html"><strong aria-hidden="true">10.3.</strong> Conventions in Rust</a></li><li class="chapter-item expanded "><a href="../ch-10-appendix/pg-04-documentation.html"><strong aria-hidden="true">10.4.</strong> Documentation</a></li><li class="chapter-item expanded "><a href="../ch-10-appendix/pg-05-cargo.html"><strong aria-hidden="true">10.5.</strong> Cargo</a></li><li class="chapter-item expanded "><a href="../ch-10-appendix/pg-06-editions-in-rust.html"><strong aria-hidden="true">10.6.</strong> Editions in Rust</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">MASQ Rust Docs</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="macros"><a class="header" href="#macros">Macros</a></h2>
<ul>
<li>
<p>Rust code that writes more rust code are called <em>Macros</em>. This kind of programming is called metaprogramming.</p>
</li>
<li>
<p>Here are the following things that you can only do with macros and not functions:</p>
<ul>
<li>Macros can take variable number of parameters, unlike functions. You can call <code>println!(&quot;hello&quot;)</code> with one argument or <code>println!(&quot;hello {}&quot;, name)</code> with two arguments.</li>
<li>Macros are expanded before the compiler interprets the meaning of the code. For example, macros can implement a trait on a given type. Functions can't because it gets called at runtime and a trait needs to be implemented at compile time.</li>
</ul>
</li>
<li>
<p>Drawbacks of Macros:</p>
<ul>
<li>It's hard to read, write and maintain.</li>
<li>You can define functions anywhere, but you need to bring the macros in scope before you can call them.</li>
</ul>
</li>
</ul>
<h4 id="declarative-macros"><a class="header" href="#declarative-macros">Declarative Macros</a></h4>
<ul>
<li>They are the most widely used types of macros.</li>
<li>Also referred to as &quot;macros by example&quot;, “<code>macro_rules!</code> macros”, or just plain “macros”.</li>
<li>They are similar to <code>match</code> statements, except they match on literal rust code, instead of some value.</li>
<li>Here is a simple implementation of the <code>vec!</code> macro:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>
<p>Explanation:</p>
<ul>
<li><code>#[macro_export]</code> - You can't export the macro without this line. For using this macro, you'll have to bring the crate into scope where this macro is defined.</li>
<li><code>macro_rules! name-of-macro</code> - Then we declare the macro with the <code>macro_rules!</code> along with the name of the macro without the exclamation mark. In our case, <code>vec</code>.</li>
<li><code>( $( $x:expr ),* ) =&gt;</code> - This is the match arm of the macro. In our case, the macro has only one match arm, if such an expression is passed to the macro which doesn't fall into it, it'll fail. Some complex macros will have multiple match arms.
<ul>
<li><code>( ) =&gt;</code> - A parantheses surrounds the whole pattern. It indicates that this is a match arm.</li>
<li><code>$( )</code> - Anything inside this parantheses will capture values.</li>
<li><code>$x: expr</code> - This matches any Rust expression and gives the expression the name <code>$x</code>.</li>
<li><code>,</code> - It means that the literal <code>,</code> might appear after the code that matches the code in <code>$()</code>.</li>
<li><code>*</code> - It means that the pattern matches zero or more of whatever precedes the <code>*</code>.</li>
<li><code>$()*</code> - For every time the expression in <code>$()</code> gets matched, the code inside <code>$()*</code> will get called.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>In Action:</p>
<ul>
<li>
<p>So, when we'll write <code>vec![1, 2, 3]</code> it will get compiled into, the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
  let mut temp_vec = Vec::new();
  temp_vec.push(1);
  temp_vec.push(2);
  temp_vec.push(3);
  temp_vec
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
</li>
</ul>
<p>Note: This vector that we created over here can take any number of arguments of any type. The implementation of <code>vec!</code> macro in standard library only accepts data of one type and it also has some extra code for preallocating memory for those types.</p>
<h4 id="procedural-macros"><a class="header" href="#procedural-macros">Procedural Macros</a></h4>
<ul>
<li>
<p>They act more like functions and they are a type of procedure.</p>
</li>
<li>
<p>They don't match against a pattern.</p>
</li>
<li>
<p>They simply accept some code, operates on it and produces some new code.</p>
</li>
<li>
<p>There are three kinds of procedural macros:</p>
<ul>
<li>Custom Derive</li>
<li>Attribute Like</li>
<li>Function Like</li>
</ul>
</li>
</ul>
<h5 id="custom-derive-macros"><a class="header" href="#custom-derive-macros">Custom Derive Macros</a></h5>
<ul>
<li>
<p>Using custom derive macros looks like this (it is used over structs or enums):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(HelloMacro)]
struct Pancakes;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Defining proceudral macros looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use proc_macro;

#[some_attribute] // This attribute tells us which kind of procedural macro we are creating
pub fn some_name(input: TokenStream) -&gt; TokenStream { // TokenStream is a type imported from the crate `proc_macro`. It represents a sequence of tokens.
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>An Example of a <em>Custom Derive</em> macro:</p>
<ul>
<li>
<p>What we want? We want to print the name of the struct which tries to call the function <code>hello_macro()</code>.</p>
<pre><pre class="playground"><code class="language-rust">use hello_macro::HelloMacro; // A trait which has an associated function hello_macro()
use hello_macro_derive::HelloMacro; // A macro that we can use

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro(); // This will print &quot;Hello, Macro! My name is Pancakes!&quot;
}</code></pre></pre>
</li>
<li>
<p>Part 1: Defining Traits</p>
<ul>
<li>
<p>First of all define the trait in different crate, created using <code>cargo new hello_macro --lib</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: src/lib.rs
pub trait HelloMacro {
    fn hello_macro();
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Then implement the trait for every struct (without using macro, this is what it looks like):</p>
<pre><pre class="playground"><code class="language-rust">// File: src/main.rs
use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!(&quot;Hello, Macro! My name is Pancakes!&quot;); // Programmer will have to implement this fn for each struct.
    }
}

fn main() {
    Pancakes::hello_macro();
}</code></pre></pre>
</li>
<li>
<p>Additionally, we can’t yet provide the <code>hello_macro</code> function with default implementation that will print the name of the type the trait is implemented on: Rust doesn’t have reflection capabilities, so it can’t look up the type’s name at runtime.</p>
</li>
</ul>
</li>
<li>
<p>Part 2: Implementing Procedural Macros</p>
<ul>
<li>
<p>At the time of this writing, procedural macros need to be in their own crate. Eventually, this restriction might be lifted. So, first create a new crate using:</p>
<pre><code class="language-zsh">cargo new hello_macro_derive --lib
</code></pre>
</li>
<li>
<p>This trait will work in parallel with the trait defined above. Both the traits are tightly related. Hence we'll have to keep both the crates (<code>hello_macro</code> and <code>hello_macro_derive</code>) in one directory. In case someone wants to use the macro, they'll have to pull both the crates as dependencies.</p>
</li>
<li>
<p>So inside the <code>cargo.toml</code> file of the crate <code>hello_macro_derive</code>, add the following lines:</p>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = &quot;1.0&quot;
quote = &quot;1.0&quot;
</code></pre>
</li>
<li>
<p>Now, we can define the macro inside the <code>src/lib.rs</code> file of the crate <code>hello_macro_derive</code>. The code for most of the procedural macros will be same as the code block below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Filename: src/lib.rs
use proc_macro::TokenStream; // this crate, proc_macro comes with rust, it allows to read and manipulate rust code from our code
use quote::quote; // Transforms DeriveInput -&gt; Rust Code
use syn; // Transforms Rust Code -&gt; DeriveInput

#[proc_macro_derive(HelloMacro)] // This line makes sure that whenever a user specifies #[derive(HelloMacro)] on a type, it calls the below fn
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_hello_macro(&amp;ast)
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Once the line <code>let ast = syn::parse(input).unwrap();</code> is executed (let's say for the <code>struct Pancakes {};</code>), it creates a <code>DeriveInput</code> struct, which looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>DeriveInput {
    // --snip--

    ident: Ident {
        ident: &quot;Pancakes&quot;,
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
</li>
<li>
<p>Now, we can convert the <code>DeriveInput</code> into <code>TokenStream</code> using the function <code>impl_hello_macro(&amp;ast)</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let name = &amp;ast.ident; // type is not &amp;str but &amp;syn::Ident
    let gen = quote! { // it turns Rust syntax tree data structures into tokens of source code
        impl HelloMacro for #name {
            fn hello_macro() {
                println!(&quot;Hello, Macro! My name is {}!&quot;, stringify!(#name)); // quote! is used here to replace #name with the value in the variable name
            }
        }
    };

    gen.into() // quote! can't directly convert into TokenStream so we call into()
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>The <code>stringify!</code> macro used here is built into Rust. It takes a Rust expression, such as <code>1 + 2</code>, and at compile time turns the expression into a string literal, such as <code>&quot;1 + 2&quot;</code>. This is different than <code>format!</code> or <code>println!</code>, macros which evaluate the expression and then turn the result into a String.</p>
</li>
<li>
<p>Now, we can create a crate named <code>pancakes</code> and then use our macro inside of it.</p>
<pre><code class="language-zsh">cargo new pancakes
</code></pre>
</li>
<li>
<p>The file structure should be like this:</p>
<pre><code class="language-zsh">.
├── hello_macro
│   ├── hello_macro_derive
│   │   └── ..
│   └── ..
└── pancakes
    └── ..
</code></pre>
</li>
<li>
<p>Then migrate the code as explained in the starting of this example to <code>src/main.rs</code>, and also add these lines to the dependencies:</p>
<pre><code class="language-toml">hello_macro = { path = &quot;../hello_macro&quot; }
hello_macro_derive = { path = &quot;../hello_macro/hello_macro_derive&quot; }
</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="attribute-like-macros"><a class="header" href="#attribute-like-macros">Attribute Like Macros</a></h5>
<ul>
<li>
<p>In Custom Derive Macros, the <code>derive</code> keyword is used and it generates some new code for the struct or enum.</p>
</li>
<li>
<p>Instead of generating new code, Attribute like macros allow you to create new attributes.</p>
</li>
<li>
<p>Unlike Custom Derive Macros, Attribute like macros are not limited to just structs or enums and can be applied to other items, such as functions.</p>
</li>
<li>
<p>Here's an example of how it can be used on a function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[route(GET, &quot;/&quot;)]
fn index() {
  ..
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>This <code>#[route]</code> attribute would be defined by the framework as a procedural macro. The signature of the macro definition function would look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {
  // attr: The GET, &quot;/&quot; will get stored in this argument
  // item: The code attached to above macro (fn index() {} in our case) will get stored in this argument
  ..
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Other than that, attribute-like macros work the same way as custom derive macros: you create a crate with the <code>proc-macro</code> crate type and implement a function that generates the code you want!</p>
</li>
</ul>
<h5 id="function-like-macros"><a class="header" href="#function-like-macros">Function Like Macros</a></h5>
<ul>
<li>
<p>These macros look like function calls but with a <code>!</code>.</p>
</li>
<li>
<p>They're more flexible than functions as they can accept variable number of arguments.</p>
</li>
<li>
<p>In declarative macros (<code>macro_rules !</code> macro) uses match-like syntax, the Function Like Macros take a <code>TokenStream</code> parameter, similar to the other two procedural macros.</p>
</li>
<li>
<p>Here's an example, here we want to parse SQL code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sql = sql!(SELECT * FROM posts WHERE id=1);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>If we tried to build this macro with the <code>macro_rules !</code> macro, then match-like pattern would've made it hard to implement. With using <code>TokenStream</code> it is a bit easier to implement:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {
  ..
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>It's implementation is closer to that of custom derive macros.</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../ch-06-advanced-concepts/pg-05-advanced-functions-and-closures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../ch-06-advanced-concepts/pg-07-miscellaneous.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../ch-06-advanced-concepts/pg-05-advanced-functions-and-closures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../ch-06-advanced-concepts/pg-07-miscellaneous.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
